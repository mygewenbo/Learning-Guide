# 事件发射器与自定义事件

## 1. EventEmitter 基础

EventEmitter 是 Node.js 中实现事件驱动编程的核心类，它允许对象发射和监听事件。

### 1.1 基本概念

- **事件**：是一种信号，表示某个事情已经发生。
- **事件发射器**：负责发射事件的对象。
- **事件监听器**：负责监听事件并处理事件的函数。
- **事件驱动编程**：一种编程范式，程序的执行流程由事件决定。

### 1.2 创建 EventEmitter 实例

```javascript
// ES Modules
import { EventEmitter } from 'node:events';

// CommonJS
const EventEmitter = require('node:events');

// 创建 EventEmitter 实例
const myEmitter = new EventEmitter();
```

### 1.3 注册事件监听器

使用 `on()` 或 `addListener()` 方法注册事件监听器：

```javascript
// 注册单个事件监听器
myEmitter.on('event', () => {
  console.log('事件被触发！');
});

// 注册只执行一次的事件监听器
myEmitter.once('event', () => {
  console.log('这个监听器只会执行一次！');
});
```

### 1.4 发射事件

使用 `emit()` 方法发射事件：

```javascript
// 发射事件
myEmitter.emit('event');
// 输出: 事件被触发！
// 输出: 这个监听器只会执行一次！

// 再次发射事件
myEmitter.emit('event');
// 输出: 事件被触发！
// 注意：once 注册的监听器不会再次执行
```

## 2. 事件监听器管理

### 2.1 移除事件监听器

使用 `removeListener()` 或 `off()` 方法移除事件监听器：

```javascript
function listener() {
  console.log('事件被触发！');
}

// 注册监听器
myEmitter.on('event', listener);

// 移除监听器
myEmitter.off('event', listener);
// 或使用 removeListener
// myEmitter.removeListener('event', listener);

// 发射事件，不会有输出
myEmitter.emit('event');
```

### 2.2 移除所有监听器

使用 `removeAllListeners()` 方法移除所有监听器：

```javascript
// 移除指定事件的所有监听器
myEmitter.removeAllListeners('event');

// 移除所有事件的所有监听器
myEmitter.removeAllListeners();
```

### 2.3 获取监听器数量

使用 `listenerCount()` 方法获取监听器数量：

```javascript
myEmitter.on('event', () => {});
myEmitter.on('event', () => {});

console.log(myEmitter.listenerCount('event')); // 输出: 2
```

### 2.4 获取监听器列表

使用 `listeners()` 方法获取监听器列表：

```javascript
function listener1() {}
function listener2() {}

myEmitter.on('event', listener1);
myEmitter.on('event', listener2);

console.log(myEmitter.listeners('event')); // 输出: [ [Function: listener1], [Function: listener2] ]
```

## 3. 事件传递参数

### 3.1 传递参数给监听器

```javascript
myEmitter.on('event', (arg1, arg2) => {
  console.log(`事件被触发，参数: ${arg1}, ${arg2}`);
});

// 发射事件并传递参数
myEmitter.emit('event', '参数1', '参数2');
// 输出: 事件被触发，参数: 参数1, 参数2
```

### 3.2 监听器中的 this 上下文

- 使用普通函数作为监听器时，`this` 指向 EventEmitter 实例。
- 使用箭头函数作为监听器时，`this` 指向定义时的上下文。

```javascript
myEmitter.on('event', function() {
  console.log('this 指向 EventEmitter 实例:', this === myEmitter); // 输出: true
});

myEmitter.on('event', () => {
  console.log('箭头函数中的 this:', this); // 输出: {} 或 undefined，取决于执行环境
});

myEmitter.emit('event');
```

## 4. 事件监听器执行顺序

### 4.1 默认执行顺序

事件监听器按照注册顺序执行：

```javascript
myEmitter.on('event', () => {
  console.log('监听器1 执行');
});

myEmitter.on('event', () => {
  console.log('监听器2 执行');
});

myEmitter.on('event', () => {
  console.log('监听器3 执行');
});

myEmitter.emit('event');
// 输出顺序:
// 监听器1 执行
// 监听器2 执行
// 监听器3 执行
```

### 4.2 前置监听器

使用 `prependListener()` 方法将监听器添加到监听器列表的开头：

```javascript
myEmitter.on('event', () => {
  console.log('监听器1 执行');
});

// 添加到开头
myEmitter.prependListener('event', () => {
  console.log('前置监听器 执行');
});

myEmitter.on('event', () => {
  console.log('监听器2 执行');
});

myEmitter.emit('event');
// 输出顺序:
// 前置监听器 执行
// 监听器1 执行
// 监听器2 执行
```

## 5. 异步事件处理

### 5.1 同步执行

默认情况下，EventEmitter 同步执行所有监听器：

```javascript
myEmitter.on('event', () => {
  console.log('监听器1 开始');
  // 模拟耗时操作
  for (let i = 0; i < 1000000000; i++) {
    // 空循环
  }
  console.log('监听器1 结束');
});

myEmitter.on('event', () => {
  console.log('监听器2 执行');
});

console.log('开始发射事件');
myEmitter.emit('event');
console.log('事件发射完成');

// 输出顺序:
// 开始发射事件
// 监听器1 开始
// 监听器1 结束
// 监听器2 执行
// 事件发射完成
```

### 5.2 异步执行

如果需要异步执行监听器，可以使用 `setImmediate()` 或 `process.nextTick()`：

```javascript
myEmitter.on('event', () => {
  setImmediate(() => {
    console.log('监听器1 异步执行');
  });
});

myEmitter.on('event', () => {
  process.nextTick(() => {
    console.log('监听器2 异步执行');
  });
});

console.log('开始发射事件');
myEmitter.emit('event');
console.log('事件发射完成');

// 输出顺序:
// 开始发射事件
// 事件发射完成
// 监听器2 异步执行 (process.nextTick 优先级更高)
// 监听器1 异步执行 (setImmediate 优先级较低)
```

## 6. 自定义事件类

### 6.1 继承 EventEmitter

创建自定义类继承 EventEmitter：

```javascript
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {
  constructor() {
    super();
  }

  doSomething() {
    console.log('正在执行操作...');
    // 发射自定义事件
    this.emit('done', '操作结果');
  }
}

// 使用自定义事件类
const myEmitter = new MyEmitter();

myEmitter.on('done', (result) => {
  console.log('操作完成，结果:', result);
});

myEmitter.doSomething();
// 输出:
// 正在执行操作...
// 操作完成，结果: 操作结果
```

### 6.2 实际应用示例

创建一个简单的文件监听器类：

```javascript
import { EventEmitter } from 'node:events';
import { watch } from 'node:fs';

class FileWatcher extends EventEmitter {
  constructor(filePath) {
    super();
    this.filePath = filePath;
    this.watcher = null;
  }

  start() {
    this.watcher = watch(this.filePath, (eventType, filename) => {
      this.emit('change', { eventType, filename });
    });
    console.log(`开始监听文件: ${this.filePath}`);
    this.emit('start', this.filePath);
  }

  stop() {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
      console.log(`停止监听文件: ${this.filePath}`);
      this.emit('stop', this.filePath);
    }
  }
}

// 使用文件监听器
const watcher = new FileWatcher('test.txt');

watcher.on('start', (filePath) => {
  console.log(`文件监听器已启动，监听: ${filePath}`);
});

watcher.on('change', (info) => {
  console.log(`文件变化: ${info.filename}, 事件类型: ${info.eventType}`);
});

watcher.on('stop', (filePath) => {
  console.log(`文件监听器已停止，监听: ${filePath}`);
});

// 启动监听器
watcher.start();

// 5秒后停止监听器
setTimeout(() => {
  watcher.stop();
}, 5000);
```

## 7. 事件发射器的高级特性

### 7.1 事件捕获

EventEmitter 支持事件捕获模式，使用 `captureRejections` 选项：

```javascript
const myEmitter = new EventEmitter({ captureRejections: true });

myEmitter.on('event', async () => {
  throw new Error('异步错误');
});

myEmitter.on('error', (err) => {
  console.error('捕获到错误:', err);
});

myEmitter.emit('event');
```

### 7.2 事件发射器异步资源

使用 `EventEmitterAsyncResource` 类创建支持异步上下文跟踪的事件发射器：

```javascript
import { EventEmitterAsyncResource } from 'node:events';
import { executionAsyncId } from 'node:async_hooks';

// 创建支持异步上下文的事件发射器
const ee = new EventEmitterAsyncResource({ name: 'MyEmitter' });

// 监听器将在事件发射器的异步上下文中执行
ee.on('event', () => {
  console.log('执行异步 ID:', executionAsyncId());
  console.log('是否与事件发射器异步 ID 相同:', executionAsyncId() === ee.asyncId);
});

// 在不同的异步上下文中发射事件
setTimeout(() => {
  ee.emit('event');
}, 100);
```

### 7.3 事件监听器最大数量

EventEmitter 默认限制每个事件最多 10 个监听器，可以使用 `setMaxListeners()` 方法修改：

```javascript
// 获取当前最大监听器数量
console.log(myEmitter.getMaxListeners()); // 输出: 10

// 修改最大监听器数量
myEmitter.setMaxListeners(20);

// 为所有事件发射器设置默认最大监听器数量
EventEmitter.defaultMaxListeners = 20;
```

## 8. 事件流控制

### 8.1 事件监听器执行控制

使用 `events.once()` 方法等待单个事件：

```javascript
import { once, EventEmitter } from 'node:events';

const myEmitter = new EventEmitter();

async function waitForEvent() {
  console.log('等待事件...');
  const [result] = await once(myEmitter, 'event');
  console.log('事件发生，结果:', result);
}

waitForEvent();

// 1秒后发射事件
setTimeout(() => {
  myEmitter.emit('event', '事件数据');
}, 1000);
```

### 8.2 异步迭代事件

使用 `events.on()` 方法创建事件的异步迭代器：

```javascript
import { on, EventEmitter } from 'node:events';
import process from 'node:process';

const myEmitter = new EventEmitter();

// 每秒发射一个事件
let count = 0;
const interval = setInterval(() => {
  myEmitter.emit('event', count++);
  if (count === 5) {
    clearInterval(interval);
  }
}, 1000);

async function iterateEvents() {
  // 使用 for await...of 迭代事件
  for await (const [value] of on(myEmitter, 'event')) {
    console.log('接收到事件:', value);
    if (value === 4) {
      break;
    }
  }
  console.log('事件迭代完成');
}

iterateEvents();
```

## 9. 实际应用场景

### 9.1 HTTP 服务器事件

Node.js 的 HTTP 服务器是基于 EventEmitter 实现的：

```javascript
import http from 'node:http';

const server = http.createServer();

// 监听请求事件
server.on('request', (req, res) => {
  console.log(`收到请求: ${req.method} ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello, World!');
});

// 监听连接事件
server.on('connection', (socket) => {
  console.log('新的连接');
});

// 监听关闭事件
server.on('close', () => {
  console.log('服务器关闭');
});

server.listen(3000, () => {
  console.log('服务器运行在 http://localhost:3000');
});
```

### 9.2 自定义日志系统

```javascript
import { EventEmitter } from 'node:events';
import fs from 'node:fs/promises';

class Logger extends EventEmitter {
  constructor(logFile) {
    super();
    this.logFile = logFile;
    this.setupListeners();
  }

  setupListeners() {
    // 监听不同级别的日志事件
    this.on('log', this.writeLog.bind(this, 'LOG'));
    this.on('info', this.writeLog.bind(this, 'INFO'));
    this.on('warn', this.writeLog.bind(this, 'WARN'));
    this.on('error', this.writeLog.bind(this, 'ERROR'));
  }

  async writeLog(level, message) {
    const timestamp = new Date().toISOString();
    const logLine = `${timestamp} [${level}] ${message}\n`;
    
    try {
      await fs.appendFile(this.logFile, logLine);
      // 同时输出到控制台
      console[level.toLowerCase() || 'log'](logLine.trim());
    } catch (err) {
      console.error('写入日志失败:', err);
    }
  }

  // 便捷方法
  log(message) { this.emit('log', message); }
  info(message) { this.emit('info', message); }
  warn(message) { this.emit('warn', message); }
  error(message) { this.emit('error', message); }
}

// 使用自定义日志系统
const logger = new Logger('app.log');

logger.log('普通日志消息');
logger.info('信息日志消息');
logger.warn('警告日志消息');
logger.error('错误日志消息');
```

## 10. 最佳实践

1. **命名规范**：使用清晰、描述性的事件名称，避免使用保留字。
2. **错误处理**：始终监听 `error` 事件，避免程序崩溃。
3. **资源管理**：及时移除不再需要的事件监听器，避免内存泄漏。
4. **避免过度使用**：不要将 EventEmitter 用于所有通信，对于简单的函数调用，直接调用函数更高效。
5. **异步安全**：注意事件监听器的同步/异步执行顺序，避免竞态条件。
6. **文档化**：为自定义事件类编写清晰的文档，说明支持的事件和参数。
7. **测试**：测试事件发射器的各种场景，包括正常情况和异常情况。
8. **使用 TypeScript**：TypeScript 可以提供更好的类型检查和编辑器支持。

## 11. 总结

EventEmitter 是 Node.js 中实现事件驱动编程的核心机制，它提供了一种优雅的方式来处理对象之间的通信。通过掌握 EventEmitter 的高级特性，你可以编写更加灵活、可扩展的 Node.js 应用程序。

- EventEmitter 允许对象发射和监听事件，实现了发布-订阅模式。
- 可以通过继承 EventEmitter 来创建自定义事件类。
- 事件监听器可以是同步的，也可以是异步的。
- 提供了丰富的方法来管理事件监听器，如添加、移除、获取等。
- 支持事件捕获、异步上下文跟踪等高级特性。
- 广泛应用于 Node.js 核心模块和第三方库中，如 HTTP 服务器、文件系统等。

通过不断实践和学习，你将能够熟练运用 EventEmitter 来构建事件驱动的 Node.js 应用，提高应用的可扩展性和可维护性。