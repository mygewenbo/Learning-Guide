# 异步编程进阶(Promise/async/await)

## 1. Promise 基础

Promise 是 JavaScript 中处理异步操作的对象，它代表了一个异步操作的最终完成或失败，及其结果值。

### 1.1 Promise 的三种状态

- **Pending（进行中）**：初始状态，既不是成功，也不是失败状态。
- **Fulfilled（已成功）**：意味着操作成功完成。
- **Rejected（已失败）**：意味着操作失败。

### 1.2 Promise 基本用法

```javascript
// 创建 Promise
const promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve('操作成功'); // 成功时调用 resolve
    } else {
      reject(new Error('操作失败')); // 失败时调用 reject
    }
  }, 1000);
});

// 使用 Promise
promise
  .then(result => {
    console.log('成功:', result);
  })
  .catch(error => {
    console.error('失败:', error);
  })
  .finally(() => {
    console.log('操作完成，无论成功或失败都会执行');
  });
```

## 2. Promise 链式调用

Promise 的 `then` 方法返回一个新的 Promise，这使得我们可以链式调用多个异步操作。

```javascript
// 链式调用示例
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log('获取数据成功:', data);
    return fetch(`https://api.example.com/users/${data.userId}`);
  })
  .then(response => response.json())
  .then(user => {
    console.log('获取用户信息成功:', user);
  })
  .catch(error => {
    console.error('请求失败:', error);
  });
```

## 3. Promise 静态方法

### 3.1 Promise.all()

用于并行处理多个 Promise，只有当所有 Promise 都成功时才会成功，否则失败。

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then(values => {
    console.log('所有 Promise 成功:', values); // [1, 2, 3]
  })
  .catch(error => {
    console.error('至少一个 Promise 失败:', error);
  });
```

### 3.2 Promise.race()

返回第一个完成的 Promise 的结果，无论成功或失败。

```javascript
const promise1 = new Promise(resolve => setTimeout(resolve, 1000, '慢的 Promise'));
const promise2 = new Promise(resolve => setTimeout(resolve, 500, '快的 Promise'));

Promise.race([promise1, promise2])
  .then(value => {
    console.log('第一个完成的 Promise:', value); // '快的 Promise'
  });
```

### 3.3 Promise.allSettled()

返回所有 Promise 的结果，无论成功或失败。

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(new Error('失败'));
const promise3 = Promise.resolve(3);

Promise.allSettled([promise1, promise2, promise3])
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('成功:', result.value);
      } else {
        console.error('失败:', result.reason);
      }
    });
  });
```

### 3.4 Promise.any()

返回第一个成功的 Promise 的结果，如果所有 Promise 都失败，则返回一个 AggregateError。

```javascript
const promise1 = Promise.reject(new Error('失败1'));
const promise2 = Promise.reject(new Error('失败2'));
const promise3 = Promise.resolve('成功');

Promise.any([promise1, promise2, promise3])
  .then(value => {
    console.log('第一个成功的 Promise:', value); // '成功'
  })
  .catch(error => {
    console.error('所有 Promise 都失败:', error);
  });
```

## 4. async/await 语法

async/await 是基于 Promise 的语法糖，让异步代码看起来更像同步代码。

### 4.1 async 函数

`async` 关键字用于声明异步函数，异步函数总是返回一个 Promise。

```javascript
async function fetchData() {
  return '数据'; // 相当于 return Promise.resolve('数据');
}

fetchData().then(data => {
  console.log(data); // '数据'
});
```

### 4.2 await 关键字

`await` 关键字用于等待 Promise 解决，只能在 async 函数中使用。

```javascript
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log('获取数据成功:', data);
    return data;
  } catch (error) {
    console.error('请求失败:', error);
    throw error;
  }
}

fetchData();
```

### 4.3 async/await 与 Promise.all() 结合

```javascript
async function fetchMultipleData() {
  const [user, posts, comments] = await Promise.all([
    fetch('https://api.example.com/user').then(res => res.json()),
    fetch('https://api.example.com/posts').then(res => res.json()),
    fetch('https://api.example.com/comments').then(res => res.json())
  ]);

  console.log('用户:', user);
  console.log('文章:', posts);
  console.log('评论:', comments);
}

fetchMultipleData();
```

## 5. 错误处理

### 5.1 try/catch 块

在 async 函数中，可以使用 try/catch 块来捕获错误。

```javascript
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error(`HTTP 错误! 状态: ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('获取数据失败:', error);
    return null;
  }
}
```

### 5.2 处理多个 await 错误

```javascript
async function fetchMultipleData() {
  try {
    const user = await fetch('https://api.example.com/user').then(res => res.json());
    const posts = await fetch('https://api.example.com/posts').then(res => res.json());
    return { user, posts };
  } catch (error) {
    console.error('获取数据失败:', error);
    return { user: null, posts: null };
  }
}
```

## 6. 实际应用场景

### 6.1 异步文件操作

```javascript
const fs = require('fs').promises;

async function readFiles() {
  try {
    const [file1, file2] = await Promise.all([
      fs.readFile('file1.txt', 'utf8'),
      fs.readFile('file2.txt', 'utf8')
    ]);
    console.log('文件1内容:', file1);
    console.log('文件2内容:', file2);
  } catch (error) {
    console.error('读取文件失败:', error);
  }
}

readFiles();
```

### 6.2 数据库操作

```javascript
const mysql = require('mysql2/promise');

async function queryDatabase() {
  const connection = await mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'test'
  });

  try {
    const [rows] = await connection.execute('SELECT * FROM users WHERE id = ?', [1]);
    console.log('查询结果:', rows[0]);
  } catch (error) {
    console.error('数据库查询失败:', error);
  } finally {
    await connection.end();
  }
}

queryDatabase();
```

## 7. 最佳实践

1. **始终处理 Promise 拒绝**：使用 `.catch()` 或 try/catch 块来处理错误。
2. **避免 Promise 地狱**：使用链式调用或 async/await 来保持代码清晰。
3. **使用 Promise.all() 并行处理**：对于独立的异步操作，使用 Promise.all() 可以提高性能。
4. **限制并发请求**：对于大量的异步操作，考虑使用限流机制。
5. **使用 async/await 提高可读性**：在大多数情况下，async/await 比链式调用更易读。
6. **避免在循环中使用 await**：对于循环中的异步操作，考虑使用 Promise.all()。
7. **使用 TypeScript**：TypeScript 可以提供更好的类型检查和编辑器支持。

## 8. 总结

Promise 和 async/await 是 Node.js 中处理异步操作的核心机制，它们让异步代码更加可控和可读。通过掌握这些高级特性，你可以编写更加高效、可靠的 Node.js 应用程序。

- Promise 提供了一种优雅的方式来处理异步操作的结果。
- async/await 让异步代码看起来更像同步代码，提高了可读性。
- Promise 静态方法（如 Promise.all()、Promise.race() 等）提供了处理多个异步操作的便捷方式。
- 良好的错误处理是编写可靠异步代码的关键。

通过不断实践和学习，你将能够熟练运用这些异步编程技术，构建高性能、可维护的 Node.js 应用。