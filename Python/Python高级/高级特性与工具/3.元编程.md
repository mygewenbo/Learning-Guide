# 元编程

## 1. 元编程概述

元编程是指编写能够操作其他程序或自身的程序。在Python中，元编程允许我们：
- 动态创建类和函数
- 修改类和函数的行为
- 拦截属性访问
- 实现装饰器和元类

元编程是Python高级编程中的重要概念，它可以帮助我们编写更灵活、更强大的代码。

## 2. 装饰器

装饰器是Python中最常用的元编程工具之一，它允许我们在不修改原函数代码的情况下，增强函数的功能。

### 2.1 基本装饰器

```python
# 基本装饰器
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

# 调用装饰后的函数
result = add(2, 3)
# 输出:
# Calling add
# add returned 5
```

### 2.2 带参数的装饰器

```python
# 带参数的装饰器
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(n):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    return f"Hello, {name}!"

# 调用装饰后的函数
results = greet("Alice")
print(results)  # ['Hello, Alice!', 'Hello, Alice!', 'Hello, Alice!']
```

### 2.3 类装饰器

```python
# 类装饰器
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.call_count = 0
    
    def __call__(self, *args, **kwargs):
        self.call_count += 1
        print(f"Call {self.call_count} to {self.func.__name__}")
        return self.func(*args, **kwargs)

@CountCalls
def multiply(a, b):
    return a * b

# 调用装饰后的函数
print(multiply(2, 3))  # Call 1 to multiply, 6
print(multiply(4, 5))  # Call 2 to multiply, 20
print(multiply.call_count)  # 2
```

### 2.4 保留原函数元数据

```python
# 保留原函数元数据
from functools import wraps

def my_decorator(func):
    @wraps(func)  # 保留原函数的元数据
    def wrapper(*args, **kwargs):
        """Wrapper function"""
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Greet someone"""
    return f"Hello, {name}!"

print(greet.__name__)  # greet (不是wrapper)
print(greet.__doc__)   # Greet someone (不是Wrapper function)
```

## 3. 描述符

描述符是实现了`__get__`、`__set__`或`__delete__`方法的对象，用于控制属性访问。

### 3.1 基本描述符

```python
# 基本描述符
class Descriptor:
    def __get__(self, instance, owner):
        print(f"Getting value")
        return self.value
    
    def __set__(self, instance, value):
        print(f"Setting value to {value}")
        self.value = value
    
    def __delete__(self, instance):
        print(f"Deleting value")
        del self.value

class MyClass:
    attr = Descriptor()

# 使用描述符
obj = MyClass()
obj.attr = 10  # Setting value to 10
print(obj.attr)  # Getting value, 10
del obj.attr  # Deleting value
```

### 3.2 数据描述符和非数据描述符

- **数据描述符**：实现了`__get__`和`__set__`方法
- **非数据描述符**：只实现了`__get__`方法

```python
# 非数据描述符
class NonDataDescriptor:
    def __get__(self, instance, owner):
        print(f"Getting value from non-data descriptor")
        return 42

class MyClass:
    data_desc = Descriptor()  # 数据描述符
    non_data_desc = NonDataDescriptor()  # 非数据描述符

obj = MyClass()
obj.data_desc = 10  # 调用数据描述符的__set__
obj.non_data_desc = 20  # 直接设置实例属性，不会调用非数据描述符的__set__
print(obj.data_desc)  # 调用数据描述符的__get__
print(obj.non_data_desc)  # 直接访问实例属性，不会调用非数据描述符的__get__
```

### 3.3 描述符协议

描述符协议定义了三个方法：

```python
# 描述符协议
def __get__(self, instance, owner):
    """
    当访问属性时调用
    instance: 实例对象，如果是通过类访问则为None
    owner: 类对象
    """
    pass

def __set__(self, instance, value):
    """
    当设置属性时调用
    instance: 实例对象
    value: 要设置的值
    """
    pass

def __delete__(self, instance):
    """
    当删除属性时调用
    instance: 实例对象
    """
    pass
```

### 3.4 内置描述符

Python内置了一些描述符：

```python
# 内置描述符 - property
class MyClass:
    def __init__(self):
        self._x = 0
    
    @property
    def x(self):
        """Getter for x"""
        return self._x
    
    @x.setter
    def x(self, value):
        """Setter for x"""
        if value < 0:
            raise ValueError("x must be non-negative")
        self._x = value
    
    @x.deleter
    def x(self):
        """Deleter for x"""
        del self._x

obj = MyClass()
obj.x = 10  # 调用setter
print(obj.x)  # 调用getter，输出10
# obj.x = -5  # 引发ValueError
del obj.x  # 调用deleter
```

## 4. 元类

元类是创建类的类，它控制类的创建过程。在Python中，默认的元类是`type`。

### 4.1 基本元类

```python
# 基本元类
class Meta(type):
    def __new__(cls, name, bases, dct):
        print(f"Creating class {name}")
        # 可以在创建类之前修改dct
        dct['added_attr'] = 42
        return super().__new__(cls, name, bases, dct)
    
    def __init__(cls, name, bases, dct):
        print(f"Initializing class {name}")
        super().__init__(name, bases, dct)

# 使用元类
class MyClass(metaclass=Meta):
    x = 10

# 创建子类
class MySubclass(MyClass):
    y = 20

# 访问添加的属性
print(MyClass.added_attr)  # 42
print(MySubclass.added_attr)  # 42
```

### 4.2 元类的应用

元类可以用于：
- 自动添加方法或属性
- 验证类的结构
- 实现单例模式
- 实现ORM框架

```python
# 使用元类实现单例模式
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class SingletonClass(metaclass=SingletonMeta):
    def __init__(self, value):
        self.value = value

# 创建单例实例
instance1 = SingletonClass(10)
instance2 = SingletonClass(20)

print(instance1 is instance2)  # True
print(instance1.value)  # 10 (不是20，因为第二次调用没有创建新实例)
```

### 4.3 元类与继承

```python
# 元类与继承
class MetaA(type):
    pass

class ClassA(metaclass=MetaA):
    pass

# 子类会继承父类的元类
class ClassB(ClassA):
    pass

print(type(ClassA))  # <class '__main__.MetaA'>
print(type(ClassB))  # <class '__main__.MetaA'>

# 可以显式指定不同的元类
class MetaB(type):
    pass

class ClassC(ClassA, metaclass=MetaB):
    pass

print(type(ClassC))  # <class '__main__.MetaB'>
```

### 4.4 特殊方法查找

Python的特殊方法查找有一些特殊规则：

```python
# 特殊方法查找绕过__getattribute__
class Meta(type):
    def __getattribute__(*args):
        print("Metaclass getattribute invoked")
        return type.__getattribute__(*args)

class C(object, metaclass=Meta):
    def __len__(self):
        return 10
    
    def __getattribute__(*args):
        print("Class getattribute invoked")
        return object.__getattribute__(*args)

c = C()
c.__len__()                 # 显式调用，会触发__getattribute__
type(c).__len__(c)          # 显式调用，会触发__getattribute__
len(c)                      # 隐式调用，绕过__getattribute__
```

## 5. 动态创建类

Python允许我们在运行时动态创建类。

### 5.1 使用type()函数

```python
# 使用type()动态创建类

# 定义类的属性和方法
class_attrs = {
    'x': 10,
    'y': 20,
    'add': lambda self: self.x + self.y
}

# 动态创建类
DynamicClass = type('DynamicClass', (object,), class_attrs)

# 使用动态创建的类
obj = DynamicClass()
print(obj.x)  # 10
print(obj.y)  # 20
print(obj.add())  # 30
```

### 5.2 使用type()创建带有复杂方法的类

```python
# 动态创建带有复杂方法的类

def say_hello(self):
    return f"Hello from {self.name}"

class_attrs = {
    'name': 'DynamicClass',
    'say_hello': say_hello
}

DynamicClass = type('DynamicClass', (object,), class_attrs)

obj = DynamicClass()
print(obj.say_hello())  # Hello from DynamicClass
```

### 5.3 使用types模块

```python
# 使用types模块动态创建函数和类
import types

# 动态创建函数
def dynamic_func(self, x, y):
    return x + y

# 创建类
class MyClass:
    pass

# 动态添加方法
MyClass.dynamic_method = types.MethodType(dynamic_func, None, MyClass)

obj = MyClass()
print(obj.dynamic_method(2, 3))  # 5
```

## 6. 反射

反射是指在运行时动态地访问、检查和修改对象的属性和方法。

### 6.1 基本反射函数

```python
# 基本反射函数
class MyClass:
    def __init__(self):
        self.x = 10
        self.y = 20
    
    def add(self):
        return self.x + self.y

obj = MyClass()

# getattr() - 获取属性或方法
print(getattr(obj, 'x'))  # 10
print(getattr(obj, 'add')())  # 30
print(getattr(obj, 'z', 30))  # 30 (默认值)

# setattr() - 设置属性
setattr(obj, 'z', 40)
print(obj.z)  # 40

# delattr() - 删除属性
delattr(obj, 'z')
# print(obj.z)  # AttributeError

# hasattr() - 检查属性是否存在
print(hasattr(obj, 'x'))  # True
print(hasattr(obj, 'z'))  # False
```

### 6.2 动态导入模块

```python
# 动态导入模块

# 使用importlib
import importlib

# 动态导入模块
math_module = importlib.import_module('math')
print(math_module.sqrt(16))  # 4.0

# 动态导入模块中的属性
sqrt = getattr(math_module, 'sqrt')
print(sqrt(25))  # 5.0

# 使用__import__
math_module = __import__('math')
print(math_module.pi)  # 3.141592653589793
```

### 6.3 检查对象类型

```python
# 检查对象类型

# isinstance() - 检查对象是否是某个类的实例
print(isinstance(10, int))  # True
print(isinstance('hello', str))  # True
print(isinstance([], list))  # True

# issubclass() - 检查类是否是某个类的子类
print(issubclass(list, object))  # True
print(issubclass(dict, object))  # True
print(issubclass(int, float))  # False

# type() - 获取对象的类型
print(type(10))  # <class 'int'>
print(type('hello'))  # <class 'str'>
print(type([]))  # <class 'list'>
```

## 7. AST操作

AST（抽象语法树）是Python代码的抽象表示，我们可以在运行时修改AST来改变代码的行为。

### 7.1 解析和生成AST

```python
# 解析和生成AST
import ast

# 解析代码为AST
source_code = "print('Hello, World!')"
ast_tree = ast.parse(source_code)

# 打印AST
print(ast.dump(ast_tree, indent=2))

# 生成代码
code_object = compile(ast_tree, '<string>', 'exec')
exec(code_object)  # 输出: Hello, World!
```

### 7.2 修改AST

```python
# 修改AST
import ast

# 定义AST访问者
class PrintTransformer(ast.NodeTransformer):
    def visit_Call(self, node):
        # 检查是否是print调用
        if isinstance(node.func, ast.Name) and node.func.id == 'print':
            # 添加一个参数
            new_arg = ast.Constant(value='Modified:')
            node.args.insert(0, new_arg)
        return node

# 解析代码
source_code = "print('Hello, World!')"
ast_tree = ast.parse(source_code)

# 转换AST
transformer = PrintTransformer()
modified_ast = transformer.visit(ast_tree)

# 修复AST位置信息
ast.fix_missing_locations(modified_ast)

# 执行修改后的代码
code_object = compile(modified_ast, '<string>', 'exec')
exec(code_object)  # 输出: Modified: Hello, World!
```

## 8. 元编程最佳实践

### 8.1 优先使用简单的元编程工具

- 优先使用装饰器，而不是元类
- 优先使用描述符，而不是元类
- 只有在必要时才使用元类

### 8.2 保持代码的可读性

元编程可能会使代码变得复杂和难以理解，因此应该：
- 限制元编程的使用范围
- 编写清晰的文档
- 使用有意义的命名

### 8.3 测试元编程代码

元编程代码可能会有一些意想不到的行为，因此应该：
- 编写全面的测试
- 测试边界情况
- 测试继承关系

### 8.4 避免过度使用元编程

元编程是一把双刃剑，过度使用会导致：
- 代码难以理解和维护
- 调试困难
- 性能问题

## 9. 总结

元编程是Python高级编程中的重要概念，它允许我们编写能够操作其他程序或自身的程序。Python提供了多种元编程工具：

- **装饰器**：用于增强函数和类的功能
- **描述符**：用于控制属性访问
- **元类**：用于控制类的创建过程
- **动态创建类**：允许在运行时创建类
- **反射**：用于动态访问和修改对象的属性和方法
- **AST操作**：用于修改代码的抽象表示

元编程可以帮助我们编写更灵活、更强大的代码，但也会增加代码的复杂性。在实际开发中，我们应该根据具体情况，合理使用元编程工具，保持代码的可读性和可维护性。