# 其他常用Hooks详解

## 1. useRef Hook

### 1.1 什么是 useRef？

`useRef` 是 React 提供的一个内置 Hook，用于创建一个可变的 ref 对象，该对象的 `current` 属性可以保存任意值，并且在组件的整个生命周期内保持不变。

### 1.2 核心特性
- 用于获取 DOM 元素的引用
- 用于保存持久化的值，不会触发组件重新渲染
- 可以在组件的整个生命周期内保持不变
- 适合存储不需要引起重新渲染的数据

### 1.3 语法和基本使用

```javascript
import { useRef } from 'react';

function Component() {
  const ref = useRef(initialValue);
  
  // 访问 ref 的值
  console.log(ref.current);
  
  // 修改 ref 的值
  ref.current = newValue;
  
  return <div ref={ref} />;
}
```

### 1.4 常见用例

#### 获取 DOM 元素

```javascript
function FocusInput() {
  const inputRef = useRef(null);
  
  const handleFocus = () => {
    inputRef.current.focus();
  };
  
  return (
    <div>
      <input ref={inputRef} placeholder="Focusable input" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
}
```

#### 保存持久化值

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef(count);
  
  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);
  
  const prevCount = prevCountRef.current;
  const isIncreased = count > prevCount;
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <p>Previous count: {prevCount}</p>
      <p>Is increased: {isIncreased ? 'Yes' : 'No'}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### 保存定时器 ID

```javascript
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const timerRef = useRef(null);
  
  const startTimer = () => {
    if (timerRef.current) return;
    
    timerRef.current = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
  };
  
  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  };
  
  useEffect(() => {
    return () => {
      stopTimer();
    };
  }, []);
  
  return (
    <div>
      <h2>Seconds: {seconds}</h2>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

### 1.5 与 useState 的对比

| 特性 | useRef | useState |
|------|--------|----------|
| 触发重新渲染 | 不触发 | 触发 |
| 值的持久性 | 组件整个生命周期 | 组件整个生命周期 |
| 更新方式 | 直接修改 .current | 调用 setState |
| 适合场景 | DOM 引用、持久化值 | 状态管理、UI 更新 |

## 2. useCallback Hook

### 2.1 什么是 useCallback？

`useCallback` 是 React 提供的一个内置 Hook，用于记忆化回调函数，避免在每次组件渲染时都创建新的函数实例，从而优化性能。

### 2.2 核心特性
- 用于记忆化回调函数
- 只有当依赖项发生变化时，才会重新创建函数
- 可以减少不必要的组件重新渲染
- 适合传递给子组件的回调函数

### 2.3 语法和基本使用

```javascript
import { useCallback } from 'react';

function Component() {
  const memoizedCallback = useCallback(
    () => {
      // 回调函数逻辑
    },
    [dependencies] // 依赖项数组
  );
  
  return <ChildComponent onClick={memoizedCallback} />;
}
```

### 2.4 常见用例

#### 优化子组件渲染

```javascript
import { useState, useCallback, memo } from 'react';

// 子组件使用 memo 包装，避免不必要的重新渲染
const ChildComponent = memo(({ onClick, count }) => {
  console.log('ChildComponent rendered');
  return <button onClick={onClick}>Count: {count}</button>;
});

function ParentComponent() {
  const [count, setCount] = useState(0);
  const [otherState, setOtherState] = useState(0);
  
  // 使用 useCallback 记忆化回调函数
  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  return (
    <div>
      <ChildComponent onClick={handleClick} count={count} />
      <button onClick={() => setOtherState(prev => prev + 1)}>
        Update Other State
      </button>
    </div>
  );
}
```

#### 与 useEffect 配合使用

```javascript
function Component() {
  const [count, setCount] = useState(0);
  
  // 记忆化回调函数
  const fetchData = useCallback(async () => {
    const response = await fetch(`https://api.example.com/data?count=${count}`);
    const data = await response.json();
    console.log(data);
  }, [count]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return <button onClick={() => setCount(prev => prev + 1)}>Increment</button>;
}
```

## 3. useMemo Hook

### 3.1 什么是 useMemo？

`useMemo` 是 React 提供的一个内置 Hook，用于记忆化计算结果，避免在每次组件渲染时都重新计算，从而优化性能。

### 3.2 核心特性
- 用于记忆化计算结果
- 只有当依赖项发生变化时，才会重新计算
- 可以减少不必要的计算
- 适合计算昂贵的操作

### 3.3 语法和基本使用

```javascript
import { useMemo } from 'react';

function Component() {
  const memoizedValue = useMemo(
    () => {
      // 计算逻辑
      return expensiveCalculation(dependencies);
    },
    [dependencies] // 依赖项数组
  );
  
  return <div>{memoizedValue}</div>;
}
```

### 3.4 常见用例

#### 优化昂贵的计算

```javascript
function ExpensiveComponent({ items }) {
  // 使用 useMemo 记忆化排序结果
  const sortedItems = useMemo(() => {
    console.log('Sorting items...');
    return [...items].sort((a, b) => a.value - b.value);
  }, [items]);
  
  return (
    <ul>
      {sortedItems.map(item => (
        <li key={item.id}>{item.name}: {item.value}</li>
      ))}
    </ul>
  );
}
```

#### 计算派生状态

```javascript
function UserProfile({ user }) {
  // 使用 useMemo 计算派生状态
  const userInitials = useMemo(() => {
    return user.name
      .split(' ')
      .map(name => name[0])
      .join('')
      .toUpperCase();
  }, [user.name]);
  
  return (
    <div>
      <div className="avatar">{userInitials}</div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

#### 避免创建不必要的对象

```javascript
function Component({ items }) {
  // 使用 useMemo 缓存对象，避免每次渲染都创建新对象
  const config = useMemo(() => {
    return {
      items: items,
      limit: 10,
      sortBy: 'name'
    };
  }, [items]);
  
  return <ChildComponent config={config} />;
}
```

## 4. useLayoutEffect Hook

### 4.1 什么是 useLayoutEffect？

`useLayoutEffect` 是 React 提供的一个内置 Hook，用于处理副作用，其 API 与 `useEffect` 完全相同，但执行时机不同。

### 4.2 核心特性
- 与 `useEffect` API 相同
- 在 DOM 更新后、浏览器绘制前同步执行
- 适合需要立即读取 DOM 布局的场景
- 可能会阻塞浏览器绘制，影响性能

### 4.3 与 useEffect 的对比

| 特性 | useLayoutEffect | useEffect |
|------|----------------|-----------|
| 执行时机 | DOM 更新后、浏览器绘制前 | 浏览器绘制后 |
| 执行方式 | 同步 | 异步 |
| 阻塞绘制 | 是 | 否 |
| 适合场景 | 读取 DOM 布局、同步更新 DOM | 数据获取、订阅等副作用 |
| 性能影响 | 可能影响性能 | 性能友好 |

### 4.4 语法和基本使用

```javascript
import { useLayoutEffect } from 'react';

function Component() {
  useLayoutEffect(() => {
    // 副作用逻辑
    
    return () => {
      // 清理逻辑（可选）
    };
  }, [dependencies]);
  
  return <div />;
}
```

### 4.5 常见用例

#### 测量 DOM 元素尺寸

```javascript
function MeasureElement() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const ref = useRef(null);
  
  useLayoutEffect(() => {
    if (ref.current) {
      const { width, height } = ref.current.getBoundingClientRect();
      setDimensions({ width, height });
    }
  }, []);
  
  return (
    <div>
      <div 
        ref={ref} 
        style={{ 
          width: '200px', 
          height: '100px', 
          background: '#f0f0f0',
          padding: '20px'
        }}
      >
        Measured Element
      </div>
      <p>Width: {dimensions.width}px</p>
      <p>Height: {dimensions.height}px</p>
    </div>
  );
}
```

#### 同步更新 DOM 避免闪烁

```javascript
function SmoothTransition() {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef(null);
  
  useLayoutEffect(() => {
    if (ref.current) {
      if (isVisible) {
        ref.current.style.opacity = '1';
        ref.current.style.transform = 'translateY(0)';
      } else {
        ref.current.style.opacity = '0';
        ref.current.style.transform = 'translateY(20px)';
      }
    }
  }, [isVisible]);
  
  return (
    <div>
      <div 
        ref={ref} 
        style={{ 
          transition: 'opacity 0.3s, transform 0.3s',
          opacity: '0',
          transform: 'translateY(20px)',
          padding: '20px',
          background: '#f0f0f0'
        }}
      >
        Animated Element
      </div>
      <button onClick={() => setIsVisible(!isVisible)}>
        Toggle Visibility
      </button>
    </div>
  );
}
```

## 5. 最佳实践

### 5.1 何时使用这些 Hooks？

- **useRef**：
  - 需要获取 DOM 元素引用时
  - 需要保存持久化值，且不希望触发重新渲染时
  - 需要保存定时器 ID、事件监听器等时

- **useCallback**：
  - 需要将回调函数传递给子组件时
  - 回调函数作为其他 Hooks 的依赖项时
  - 避免不必要的子组件重新渲染时

- **useMemo**：
  - 需要执行昂贵的计算时
  - 需要计算派生状态时
  - 避免创建不必要的对象、数组或函数时

- **useLayoutEffect**：
  - 需要立即读取 DOM 布局时
  - 需要同步更新 DOM 避免闪烁时
  - 依赖于 DOM 测量的副作用时

### 5.2 性能优化建议

1. **不要过度使用这些 Hooks**：
   - 对于简单的计算，直接执行可能比使用 `useMemo` 更高效
   - 对于不传递给子组件的回调函数，可能不需要使用 `useCallback`

2. **合理设置依赖项**：
   - 确保依赖项数组包含所有必要的变量
   - 避免不必要的依赖项，导致频繁重新计算或创建函数

3. **优先使用 useEffect**：
   - 大多数情况下，`useEffect` 已经足够使用
   - 只有在确实需要同步执行副作用时，才使用 `useLayoutEffect`

4. **结合 memo 使用**：
   - 使用 `useCallback` 和 `useMemo` 时，结合 `memo` 包装子组件，才能获得最佳性能优化

## 6. 总结

- **useRef**：用于获取 DOM 元素引用和保存持久化值
- **useCallback**：用于记忆化回调函数，优化子组件渲染
- **useMemo**：用于记忆化计算结果，避免不必要的计算
- **useLayoutEffect**：用于同步执行副作用，适合读取 DOM 布局

这些 Hooks 都是 React 中用于优化性能和处理特殊场景的重要工具，合理使用它们可以提高 React 应用的性能和用户体验。

通过掌握这些常用 Hooks，你已经具备了构建高性能 React 应用的基础，可以根据具体场景选择合适的 Hook 来解决问题。