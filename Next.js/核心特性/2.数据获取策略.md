# 数据获取策略

## 一、数据获取概述

### 1.1 数据获取的重要性

数据获取是Web应用开发中的核心环节，直接影响应用的性能、用户体验和SEO。Next.js提供了多种数据获取方式，支持服务器端和客户端数据获取，开发者可以根据应用需求选择合适的数据获取策略。

### 1.2 Next.js的数据获取方式

Next.js支持多种数据获取方式，主要包括：

| 数据获取方式 | 适用场景 | 渲染策略 |
|-------------|----------|----------|
| **服务器组件fetch** | 服务器端数据获取 | SSR、SSG、ISR |
| **Server Actions** | 服务器端数据修改 | SSR、SSG、ISR |
| **客户端fetch** | 客户端数据获取 | CSR |
| **React use hook** | 客户端数据获取 | CSR |
| **SWR/React Query** | 客户端数据获取，支持缓存和重新验证 | CSR |

### 1.3 数据获取策略选择

选择合适的数据获取策略需要考虑以下因素：

1. **数据更新频率**：静态数据适合SSG，动态数据适合SSR或CSR
2. **SEO需求**：需要良好SEO的页面适合服务器端数据获取
3. **性能要求**：对首屏加载速度要求高的页面适合服务器端数据获取
4. **交互性**：交互性强的页面适合客户端数据获取
5. **数据安全性**：敏感数据适合服务器端数据获取
6. **开发复杂度**：根据团队技术栈和开发经验选择

## 二、服务器组件数据获取

### 2.1 服务器组件概述

服务器组件是Next.js 13引入的新特性，允许在服务器端渲染组件，直接访问服务器资源，如数据库、API等。服务器组件默认是异步的，可以使用`async/await`语法获取数据。

### 2.2 服务器组件fetch

在服务器组件中，可以直接使用`fetch` API获取数据。Next.js扩展了原生`fetch` API，添加了缓存功能，可以控制数据的缓存行为。

```tsx
// src/app/page.tsx (服务器组件)
export default async function Home() {
  // 在服务器端获取数据
  const res = await fetch('https://api.example.com/posts')
  const posts = await res.json()

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map((post: any) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

### 2.3 fetch API缓存配置

Next.js的`fetch` API支持多种缓存配置，可以通过`cache`和`next`选项控制缓存行为：

```tsx
// 缓存请求结果（默认）
const res = await fetch('https://api.example.com/posts', {
  cache: 'force-cache',
})

// 不缓存请求结果
const res = await fetch('https://api.example.com/posts', {
  cache: 'no-store',
})

// 缓存请求结果，10秒后重新验证
const res = await fetch('https://api.example.com/posts', {
  next: { revalidate: 10 },
})

// 缓存请求结果，使用标签失效
const res = await fetch('https://api.example.com/posts', {
  next: { tags: ['posts'] },
})
```

### 2.4 直接数据库访问

在服务器组件中，可以直接访问数据库，无需通过API。这对于全栈应用非常有用，可以减少网络请求，提高性能。

```tsx
// src/app/page.tsx (服务器组件)
import { db } from '@/lib/db'

export default async function Home() {
  // 直接访问数据库
  const posts = await db.post.findMany()

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

### 2.5 并行数据获取

Next.js支持并行数据获取，可以同时发起多个请求，提高数据获取效率：

```tsx
// src/app/page.tsx (服务器组件)
export default async function Home() {
  // 并行获取数据
  const [postsRes, usersRes] = await Promise.all([
    fetch('https://api.example.com/posts'),
    fetch('https://api.example.com/users'),
  ])

  const posts = await postsRes.json()
  const users = await usersRes.json()

  return (
    <div>
      <h1>Posts and Users</h1>
      <div>
        <h2>Posts</h2>
        <ul>
          {posts.map((post: any) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      </div>
      <div>
        <h2>Users</h2>
        <ul>
          {users.map((user: any) => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      </div>
    </div>
  )
}
```

### 2.6 服务器组件数据获取的最佳实践

1. **优先使用服务器组件fetch**：服务器组件fetch可以减少客户端JavaScript体积，提高性能
2. **合理配置缓存**：根据数据更新频率配置合适的缓存策略
3. **使用并行数据获取**：同时发起多个请求，提高数据获取效率
4. **直接访问数据库**：对于全栈应用，直接访问数据库可以减少网络请求
5. **避免在服务器组件中使用客户端API**：服务器组件运行在服务器端，无法访问浏览器API
6. **使用TypeScript**：提高代码的类型安全性和可维护性

## 三、Server Actions

### 3.1 Server Actions概述

Server Actions是Next.js 13引入的新特性，允许在客户端组件中直接调用服务器端函数。Server Actions主要用于服务器端数据修改，如创建、更新、删除数据等。

### 3.2 Server Actions实现

Server Actions使用`'use server'`指令标记，在服务器端执行：

```tsx
// src/app/actions.ts
'use server'

export async function createPost(formData: FormData) {
  const title = formData.get('title') as string
  const content = formData.get('content') as string

  // 在服务器端创建帖子
  const res = await fetch('https://api.example.com/posts', {
    method: 'POST',
    body: JSON.stringify({ title, content }),
    headers: { 'Content-Type': 'application/json' },
  })

  if (!res.ok) {
    throw new Error('Failed to create post')
  }

  return res.json()
}
```

### 3.3 Server Actions使用

在客户端组件中，可以直接调用Server Actions：

```tsx
// src/app/page.tsx
'use client'
import { createPost } from './actions'

export default function Home() {
  return (
    <form action={createPost}>
      <input type="text" name="title" placeholder="Title" />
      <textarea name="content" placeholder="Content" />
      <button type="submit">Create Post</button>
    </form>
  )
}
```

### 3.4 Server Actions与表单结合

Server Actions可以与HTML表单结合使用，自动处理表单提交：

```tsx
// src/app/actions.ts
'use server'

export async function createPost(formData: FormData) {
  // 验证表单数据
  const title = formData.get('title') as string
  const content = formData.get('content') as string

  if (!title || !content) {
    return { error: 'Title and content are required' }
  }

  // 创建帖子
  const post = await createPostInDatabase({ title, content })

  return { success: true, post }
}
```

```tsx
// src/app/page.tsx
'use client'
import { useState } from 'react'
import { createPost } from './actions'

export default function Home() {
  const [error, setError] = useState<string | null>(null)

  async function handleSubmit(formData: FormData) {
    const result = await createPost(formData)
    if (result.error) {
      setError(result.error)
    }
  }

  return (
    <div>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <form action={handleSubmit}>
        <input type="text" name="title" placeholder="Title" />
        <textarea name="content" placeholder="Content" />
        <button type="submit">Create Post</button>
      </form>
    </div>
  )
}
```

### 3.5 Server Actions的最佳实践

1. **用于数据修改**：Server Actions主要用于服务器端数据修改，如创建、更新、删除数据
2. **验证数据**：在Server Actions中验证数据，确保数据的完整性和安全性
3. **处理错误**：在Server Actions中处理错误，返回友好的错误信息
4. **使用TypeScript**：提高代码的类型安全性和可维护性
5. **避免在Server Actions中使用客户端API**：Server Actions运行在服务器端，无法访问浏览器API
6. **考虑性能**：Server Actions会增加服务器负载，需要合理设计

## 四、客户端数据获取

### 4.1 客户端数据获取概述

客户端数据获取是指在客户端（浏览器）获取数据，主要用于交互性强的页面，如用户仪表盘、实时数据更新等。

### 4.2 客户端fetch

在客户端组件中，可以使用原生的`fetch` API获取数据：

```tsx
// src/components/Posts.tsx
'use client'
import { useState, useEffect } from 'react'

export default function Posts() {
  const [posts, setPosts] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function fetchPosts() {
      try {
        const res = await fetch('https://api.example.com/posts')
        if (!res.ok) {
          throw new Error('Failed to fetch posts')
        }
        const data = await res.json()
        setPosts(data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred')
      } finally {
        setLoading(false)
      }
    }

    fetchPosts()
  }, [])

  if (loading) return <div>Loading...</div>
  if (error) return <div>Error: {error}</div>

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

### 4.3 React use hook

React 18引入了`use` hook，可以在客户端组件中直接使用Promise：

```tsx
// src/components/Posts.tsx
'use client'
import { use } from 'react'

async function fetchPosts() {
  const res = await fetch('https://api.example.com/posts')
  if (!res.ok) {
    throw new Error('Failed to fetch posts')
  }
  return res.json()
}

export default function Posts() {
  const posts = use(fetchPosts())

  return (
    <ul>
      {posts.map((post: any) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

### 4.4 SWR

SWR是一个用于数据获取的React库，支持缓存、重新验证、错误处理等功能：

1. 安装SWR：

```bash
# 使用npm
npm install swr

# 使用yarn
yarn add swr

# 使用pnpm
pnpm add swr
```

2. 使用SWR获取数据：

```tsx
// src/components/Posts.tsx
'use client'
import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export default function Posts() {
  const { data, error, isLoading, mutate } = useSWR('https://api.example.com/posts', fetcher)

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      <ul>
        {data?.map((post: any) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
      <button onClick={() => mutate()}>Refresh</button>
    </div>
  )
}
```

### 4.5 React Query

React Query是一个用于数据获取的React库，支持缓存、重新验证、错误处理、分页等功能：

1. 安装React Query：

```bash
# 使用npm
npm install @tanstack/react-query

# 使用yarn
yarn add @tanstack/react-query

# 使用pnpm
pnpm add @tanstack/react-query
```

2. 配置React Query：

```tsx
// src/app/providers.tsx
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function Providers({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

3. 使用React Query获取数据：

```tsx
// src/components/Posts.tsx
'use client'
import { useQuery } from '@tanstack/react-query'

async function fetchPosts() {
  const res = await fetch('https://api.example.com/posts')
  if (!res.ok) {
    throw new Error('Failed to fetch posts')
  }
  return res.json()
}

export default function Posts() {
  const { data, error, isLoading, refetch } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  })

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      <ul>
        {data?.map((post: any) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  )
}
```

### 4.6 客户端数据获取的最佳实践

1. **使用合适的库**：根据应用需求选择合适的数据获取库，如SWR或React Query
2. **处理加载状态**：显示加载指示器，提高用户体验
3. **处理错误状态**：显示友好的错误信息，允许用户重试
4. **使用缓存**：合理使用缓存，减少API调用，提高性能
5. **避免水falls**：并行获取数据，避免嵌套请求导致的性能问题
6. **使用TypeScript**：提高代码的类型安全性和可维护性
7. **考虑性能**：客户端数据获取会增加客户端JavaScript体积，需要合理设计

## 五、数据获取的性能优化

### 5.1 减少API调用

1. **使用缓存**：合理使用缓存，减少重复的API调用
2. **合并API调用**：将多个API调用合并为一个，减少网络请求
3. **使用批量请求**：对于多个相关请求，使用批量请求减少网络开销
4. **预获取数据**：在用户可能访问的页面预获取数据，提高导航速度

### 5.2 优化数据获取时机

1. **服务器端数据获取**：对于首屏数据，使用服务器端数据获取，减少客户端请求
2. **客户端数据获取**：对于交互性强的数据，使用客户端数据获取
3. **延迟加载**：对于非关键数据，使用延迟加载，减少初始加载时间
4. **预加载**：对于用户可能需要的数据，使用预加载，提高响应速度

### 5.3 优化数据结构

1. **只获取需要的数据**：API只返回需要的数据，减少数据传输量
2. **使用合适的数据格式**：使用JSON等高效的数据格式
3. **压缩数据**：使用gzip等压缩算法，减少数据传输量
4. **使用分页**：对于大量数据，使用分页，减少单次数据传输量

### 5.4 优化缓存策略

1. **合理设置缓存时间**：根据数据更新频率设置合适的缓存时间
2. **使用缓存标签**：使用缓存标签，便于失效特定缓存
3. **使用CDN缓存**：对于静态数据，使用CDN缓存，提高访问速度
4. **使用浏览器缓存**：对于客户端数据，使用浏览器缓存，减少重复请求

## 六、数据获取的安全性

### 6.1 服务器端数据获取的安全性

1. **使用环境变量**：将敏感信息（如API密钥、数据库凭证）存储在环境变量中
2. **验证数据**：在服务器端验证数据的完整性和安全性
3. **使用HTTPS**：使用HTTPS传输数据，防止数据泄露
4. **限制API访问**：限制API的访问频率和来源，防止恶意攻击
5. **使用CORS**：合理配置CORS，防止跨站请求伪造

### 6.2 客户端数据获取的安全性

1. **使用HTTPS**：使用HTTPS传输数据，防止数据泄露
2. **验证数据**：在客户端验证数据的完整性和安全性
3. **使用CSRF令牌**：对于表单提交，使用CSRF令牌，防止跨站请求伪造
4. **限制API访问**：限制API的访问频率和来源，防止恶意攻击
5. **使用JWT**：对于需要认证的API，使用JWT，提高安全性

### 6.3 数据获取的最佳安全实践

1. **遵循最小权限原则**：只授予必要的权限，防止权限滥用
2. **使用参数化查询**：对于数据库查询，使用参数化查询，防止SQL注入
3. **验证输入**：在服务器端和客户端都验证输入数据，防止恶意输入
4. **使用安全的密码存储**：对于用户密码，使用安全的哈希算法存储
5. **定期更新依赖**：定期更新依赖库，修复安全漏洞
6. **进行安全审计**：定期进行安全审计，发现和修复安全问题

## 七、总结

本章节我们学习了Next.js的数据获取策略：

1. **数据获取概述**：数据获取的重要性、Next.js的数据获取方式、数据获取策略选择
2. **服务器组件数据获取**：服务器组件fetch、fetch API缓存配置、直接数据库访问、并行数据获取
3. **Server Actions**：Server Actions概述、实现、使用、与表单结合
4. **客户端数据获取**：客户端fetch、React use hook、SWR、React Query
5. **数据获取的性能优化**：减少API调用、优化数据获取时机、优化数据结构、优化缓存策略
6. **数据获取的安全性**：服务器端数据获取的安全性、客户端数据获取的安全性、数据获取的最佳安全实践

通过本章节的学习，你应该能够理解Next.js的数据获取方式，并根据应用需求选择合适的数据获取策略。在实际项目中，需要根据应用的具体需求，结合性能、用户体验、SEO等因素，选择合适的数据获取方式。

## 八、练习

1. 创建一个Next.js项目，使用服务器组件fetch获取数据
2. 实现Server Actions，用于创建、更新、删除数据
3. 在客户端组件中使用fetch、use hook、SWR、React Query获取数据
4. 比较不同数据获取方式的优缺点
5. 优化数据获取性能，如使用缓存、并行数据获取等
6. 实现数据获取的安全性，如使用环境变量、验证数据等
7. 测试不同数据获取方式的性能，如首屏加载时间、API调用次数等

---

**下一章预告**：渲染机制详解

在接下来的章节中，我们将深入学习Next.js的渲染机制，包括SSR、SSG、ISR、CSR、PPR等渲染策略的实现和使用场景。