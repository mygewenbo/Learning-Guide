# 生命周期（类组件）

## 一、生命周期概述

### 1.1 什么是生命周期

React组件的生命周期是指组件从创建到销毁的整个过程。在这个过程中，React会在特定的时间点调用组件的一些方法，这些方法被称为生命周期方法（Lifecycle Methods）。

### 1.2 生命周期的三个阶段

React类组件的生命周期可以分为三个主要阶段：

1. **挂载阶段（Mounting）**：组件被创建并挂载到DOM中
2. **更新阶段（Updating）**：组件的props或state发生变化，导致组件重新渲染
3. **卸载阶段（Unmounting）**：组件从DOM中移除

### 1.3 生命周期方法的调用顺序

```
挂载阶段：
constructor() → static getDerivedStateFromProps() → render() → componentDidMount()

更新阶段：
static getDerivedStateFromProps() → shouldComponentUpdate() → render() → getSnapshotBeforeUpdate() → componentDidUpdate()

卸载阶段：
componentWillUnmount()

错误处理：
static getDerivedStateFromError() → componentDidCatch()
```

## 二、挂载阶段（Mounting）

挂载阶段是指组件从创建到首次渲染到DOM中的过程。

### 2.1 constructor()

**调用时机**：组件实例化时调用，在挂载阶段只调用一次。

**作用**：
- 初始化组件的state
- 绑定事件处理函数
- 进行其他初始化工作

**注意事项**：
- 不要在constructor中调用setState()，因为此时组件还没有挂载
- 不要在constructor中进行API请求或副作用操作
- 必须调用super(props)，否则无法访问this.props

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    // 初始化state
    this.state = {
      count: 0,
      name: props.name || 'Guest'
    };
    // 绑定事件处理函数
    this.handleClick = this.handleClick.bind(this);
  }
  
  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return (
      <div>
        <h1>Hello, {this.state.name}!</h1>
        <p>You clicked {this.state.count} times</p>
        <button onClick={this.handleClick}>Click me</button>
      </div>
    );
  }
}
```

### 2.2 static getDerivedStateFromProps()

**调用时机**：在挂载和更新阶段都会调用，在render()之前调用。

**作用**：根据props更新state，是一个静态方法，没有this上下文。

**返回值**：
- 返回一个对象，用于更新state
- 返回null，表示不需要更新state

**注意事项**：
- 这是一个静态方法，不能访问this
- 主要用于根据props派生state，避免直接修改state
- 不要在这个方法中进行副作用操作

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: props.name,
      isOnline: false
    };
  }
  
  // 根据props更新state
  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.name !== prevState.name) {
      return {
        name: nextProps.name
      };
    }
    return null;
  }
  
  render() {
    return <h1>Hello, {this.state.name}!</h1>;
  }
}
```

### 2.3 render()

**调用时机**：在挂载和更新阶段都会调用，是组件的核心方法。

**作用**：返回React元素，描述组件的UI结构。

**注意事项**：
- 这是一个纯函数，不应该修改state或执行副作用操作
- 应该只返回React元素、null或false
- 不要在render中调用setState()，否则会导致无限循环

```jsx
class Component extends React.Component {
  render() {
    const { name, count } = this.props;
    
    // 条件渲染
    if (count === 0) {
      return <h1>Hello, {name}! You haven't clicked yet.</h1>;
    }
    
    return (
      <div>
        <h1>Hello, {name}!</h1>
        <p>You clicked {count} times</p>
      </div>
    );
  }
}
```

### 2.4 componentDidMount()

**调用时机**：组件挂载到DOM后调用，在挂载阶段只调用一次。

**作用**：
- 进行API请求
- 初始化第三方库
- 添加事件监听器
- 执行其他副作用操作

**注意事项**：
- 可以在这个方法中调用setState()，但会导致额外的渲染
- 不要在这个方法中进行阻塞操作

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      data: null,
      loading: true,
      error: null
    };
  }
  
  componentDidMount() {
    // 进行API请求
    fetch('https://api.example.com/data')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        this.setState({
          data,
          loading: false
        });
      })
      .catch(error => {
        this.setState({
          error: error.message,
          loading: false
        });
      });
      
    // 添加事件监听器
    window.addEventListener('resize', this.handleResize);
  }
  
  handleResize() {
    this.setState({
      windowWidth: window.innerWidth,
      windowHeight: window.innerHeight
    });
  }
  
  render() {
    const { data, loading, error } = this.state;
    
    if (loading) {
      return <div>Loading...</div>;
    }
    
    if (error) {
      return <div>Error: {error}</div>;
    }
    
    return <div>Data: {JSON.stringify(data)}</div>;
  }
}
```

## 三、更新阶段（Updating）

更新阶段是指组件的props或state发生变化，导致组件重新渲染的过程。

### 3.1 static getDerivedStateFromProps()

**调用时机**：在更新阶段，在render()之前调用。

**作用**：与挂载阶段相同，根据props更新state。

**注意事项**：与挂载阶段相同。

### 3.2 shouldComponentUpdate()

**调用时机**：在更新阶段，在render()之前调用。

**作用**：决定组件是否需要重新渲染，返回布尔值。

**返回值**：
- true：组件需要重新渲染（默认值）
- false：组件不需要重新渲染

**注意事项**：
- 不要在这个方法中调用setState()
- 主要用于性能优化，避免不必要的重新渲染
- 只比较props和state的变化，不要进行复杂的计算

```jsx
class Component extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    // 只有当count变化时才重新渲染
    if (this.props.count !== nextProps.count) {
      return true;
    }
    
    // 只有当name变化时才重新渲染
    if (this.state.name !== nextState.name) {
      return true;
    }
    
    // 其他情况不重新渲染
    return false;
  }
  
  render() {
    return (
      <div>
        <h1>Hello, {this.state.name}!</h1>
        <p>Count: {this.props.count}</p>
      </div>
    );
  }
}
```

### 3.3 render()

**调用时机**：在更新阶段，在shouldComponentUpdate()之后调用。

**作用**：与挂载阶段相同，返回React元素。

**注意事项**：与挂载阶段相同。

### 3.4 getSnapshotBeforeUpdate()

**调用时机**：在render()之后，DOM更新之前调用。

**作用**：获取DOM更新前的快照，用于保存一些DOM状态，如滚动位置等。

**返回值**：
- 返回一个值，作为componentDidUpdate()的第三个参数
- 返回null，表示不需要传递任何值

**注意事项**：
- 不要在这个方法中调用setState()
- 主要用于保存DOM状态，如滚动位置、元素尺寸等

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      messages: [],
      scrollPosition: 0
    };
    this.messagesEndRef = React.createRef();
  }
  
  componentDidMount() {
    this.scrollToBottom();
  }
  
  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 如果有新消息，并且滚动位置在底部，保存当前滚动位置
    if (prevState.messages.length < this.state.messages.length) {
      const messagesList = this.messagesEndRef.current.parentElement;
      return messagesList.scrollHeight - messagesList.scrollTop;
    }
    return null;
  }
  
  componentDidUpdate(prevProps, prevState, snapshot) {
    // 如果快照存在，并且滚动位置在底部，保持滚动位置
    if (snapshot !== null) {
      const messagesList = this.messagesEndRef.current.parentElement;
      messagesList.scrollTop = messagesList.scrollHeight - snapshot;
    }
  }
  
  scrollToBottom = () => {
    this.messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };
  
  addMessage = () => {
    this.setState(prevState => ({
      messages: [...prevState.messages, `Message ${prevState.messages.length + 1}`]
    }));
  };
  
  render() {
    return (
      <div>
        <button onClick={this.addMessage}>Add Message</button>
        <div style={{ height: '200px', overflow: 'auto' }}>
          {this.state.messages.map((message, index) => (
            <div key={index}>{message}</div>
          ))}
          <div ref={this.messagesEndRef} /></div>
      </div>
    );
  }
}
```

### 3.5 componentDidUpdate()

**调用时机**：DOM更新后调用，在更新阶段调用。

**作用**：
- 处理DOM更新后的副作用，如API请求、DOM操作等
- 根据prevProps和prevState与当前props和state的差异执行不同的操作

**参数**：
- prevProps：更新前的props
- prevState：更新前的state
- snapshot：getSnapshotBeforeUpdate()的返回值

**注意事项**：
- 可以在这个方法中调用setState()，但必须包裹在条件判断中，否则会导致无限循环
- 不要在这个方法中进行阻塞操作

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      data: null,
      loading: false
    };
  }
  
  componentDidUpdate(prevProps, prevState) {
    // 当id变化时，重新获取数据
    if (this.props.id !== prevProps.id) {
      this.setState({ loading: true });
      
      fetch(`https://api.example.com/data/${this.props.id}`)
        .then(response => response.json())
        .then(data => {
          this.setState({ data, loading: false });
        })
        .catch(error => {
          this.setState({ error: error.message, loading: false });
        });
    }
    
    // 当data变化时，执行某些操作
    if (this.state.data !== prevState.data) {
      console.log('Data updated:', this.state.data);
    }
  }
  
  render() {
    const { data, loading, error } = this.state;
    
    if (loading) {
      return <div>Loading...</div>;
    }
    
    if (error) {
      return <div>Error: {error}</div>;
    }
    
    return <div>Data: {JSON.stringify(data)}</div>;
  }
}
```

## 四、卸载阶段（Unmounting）

卸载阶段是指组件从DOM中移除的过程。

### 4.1 componentWillUnmount()

**调用时机**：组件卸载前调用，只调用一次。

**作用**：
- 清理副作用，如事件监听器、定时器、订阅等
- 取消API请求
- 释放资源

**注意事项**：
- 不要在这个方法中调用setState()，因为组件已经卸载，不会重新渲染
- 必须清理所有副作用，避免内存泄漏

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
    this.timer = null;
  }
  
  componentDidMount() {
    // 设置定时器
    this.timer = setInterval(() => {
      this.setState(prevState => ({
        count: prevState.count + 1
      }));
    }, 1000);
    
    // 添加事件监听器
    window.addEventListener('resize', this.handleResize);
    
    // 订阅事件
    this.subscription = eventEmitter.subscribe('event', this.handleEvent);
  }
  
  componentWillUnmount() {
    // 清理定时器
    clearInterval(this.timer);
    
    // 移除事件监听器
    window.removeEventListener('resize', this.handleResize);
    
    // 取消订阅
    this.subscription.unsubscribe();
    
    // 取消API请求
    if (this.abortController) {
      this.abortController.abort();
    }
  }
  
  handleResize = () => {
    this.setState({
      windowWidth: window.innerWidth,
      windowHeight: window.innerHeight
    });
  };
  
  handleEvent = (data) => {
    console.log('Event received:', data);
  };
  
  render() {
    return <div>Count: {this.state.count}</div>;
  }
}
```

## 五、错误处理生命周期

React 16引入了错误边界（Error Boundaries），用于捕获子组件树中的JavaScript错误，并显示备用UI。

### 5.1 static getDerivedStateFromError()

**调用时机**：当子组件抛出错误时调用。

**作用**：更新state，用于显示错误UI。

**返回值**：
- 返回一个对象，用于更新state
- 返回null，表示不需要更新state

**注意事项**：
- 这是一个静态方法，不能访问this
- 主要用于更新state，显示错误UI

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }
  
  static getDerivedStateFromError(error) {
    // 更新state，下次渲染时显示错误UI
    return {
      hasError: true,
      error
    };
  }
  
  render() {
    if (this.state.hasError) {
      // 显示错误UI
      return (
        <div>
          <h1>Something went wrong.</h1>
          <p>Error: {this.state.error.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    // 正常渲染子组件
    return this.props.children;
  }
}
```

### 5.2 componentDidCatch()

**调用时机**：当子组件抛出错误时调用，在commit阶段调用。

**作用**：
- 记录错误信息
- 发送错误报告
- 执行其他副作用操作

**参数**：
- error：抛出的错误
- info：包含错误发生位置的组件栈信息

**注意事项**：
- 可以在这个方法中执行副作用操作，如日志记录、错误报告等
- 不要在这个方法中调用setState()，因为它已经在getDerivedStateFromError()中处理了

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, info) {
    // 记录错误信息
    console.error('ErrorBoundary caught an error:', error);
    console.error('Component stack:', info.componentStack);
    
    // 发送错误报告到服务器
    fetch('/api/error-report', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        error: error.message,
        stack: error.stack,
        componentStack: info.componentStack,
        url: window.location.href
      })
    });
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    
    return this.props.children;
  }
}
```

## 六、生命周期方法的最佳实践

### 6.1 挂载阶段

- **constructor()**：只用于初始化state和绑定事件处理函数，不要进行副作用操作
- **componentDidMount()**：用于API请求、事件监听、第三方库初始化等副作用操作

### 6.2 更新阶段

- **shouldComponentUpdate()**：只用于性能优化，避免不必要的重新渲染
- **componentDidUpdate()**：用于处理DOM更新后的副作用，如根据props变化重新获取数据
- **getSnapshotBeforeUpdate()**：用于保存DOM状态，如滚动位置

### 6.3 卸载阶段

- **componentWillUnmount()**：必须清理所有副作用，如定时器、事件监听器、订阅等

### 6.4 错误处理

- **static getDerivedStateFromError()**：用于更新state，显示错误UI
- **componentDidCatch()**：用于记录错误和发送错误报告

### 6.5 避免使用的生命周期方法

React 16.3开始，以下生命周期方法被标记为不安全（legacy），不推荐使用：

- **componentWillMount()**：使用constructor()和componentDidMount()替代
- **componentWillReceiveProps()**：使用static getDerivedStateFromProps()替代
- **componentWillUpdate()**：使用getSnapshotBeforeUpdate()和componentDidUpdate()替代

这些方法在React 17中被移除，在React 16中仍然可用，但会显示警告。

## 七、生命周期方法的替代方案（Hooks）

React 16.8引入了Hooks，允许函数组件使用状态和其他React特性，不再需要类组件和生命周期方法。

### 7.1 useState替代state和setState

```jsx
// 类组件
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  
  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={this.handleClick.bind(this)}>Click me</button>
      </div>
    );
  }
}

// 函数组件 + useState
function Component() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

### 7.2 useEffect替代生命周期方法

```jsx
// 类组件
class Component extends React.Component {
  constructor(props) {
    super(props);
    this.state = { data: null };
  }
  
  componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
    
    window.addEventListener('resize', this.handleResize);
  }
  
  componentDidUpdate(prevProps) {
    if (this.props.id !== prevProps.id) {
      fetch(`https://api.example.com/data/${this.props.id}`)
        .then(response => response.json())
        .then(data => this.setState({ data }));
    }
  }
  
  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }
  
  handleResize = () => {
    this.setState({ windowWidth: window.innerWidth });
  };
  
  render() {
    return <div>Data: {JSON.stringify(this.state.data)}</div>;
  }
}

// 函数组件 + useEffect
function Component({ id }) {
  const [data, setData] = useState(null);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  
  // componentDidMount + componentDidUpdate (when id changes)
  useEffect(() => {
    fetch(`https://api.example.com/data/${id}`)
      .then(response => response.json())
      .then(data => setData(data));
  }, [id]);
  
  // componentDidMount + componentWillUnmount
  useEffect(() => {
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };
    
    window.addEventListener('resize', handleResize);
    
    // componentWillUnmount
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return <div>Data: {JSON.stringify(data)}</div>;
}
```

## 八、总结

本章节我们学习了：

1. 生命周期的三个阶段：挂载、更新、卸载
2. 每个阶段的生命周期方法：
   - 挂载阶段：constructor()、static getDerivedStateFromProps()、render()、componentDidMount()
   - 更新阶段：static getDerivedStateFromProps()、shouldComponentUpdate()、render()、getSnapshotBeforeUpdate()、componentDidUpdate()
   - 卸载阶段：componentWillUnmount()
   - 错误处理：static getDerivedStateFromError()、componentDidCatch()
3. 生命周期方法的调用顺序和作用
4. 生命周期方法的最佳实践
5. 避免使用的不安全生命周期方法
6. 使用Hooks替代生命周期方法

生命周期方法是React类组件的重要组成部分，掌握好生命周期方法对于理解React组件的工作原理和优化组件性能至关重要。虽然Hooks已经成为React开发的主流，但了解类组件的生命周期仍然有助于理解React的底层原理。

## 九、练习

1. 创建一个类组件，实现以下功能：
   - 在constructor中初始化state
   - 在componentDidMount中设置定时器，每秒更新一次state
   - 在componentWillUnmount中清理定时器
   - 显示当前时间

2. 创建一个错误边界组件，捕获子组件的错误并显示友好的错误信息

3. 使用shouldComponentUpdate优化组件，只有当特定props或state变化时才重新渲染

4. 使用getSnapshotBeforeUpdate保存滚动位置，在componentDidUpdate中恢复滚动位置

5. 将上述类组件转换为函数组件，使用Hooks替代生命周期方法

---

**下一章预告**：Hooks基础

在接下来的章节中，我们将深入学习React Hooks的基础知识，包括useState、useEffect、useContext等常用Hooks。