# useContext Hook 详解

## 1. 什么是 useContext Hook？

`useContext` 是 React 提供的一个内置 Hook，用于在函数组件中访问和使用 Context。Context 是 React 提供的一种在组件树中共享数据的方式，无需通过逐层传递 props（即 "prop drilling"）。

### 核心特性
- 允许组件访问全局或跨层级共享的数据
- 避免了 prop drilling 问题
- 提供了一种集中管理状态的方式
- 支持动态更新 Context 值
- 与函数式编程范式完美契合

## 2. 语法和基本使用

### 语法结构

```javascript
import { createContext, useContext } from 'react';

// 1. 创建 Context
const MyContext = createContext(defaultValue);

// 2. 提供 Context 值
function MyProvider({ children }) {
  return (
    <MyContext.Provider value={contextValue}>
      {children}
    </MyContext.Provider>
  );
}

// 3. 使用 Context 值
function MyComponent() {
  const contextValue = useContext(MyContext);
  return <div>{contextValue}</div>;
}
```

### 参数说明

1. **createContext(defaultValue)**：创建一个 Context 对象
   - `defaultValue`：当组件在没有匹配的 Provider 时使用的默认值

2. **MyContext.Provider**：提供 Context 值的组件
   - `value`：要共享的 Context 值

3. **useContext(MyContext)**：访问 Context 值的 Hook
   - `MyContext`：要访问的 Context 对象

### 基本示例

```javascript
import { createContext, useContext, useState } from 'react';
import { createRoot } from 'react-dom/client';

// 创建主题 Context
const ThemeContext = createContext('light');

// 主题提供者组件
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 使用主题的按钮组件
function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      style={{
        background: theme === 'dark' ? '#333' : '#fff',
        color: theme === 'dark' ? '#fff' : '#333'
      }}
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
    >
      Toggle Theme (Current: {theme})
    </button>
  );
}

// 应用组件
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

## 3. 避免 Prop Drilling

### 什么是 Prop Drilling？

Prop Drilling 是指在 React 组件树中，为了将数据传递给深层嵌套的组件，需要逐层传递 props 的现象。这会导致代码变得冗长、难以维护。

### 传统 Prop Drilling 示例

```javascript
// ❌ 传统 Prop Drilling
function Grandparent() {
  const [theme, setTheme] = useState('light');
  return <Parent theme={theme} setTheme={setTheme} />;
}

function Parent({ theme, setTheme }) {
  return <Child theme={theme} setTheme={setTheme} />;
}

function Child({ theme, setTheme }) {
  return <Grandchild theme={theme} setTheme={setTheme} />;
}

function Grandchild({ theme, setTheme }) {
  return (
    <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>
      Toggle Theme
    </button>
  );
}
```

### 使用 useContext 避免 Prop Drilling

```javascript
// ✅ 使用 useContext 避免 Prop Drilling
const ThemeContext = createContext('light');

function Grandparent() {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Parent />
    </ThemeContext.Provider>
  );
}

function Parent() {
  return <Child />;
}

function Child() {
  return <Grandchild />;
}

function Grandchild() {
  const { theme, setTheme } = useContext(ThemeContext);
  return (
    <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>
      Toggle Theme
    </button>
  );
}
```

## 4. 高级用法

### 1. 多个 Context

可以在同一个组件中使用多个 Context：

```javascript
// 创建多个 Context
const ThemeContext = createContext('light');
const UserContext = createContext(null);

// 提供者组件
function AppProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState({ name: 'John' });

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <UserContext.Provider value={{ user, setUser }}>
        {children}
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}

// 使用多个 Context
function ProfileComponent() {
  const { theme } = useContext(ThemeContext);
  const { user } = useContext(UserContext);

  return (
    <div style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333' }}>
      <h2>User Profile</h2>
      <p>Name: {user.name}</p>
    </div>
  );
}
```

### 2. Context 与 Hooks 结合

Context 可以与其他 Hooks 结合使用，例如 useState、useReducer、useEffect 等：

```javascript
const AuthContext = createContext(null);

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  // 模拟异步登录
  useEffect(() => {
    const fetchUser = async () => {
      try {
        // 模拟 API 请求
        const response = await fetch('/api/user');
        const data = await response.json();
        setUser(data);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchUser();
  }, []);

  const login = async (credentials) => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/login', { method: 'POST', body: JSON.stringify(credentials) });
      const data = await response.json();
      setUser(data);
    } catch (error) {
      console.error('Login failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// 使用 Auth Context
function LoginButton() {
  const { user, login, logout } = useContext(AuthContext);

  if (user) {
    return <button onClick={logout}>Logout</button>;
  } else {
    return <button onClick={() => login({ username: 'test', password: 'test' })}>Login</button>;
  }
}
```

### 3. 动态 Context 值

Context 值可以是动态的，当 Context 值发生变化时，所有使用该 Context 的组件都会重新渲染：

```javascript
const CounterContext = createContext(0);

function CounterProvider({ children }) {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return (
    <CounterContext.Provider value={{ count, increment, decrement }}>
      {children}
    </CounterContext.Provider>
  );
}

function CounterDisplay() {
  const { count } = useContext(CounterContext);
  return <div>Count: {count}</div>;
}

function CounterControls() {
  const { increment, decrement } = useContext(CounterContext);
  return (
    <div>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
}
```

## 5. 最佳实践

### 1. 将 Context 拆分为多个专用 Context

避免创建一个包含所有状态的大型 Context，而是将状态拆分为多个专用 Context：

```javascript
// ✅ 多个专用 Context
const ThemeContext = createContext('light');
const UserContext = createContext(null);
const AuthContext = createContext(null);

// ❌ 避免大型单一 Context
const AppContext = createContext({
  theme: 'light',
  user: null,
  isAuthenticated: false,
  // 更多状态...
});
```

### 2. 创建自定义 Hook 简化 Context 使用

创建自定义 Hook 可以简化 Context 的使用，并提供更好的类型安全：

```javascript
const ThemeContext = createContext('light');

// 自定义 Hook
function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

// 使用自定义 Hook
function ThemedComponent() {
  const { theme, setTheme } = useTheme();
  // ...
}
```

### 3. 为 Context 提供默认值

为 Context 提供默认值可以避免在没有 Provider 时出现 undefined：

```javascript
// ✅ 提供默认值
const ThemeContext = createContext({
  theme: 'light',
  setTheme: () => {}
});

// ❌ 没有默认值
const ThemeContext = createContext();
```

### 4. 避免在 Context 中存储过多数据

Context 适合存储全局共享的状态，避免存储组件特定的状态：

```javascript
// ✅ 适合存储的全局状态
const AuthContext = createContext(null); // 用户认证状态
const ThemeContext = createContext('light'); // 主题设置
const LanguageContext = createContext('en'); // 语言设置

// ❌ 不适合存储的组件特定状态
const CounterContext = createContext(0); // 组件特定的计数器
```

### 5. 优化 Context 更新性能

当 Context 值发生变化时，所有使用该 Context 的组件都会重新渲染。为了优化性能，可以：

1. 将不经常变化的值和经常变化的值分离到不同的 Context 中
2. 使用 memo 包装组件，避免不必要的重新渲染
3. 使用 useMemo 缓存 Context 值，避免不必要的 Context 更新

```javascript
// 使用 useMemo 缓存 Context 值
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const [color, setColor] = useState('#007bff');

  // 缓存 Context 值，只有当 theme 或 color 变化时才更新
  const contextValue = useMemo(() => {
    return { theme, setTheme, color, setColor };
  }, [theme, color]);

  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
}
```

## 6. 常见错误和注意事项

### 1. 忘记提供 Provider

当组件使用 useContext 但没有匹配的 Provider 时，会使用默认值：

```javascript
// ❌ 忘记提供 Provider
function App() {
  return <ThemedButton />; // 使用默认值 'light'
}

// ✅ 提供 Provider
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}
```

### 2. 在条件语句中调用 useContext

useContext 必须在组件的顶层调用，不能在条件语句、循环或嵌套函数中调用：

```javascript
// ❌ 错误：在条件语句中调用 useContext
function Component() {
  if (condition) {
    const context = useContext(MyContext);
  }
  // ...
}

// ✅ 正确：在顶层调用 useContext
function Component() {
  const context = useContext(MyContext);
  if (condition) {
    // 使用 context
  }
  // ...
}
```

### 3. 直接修改 Context 值

Context 值应该通过 Provider 的 value 属性进行更新，而不是直接修改：

```javascript
// ❌ 错误：直接修改 Context 值
function Component() {
  const context = useContext(MyContext);
  context.theme = 'dark'; // 不会触发重新渲染
}

// ✅ 正确：通过 Provider 更新 Context 值
function Component() {
  const { setTheme } = useContext(MyContext);
  setTheme('dark'); // 会触发重新渲染
}
```

### 4. 错误地使用默认值

默认值只有在没有匹配的 Provider 时才会使用，而不是在 Provider 的 value 为 undefined 时：

```javascript
const ThemeContext = createContext('light');

// ❌ 不会使用默认值，因为有 Provider
function App() {
  return (
    <ThemeContext.Provider value={undefined}>
      <ThemedButton /> // context.theme 是 undefined
    </ThemeContext.Provider>
  );
}

// ✅ 会使用默认值，因为没有 Provider
function App() {
  return <ThemedButton />; // context.theme 是 'light'
}
```

## 7. React 19 中的 useContext 特性

React 19 对 `useContext` 进行了一些改进：

1. **更好的错误消息**：当违反 Hooks 规则时，React 19 提供了更清晰的错误消息

2. **与 React Server Components 兼容**：`useContext` 可以在客户端组件中正常使用，与 React Server Components 无缝集成

3. **优化的 Context 更新**：React 19 优化了 Context 更新机制，减少了不必要的重新渲染

4. **支持异步 Context**：React 19 支持异步 Context 值，允许在 Provider 中使用异步数据

## 8. 与其他状态管理方案的对比

| 特性 | useContext | Redux | Zustand | Jotai |
|------|------------|-------|---------|-------|
| 学习曲线 | 简单 | 复杂 | 简单 | 中等 |
| 代码量 | 少 | 多 | 少 | 中等 |
| 性能 | 一般 | 好 | 好 | 好 |
| 中间件支持 | 无 | 有 | 有 | 无 |
| 开发工具 | 有限 | 丰富 | 基本 | 基本 |
| 适合场景 | 小型应用、简单全局状态 | 大型应用、复杂全局状态 | 中小型应用 | 中小型应用 |

## 9. 测试 useContext

### 使用 React Testing Library 测试

```javascript
import { render, screen } from '@testing-library/react';
import { ThemeContext } from './ThemeContext';
import ThemedButton from './ThemedButton';

test('renders button with light theme by default', () => {
  render(
    <ThemeContext.Provider value={{ theme: 'light', setTheme: jest.fn() }}>
      <ThemedButton />
    </ThemeContext.Provider>
  );

  const button = screen.getByText(/Toggle Theme/);
  expect(button).toHaveStyle({
    background: '#fff',
    color: '#333'
  });
});

test('renders button with dark theme', () => {
  render(
    <ThemeContext.Provider value={{ theme: 'dark', setTheme: jest.fn() }}>
      <ThemedButton />
    </ThemeContext.Provider>
  );

  const button = screen.getByText(/Toggle Theme/);
  expect(button).toHaveStyle({
    background: '#333',
    color: '#fff'
  });
});
```

## 10. 总结

`useContext` 是 React 中用于共享全局状态的重要 Hook，它可以帮助我们避免 prop drilling 问题，使代码更加简洁和易于维护。通过合理使用 `useContext`，我们可以：

- 在组件树中共享数据，无需逐层传递 props
- 创建全局状态管理方案
- 实现主题切换、用户认证等功能
- 与其他 Hooks 结合使用，构建复杂的应用

遵循 `useContext` 的最佳实践，我们可以编写出高效、可维护的 React 应用。

## 11. 进一步学习资源

- [React 官方文档 - useContext](https://react.dev/reference/react/useContext)
- [React 官方文档 - Context](https://react.dev/learn/passing-data-deeply-with-context)
- [React Hooks 规则](https://react.dev/rules/hooks)
- [React 性能优化](https://react.dev/learn/optimizing-performance)

通过掌握 `useContext` Hook，你已经掌握了 React 中共享全局状态的核心机制，为构建复杂的 React 应用打下了坚实基础。