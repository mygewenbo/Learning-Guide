# 测试和调试

## 4.1 单元测试编写

### 4.1.1 单元测试的重要性

单元测试是智能合约开发的关键环节，它可以：
- 验证合约功能的正确性
- 检测潜在的漏洞和错误
- 确保合约在各种情况下都能正常工作
- 便于代码重构和升级
- 提高合约的可靠性和安全性

### 4.1.2 测试框架

#### 4.1.2.1 Hardhat + Mocha/Chai

Hardhat是一个现代化的Solidity开发框架，内置了测试功能，通常与Mocha测试框架和Chai断言库一起使用。

**安装依赖：**
```bash
npm install --save-dev hardhat @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers
```

**基本测试结构：**
```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SimpleToken", function () {
  let SimpleToken, simpleToken, owner, addr1, addr2;

  beforeEach(async function () {
    // 部署合约前的准备工作
    SimpleToken = await ethers.getContractFactory("SimpleToken");
    [owner, addr1, addr2, _] = await ethers.getSigners();
    
    // 部署合约
    simpleToken = await SimpleToken.deploy("MyToken", "MTK", 18);
    await simpleToken.deployed();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await simpleToken.owner()).to.equal(owner.address);
    });

    it("Should assign the total supply of tokens to the owner", async function () {
      const ownerBalance = await simpleToken.balanceOf(owner.address);
      expect(await simpleToken.totalSupply()).to.equal(ownerBalance);
    });
  });

  describe("Transactions", function () {
    it("Should transfer tokens between accounts", async function () {
      // 从所有者转账到addr1
      await simpleToken.transfer(addr1.address, 50);
      const addr1Balance = await simpleToken.balanceOf(addr1.address);
      expect(addr1Balance).to.equal(50);

      // 从addr1转账到addr2
      await simpleToken.connect(addr1).transfer(addr2.address, 50);
      const addr2Balance = await simpleToken.balanceOf(addr2.address);
      expect(addr2Balance).to.equal(50);
    });

    it("Should fail if sender doesn’t have enough tokens", async function () {
      const initialOwnerBalance = await simpleToken.balanceOf(owner.address);

      // 尝试从addr1转账，addr1没有代币
      await expect(
        simpleToken.connect(addr1).transfer(owner.address, 1)
      ).to.be.revertedWith("Insufficient balance");

      // 所有者余额不应改变
      expect(await simpleToken.balanceOf(owner.address)).to.equal(initialOwnerBalance);
    });
  });
});
```

#### 4.1.2.2 Foundry

Foundry是一个基于Rust的Solidity开发框架，使用Solidity编写测试用例，提供了更快的测试速度。

**基本测试结构：**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/SimpleToken.sol";

contract SimpleTokenTest is Test {
    SimpleToken token;
    address owner = address(1);
    address addr1 = address(2);
    address addr2 = address(3);

    function setUp() public {
        vm.prank(owner);
        token = new SimpleToken("MyToken", "MTK", 18);
    }

    function testDeployment() public {
        assertEq(token.owner(), owner);
        assertEq(token.totalSupply(), token.balanceOf(owner));
    }

    function testTransfer() public {
        vm.prank(owner);
        token.transfer(addr1, 50);
        assertEq(token.balanceOf(addr1), 50);

        vm.prank(addr1);
        token.transfer(addr2, 50);
        assertEq(token.balanceOf(addr2), 50);
    }

    function testTransferFail() public {
        vm.prank(addr1);
        vm.expectRevert("Insufficient balance");
        token.transfer(owner, 1);
    }
}
```

### 4.1.3 测试最佳实践

1. **测试覆盖率**：
   - 确保测试覆盖所有函数和边界情况
   - 测试正常流程和异常情况
   - 测试各种输入值，包括边界值

2. **测试命名**：
   - 使用清晰、描述性的测试名称
   - 遵循一致的命名约定
   - 测试名称应反映测试的目的

3. **测试隔离**：
   - 每个测试用例应独立运行
   - 使用`beforeEach`和`afterEach`设置和清理测试环境
   - 避免测试用例之间的依赖

4. **断言使用**：
   - 使用明确的断言消息
   - 测试结果与预期值的比较
   - 测试异常情况的正确处理

## 4.2 集成测试

### 4.2.1 集成测试的概念

集成测试是测试多个合约或组件之间的交互，验证它们在一起工作时的正确性。

### 4.2.2 集成测试的场景

- 合约之间的调用
- 与外部合约的交互
- 复杂的业务流程
- 多合约系统的协同工作

### 4.2.3 集成测试示例

**测试DEX合约与代币合约的交互：**
```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("DEX Integration Test", function () {
  let TokenA, TokenB, DEX, tokenA, tokenB, dex, owner, addr1, addr2;

  beforeEach(async function () {
    // 部署代币合约
    TokenA = await ethers.getContractFactory("SimpleToken");
    TokenB = await ethers.getContractFactory("SimpleToken");
    [owner, addr1, addr2, _] = await ethers.getSigners();
    
    tokenA = await TokenA.deploy("Token A", "TA", 18);
    await tokenA.deployed();
    
    tokenB = await TokenB.deploy("Token B", "TB", 18);
    await tokenB.deployed();
    
    // 部署DEX合约
    DEX = await ethers.getContractFactory("DEX");
    dex = await DEX.deploy(tokenA.address, tokenB.address);
    await dex.deployed();
    
    // 初始化流动性
    await tokenA.transfer(dex.address, ethers.utils.parseEther("1000"));
    await tokenB.transfer(dex.address, ethers.utils.parseEther("1000"));
    await dex.addLiquidity(ethers.utils.parseEther("1000"), ethers.utils.parseEther("1000"));
  });

  it("Should swap tokens correctly", async function () {
    // 给addr1一些TokenA
    await tokenA.transfer(addr1.address, ethers.utils.parseEther("100"));
    
    // addr1批准DEX使用TokenA
    await tokenA.connect(addr1).approve(dex.address, ethers.utils.parseEther("100"));
    
    // addr1使用TokenA交换TokenB
    await dex.connect(addr1).swap(tokenA.address, ethers.utils.parseEther("10"));
    
    // 检查addr1的TokenB余额
    const addr1TokenBBalance = await tokenB.balanceOf(addr1.address);
    expect(addr1TokenBBalance).to.be.gt(0);
  });
});
```

## 4.3 调试技巧和工具

### 4.3.1 调试技巧

1. **使用事件日志**：
   - 在关键位置添加事件
   - 记录函数调用参数和返回值
   - 使用事件跟踪合约执行流程

2. **使用require/revert消息**：
   - 添加详细的错误消息
   - 帮助定位问题所在
   - 提高合约的可读性

3. **分步测试**：
   - 将复杂测试分解为多个步骤
   - 逐步验证每个步骤的结果
   - 更容易定位问题

4. **使用console.log**：
   - 在Solidity 0.8.0+中，可以使用`console.log`进行调试
   - 需要导入`hardhat/console.sol`
   - 只能在测试环境中使用

**console.log示例：**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";

contract DebugContract {
    function debugFunction(uint _value) public {
        console.log("Input value:", _value);
        
        uint result = _value * 2;
        console.log("Result:", result);
        
        require(result < 100, "Result too large");
    }
}
```

### 4.3.2 调试工具

1. **Remix Debugger**：
   - 内置在Remix IDE中
   - 支持单步执行
   - 查看栈、内存和存储状态
   - 检查合约执行流程

2. **Hardhat Debugger**：
   - 与Hardhat集成
   - 支持交易调试
   - 查看合约状态变化
   - 分析Gas消耗

3. **Tenderly**：
   - 在线调试工具
   - 支持主网和测试网交易调试
   - 可视化合约执行流程
   - 提供详细的Gas分析

4. **Ganache**：
   - 本地测试网络
   - 支持交易回滚
   - 查看区块链状态
   - 导出测试数据

## 4.4 覆盖率测试

### 4.4.1 覆盖率测试的重要性

覆盖率测试可以：
- 衡量测试的完整性
- 识别未测试的代码路径
- 提高测试质量
- 确保合约的各个部分都得到了测试

### 4.4.2 覆盖率测试工具

#### 4.4.2.1 Hardhat Coverage

Hardhat Coverage是一个基于Istanbul的覆盖率测试工具，可以生成详细的覆盖率报告。

**安装和使用：**
```bash
npm install --save-dev solidity-coverage

# 在hardhat.config.js中添加插件
require("solidity-coverage");

# 运行覆盖率测试
npx hardhat coverage
```

#### 4.4.2.2 Foundry Coverage

Foundry内置了覆盖率测试功能，可以生成覆盖率报告。

**使用方法：**
```bash
forge coverage
```

### 4.4.3 覆盖率指标

覆盖率测试通常包括以下指标：

1. **行覆盖率**：测试覆盖的代码行数占总行数的百分比
2. **分支覆盖率**：测试覆盖的分支占总分支数的百分比
3. **函数覆盖率**：测试覆盖的函数占总函数数的百分比
4. **语句覆盖率**：测试覆盖的语句占总语句数的百分比

### 4.4.4 覆盖率测试最佳实践

1. **目标覆盖率**：
   - 争取100%的覆盖率
   - 至少达到80%以上
   - 关注未覆盖的代码路径

2. **不要为了覆盖率而测试**：
   - 覆盖率是手段，不是目的
   - 确保测试的质量和有效性
   - 避免编写无意义的测试

3. **定期运行覆盖率测试**：
   - 在代码提交前运行
   - 在CI/CD流程中集成
   - 监控覆盖率变化

## 4.5 实践练习

### 4.5.1 单元测试练习

为以下简单的计数器合约编写完整的单元测试：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Counter {
    uint public count;
    address public owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    function increment() public {
        count++;
    }
    
    function decrement() public {
        require(count > 0, "Count is zero");
        count--;
    }
    
    function reset() public onlyOwner {
        count = 0;
    }
    
    function setCount(uint _newCount) public onlyOwner {
        count = _newCount;
    }
}
```

### 4.5.2 集成测试练习

编写一个集成测试，测试以下场景：
1. 部署一个ERC20代币合约
2. 部署一个众筹合约，接受该代币
3. 用户使用代币参与众筹
4. 众筹结束后，所有者提取资金
5. 未达到目标时，用户可以退款

### 4.5.3 调试练习

使用console.log调试以下合约，找出为什么transfer函数总是失败：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";

contract BuggyToken {
    mapping(address => uint) public balances;
    uint public totalSupply;
    
    function mint(address _to, uint _amount) public {
        totalSupply += _amount;
        balances[_to] += _amount;
    }
    
    function transfer(address _to, uint _amount) public returns (bool) {
        console.log("Sender balance:", balances[msg.sender]);
        console.log("Transfer amount:", _amount);
        console.log("Recipient balance before:", balances[_to]);
        
        if (balances[msg.sender] >= _amount) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            console.log("Recipient balance after:", balances[_to]);
            return true;
        }
        
        return false;
    }
}
```

## 4.6 学习资源

- [Hardhat测试文档](https://hardhat.org/tutorial/testing-contracts.html)
- [Foundry测试文档](https://book.getfoundry.sh/forge/writing-tests.html)
- [Solidity Coverage文档](https://github.com/sc-forks/solidity-coverage)
- [Mocha测试框架](https://mochajs.org/)
- [Chai断言库](https://www.chaijs.com/)

## 4.7 总结

测试和调试是智能合约开发的重要组成部分，它们可以确保合约的正确性、安全性和可靠性。通过编写全面的单元测试和集成测试，使用有效的调试技巧和工具，以及进行覆盖率测试，可以显著提高智能合约的质量。

在实际开发中，应该将测试和调试作为开发流程的一部分，而不是事后的补充。良好的测试实践可以节省大量的时间和成本，避免合约部署后的安全问题和功能故障。