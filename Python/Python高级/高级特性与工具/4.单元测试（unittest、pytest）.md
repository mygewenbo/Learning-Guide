# 单元测试（unittest、pytest）

## 1. 单元测试概述

单元测试是指对软件中的最小可测试单元进行检查和验证。在Python中，单元测试通常是对函数、方法或类的测试。单元测试的主要目的是：

- 验证代码的正确性
- 确保代码的可维护性
- 促进代码的重构
- 提供文档
- 减少回归错误

Python提供了多个单元测试框架，其中最常用的是：
- **unittest**：Python标准库中的测试框架
- **pytest**：第三方测试框架，提供了更简洁、更强大的测试体验

## 2. unittest框架

unittest是Python标准库中的测试框架，它基于Java的JUnit框架，提供了完整的测试功能。

### 2.1 基本使用

```python
import unittest

# 要测试的函数
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# 测试用例类
class TestMathFunctions(unittest.TestCase):
    def test_add(self):
        """测试add函数"""
        self.assertEqual(add(1, 2), 3)
        self.assertEqual(add(-1, 1), 0)
        self.assertEqual(add(0, 0), 0)
    
    def test_subtract(self):
        """测试subtract函数"""
        self.assertEqual(subtract(3, 2), 1)
        self.assertEqual(subtract(1, 1), 0)
        self.assertEqual(subtract(0, 1), -1)

# 运行测试
if __name__ == '__main__':
    unittest.main()
```

### 2.2 断言方法

unittest提供了多种断言方法，用于验证测试结果：

| 断言方法 | 描述 |
|----------|------|
| `assertEqual(a, b)` | 断言a等于b |
| `assertNotEqual(a, b)` | 断言a不等于b |
| `assertTrue(x)` | 断言x为True |
| `assertFalse(x)` | 断言x为False |
| `assertIs(a, b)` | 断言a是b（同一对象） |
| `assertIsNot(a, b)` | 断言a不是b（不同对象） |
| `assertIsNone(x)` | 断言x为None |
| `assertIsNotNone(x)` | 断言x不为None |
| `assertIn(a, b)` | 断言a在b中 |
| `assertNotIn(a, b)` | 断言a不在b中 |
| `assertIsInstance(a, b)` | 断言a是b的实例 |
| `assertNotIsInstance(a, b)` | 断言a不是b的实例 |
| `assertRaises(exception, callable, *args, **kwargs)` | 断言调用callable(*args, **kwargs)会引发exception |
| `assertWarns(warning, callable, *args, **kwargs)` | 断言调用callable(*args, **kwargs)会引发warning |

### 2.3 测试夹具

测试夹具用于在测试前后执行代码，如设置测试环境、清理测试数据等。

```python
import unittest

class TestWithFixtures(unittest.TestCase):
    def setUp(self):
        """在每个测试方法前执行"""
        print("Setting up test...")
        self.test_data = [1, 2, 3, 4, 5]
    
    def tearDown(self):
        """在每个测试方法后执行"""
        print("Tearing down test...")
        self.test_data = None
    
    def test_length(self):
        """测试列表长度"""
        self.assertEqual(len(self.test_data), 5)
    
    def test_sum(self):
        """测试列表总和"""
        self.assertEqual(sum(self.test_data), 15)

# 类级别的夹具
class TestWithClassFixtures(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        """在类中所有测试方法前执行一次"""
        print("Setting up class...")
        cls.class_data = [10, 20, 30]
    
    @classmethod
    def tearDownClass(cls):
        """在类中所有测试方法后执行一次"""
        print("Tearing down class...")
        cls.class_data = None
    
    def test_first_element(self):
        """测试第一个元素"""
        self.assertEqual(self.class_data[0], 10)
    
    def test_last_element(self):
        """测试最后一个元素"""
        self.assertEqual(self.class_data[-1], 30)
```

### 2.4 测试套件

测试套件用于组织多个测试用例：

```python
import unittest

# 导入测试用例
from test_module import TestMathFunctions, TestWithFixtures

# 创建测试套件
suite = unittest.TestSuite()

# 添加测试用例
suite.addTest(unittest.makeSuite(TestMathFunctions))
suite.addTest(unittest.makeSuite(TestWithFixtures))

# 运行测试套件
runner = unittest.TextTestRunner()
runner.run(suite)
```

### 2.5 测试发现

unittest支持自动发现测试：

```python
# 在命令行中运行
# python -m unittest discover

# 在代码中运行
import unittest

if __name__ == '__main__':
    # 发现当前目录下所有以test_开头的文件中的测试用例
    unittest.main()

# 在__init__.py中实现load_tests函数，支持测试发现
import os
import unittest

def load_tests(loader, standard_tests, pattern):
    # 发现当前目录下的测试用例
    this_dir = os.path.dirname(__file__)
    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)
    standard_tests.addTests(package_tests)
    return standard_tests
```

### 2.6 高级特性

#### 2.6.1 子测试

子测试允许在一个测试方法中运行多个相关的测试：

```python
import unittest

class NumbersTest(unittest.TestCase):
    def test_even(self):
        """测试0到5之间的数字是否为偶数"""
        for i in range(0, 6):
            with self.subTest(i=i):
                self.assertEqual(i % 2, 0)
```

#### 2.6.2 预期失败

使用`@unittest.expectedFailure`装饰器标记预期会失败的测试：

```python
import unittest

class ExpectedFailureTestCase(unittest.TestCase):
    @unittest.expectedFailure
    def test_fail(self):
        self.assertEqual(1, 0, "broken")
    
    @unittest.expectedFailure
    def test_pass(self):
        self.assertEqual(1, 1, "working")  # 这会被标记为意外通过
```

#### 2.6.3 跳过测试

使用`@unittest.skip`装饰器跳过测试：

```python
import unittest

class SkipTestCase(unittest.TestCase):
    @unittest.skip("跳过这个测试")
    def test_skip(self):
        self.assertEqual(1, 2)
    
    @unittest.skipIf(condition, "条件为真时跳过")
    def test_skip_if(self):
        self.assertEqual(1, 2)
    
    @unittest.skipUnless(condition, "条件为真时执行")
    def test_skip_unless(self):
        self.assertEqual(1, 2)
```

#### 2.6.4 捕获警告

使用`assertWarns`上下文管理器捕获警告：

```python
import unittest
import warnings

def deprecated_function():
    warnings.warn("This function is deprecated", DeprecationWarning)
    return 42

class WarningTestCase(unittest.TestCase):
    def test_warning(self):
        with self.assertWarns(DeprecationWarning):
            deprecated_function()
    
    def test_warning_details(self):
        with self.assertWarns(DeprecationWarning) as cm:
            deprecated_function()
        # 可以访问警告的详细信息
        self.assertIn('deprecated', str(cm.warning))
```

## 3. pytest框架

pytest是一个第三方测试框架，提供了更简洁、更强大的测试体验。

### 3.1 安装pytest

```bash
pip install pytest
```

### 3.2 基本使用

pytest的语法比unittest更简洁：

```python
# 要测试的函数
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# 测试函数，以test_开头
def test_add():
    assert add(1, 2) == 3
    assert add(-1, 1) == 0
    assert add(0, 0) == 0

def test_subtract():
    assert subtract(3, 2) == 1
    assert subtract(1, 1) == 0
    assert subtract(0, 1) == -1
```

### 3.3 运行pytest

```bash
# 运行当前目录下所有测试
pytest

# 运行特定文件中的测试
pytest test_file.py

# 运行特定测试函数
pytest test_file.py::test_add

# 运行特定类中的测试方法
pytest test_file.py::TestClass::test_method

# 显示详细输出
pytest -v

# 显示测试覆盖率
pytest --cov
```

### 3.4 断言方法

pytest使用Python的原生`assert`语句，不需要记住特定的断言方法：

```python
def test_assertions():
    # 基本断言
    assert 1 + 1 == 2
    
    # 断言异常
    with pytest.raises(ZeroDivisionError):
        1 / 0
    
    # 断言警告
    with pytest.warns(DeprecationWarning):
        deprecated_function()
    
    # 断言接近值
    assert 0.1 + 0.2 == pytest.approx(0.3)
    
    # 断言包含
    assert 'a' in 'abc'
    
    # 断言类型
    assert isinstance(1, int)
    
    # 断言属性
    obj = type('Obj', (), {'attr': 42})()
    assert hasattr(obj, 'attr')
    assert obj.attr == 42
```

### 3.5 测试夹具（fixture）

pytest的fixture比unittest的setUp/tearDown更灵活：

```python
import pytest

# 定义fixture
@pytest.fixture
def test_data():
    """返回测试数据"""
    return [1, 2, 3, 4, 5]

@pytest.fixture
def temp_file():
    """创建临时文件，测试后删除"""
    import tempfile
    import os
    
    # 创建临时文件
    fd, path = tempfile.mkstemp()
    
    try:
        # 写入测试数据
        with os.fdopen(fd, 'w') as f:
            f.write('test data')
        
        # 提供fixture值
        yield path
    finally:
        # 清理资源
        os.remove(path)

# 使用fixture
def test_length(test_data):
    """测试列表长度"""
    assert len(test_data) == 5

def test_sum(test_data):
    """测试列表总和"""
    assert sum(test_data) == 15

def test_temp_file(temp_file):
    """测试临时文件"""
    with open(temp_file, 'r') as f:
        content = f.read()
    assert content == 'test data'
```

### 3.6 夹具作用域

fixture可以有不同的作用域：

```python
import pytest

# 函数级作用域（默认）：每个测试函数执行一次
@pytest.fixture(scope='function')
def function_fixture():
    print("Function fixture setup")
    yield
    print("Function fixture teardown")

# 类级作用域：每个测试类执行一次
@pytest.fixture(scope='class')
def class_fixture():
    print("Class fixture setup")
    yield
    print("Class fixture teardown")

# 模块级作用域：每个模块执行一次
@pytest.fixture(scope='module')
def module_fixture():
    print("Module fixture setup")
    yield
    print("Module fixture teardown")

# 会话级作用域：整个测试会话执行一次
@pytest.fixture(scope='session')
def session_fixture():
    print("Session fixture setup")
    yield
    print("Session fixture teardown")
```

### 3.7 参数化测试

pytest支持参数化测试，允许使用不同的参数运行同一个测试函数：

```python
import pytest

# 要测试的函数
def add(a, b):
    return a + b

# 参数化测试
@pytest.mark.parametrize("a, b, expected", [
    (1, 2, 3),
    (-1, 1, 0),
    (0, 0, 0),
    (10, 20, 30),
    (1.5, 2.5, 4.0),
])
def test_add(a, b, expected):
    assert add(a, b) == expected

# 更复杂的参数化
@pytest.mark.parametrize("test_input,expected", [
    ("3+5", 8),
    ("2+4", 6),
    ("6*9", 42),  # 这会失败
])
def test_eval(test_input, expected):
    assert eval(test_input) == expected
```

### 3.8 测试类

pytest也支持使用类组织测试：

```python
import pytest

class TestMathFunctions:
    def test_add(self):
        assert add(1, 2) == 3
    
    def test_subtract(self):
        assert subtract(3, 2) == 1
    
    # 使用fixture
    def test_length(self, test_data):
        assert len(test_data) == 5
    
    # 参数化测试
    @pytest.mark.parametrize("a, b, expected", [(1, 2, 3), (3, 4, 7)])
    def test_multiply(self, a, b, expected):
        assert a * b == expected
```

### 3.9 Mocking

pytest使用`unittest.mock`或`pytest-mock`插件进行Mocking：

```python
# 使用unittest.mock
from unittest.mock import patch, MagicMock

def test_mock():
    with patch('module.function') as mock_func:
        mock_func.return_value = 42
        result = module.function()
        assert result == 42
        mock_func.assert_called_once()

# 使用pytest-mock插件
# pip install pytest-mock
def test_mock_with_plugin(mocker):
    mock_func = mocker.patch('module.function', return_value=42)
    result = module.function()
    assert result == 42
    mock_func.assert_called_once()
```

### 3.10 测试覆盖率

pytest可以使用`pytest-cov`插件生成测试覆盖率报告：

```bash
pip install pytest-cov
```

```bash
# 生成覆盖率报告
pytest --cov=my_module

# 生成HTML覆盖率报告
pytest --cov=my_module --cov-report=html
```

## 4. unittest vs pytest

| 特性 | unittest | pytest |
|------|----------|--------|
| 语法 | 复杂，需要继承TestCase | 简洁，使用原生assert |
| 断言 | 特定的断言方法 | 原生assert语句 |
| 夹具 | setUp/tearDown | fixture，更灵活 |
| 参数化测试 | 不支持，需要第三方库 | 内置支持 |
| 测试发现 | 支持 | 支持，更强大 |
| 插件生态 | 有限 | 丰富 |
| 学习曲线 | 较陡 | 较平缓 |
| 输出 | 详细 | 简洁，可配置 |
| 兼容性 | Python标准库 | 第三方库，需要安装 |

## 5. 测试最佳实践

### 5.1 测试命名

- 测试函数/方法名应该清晰地描述测试内容
- 使用`test_`前缀命名测试函数/方法
- 测试文件名应该以`test_`开头或结尾

### 5.2 测试隔离

- 每个测试应该独立运行，不依赖其他测试的结果
- 测试之间不应该共享状态
- 使用夹具来设置和清理测试环境

### 5.3 测试覆盖率

- 目标覆盖率应该根据项目需求确定，通常建议80%以上
- 不要为了覆盖率而测试，测试应该关注核心功能和边界情况
- 使用覆盖率工具来识别未测试的代码

### 5.4 测试边界情况

- 测试正常输入
- 测试边界值（最小值、最大值、空值等）
- 测试异常情况
- 测试错误输入

### 5.5 测试文档

- 为测试添加适当的文档字符串
- 测试应该是自文档化的
- 避免过于复杂的测试

### 5.6 测试运行频率

- 在开发过程中频繁运行测试
- 在提交代码前运行所有测试
- 在CI/CD流水线中自动运行测试

### 5.7 测试分层

- **单元测试**：测试单个函数或方法
- **集成测试**：测试多个组件之间的交互
- **端到端测试**：测试整个应用的流程

## 6. 总结

单元测试是Python开发中的重要组成部分，它可以帮助我们确保代码的正确性和可维护性。Python提供了多个单元测试框架，其中最常用的是unittest和pytest。

unittest是Python标准库中的测试框架，提供了完整的测试功能，但语法相对复杂。pytest是一个第三方测试框架，提供了更简洁、更强大的测试体验，支持丰富的插件生态。

在选择测试框架时，应该根据项目需求、团队习惯和个人偏好来决定。无论选择哪个框架，都应该遵循测试最佳实践，编写清晰、独立、全面的测试用例。

通过学习和使用单元测试，我们可以提高代码质量，减少回归错误，促进代码重构，为项目的长期发展打下坚实的基础。