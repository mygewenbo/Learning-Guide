# 函数式编程

## 1. 函数式编程概述

函数式编程是一种编程范式，它将计算视为数学函数的求值，强调函数的纯粹性和不可变性。函数式编程的核心思想包括：

- **纯函数**：相同的输入总是产生相同的输出，没有副作用
- **不可变性**：数据一旦创建，就不能被修改
- **高阶函数**：函数可以作为参数传递，也可以作为返回值
- **函数组合**：将多个简单函数组合成更复杂的函数
- **惰性求值**：只在需要时才计算值

Python虽然不是纯函数式编程语言，但它支持许多函数式编程特性，允许开发者以函数式风格编写代码。

## 2. 纯函数

纯函数是函数式编程的核心概念，它具有以下特点：

- **确定性**：相同的输入总是产生相同的输出
- **无副作用**：不修改外部状态，不依赖外部状态
- **可测试性**：易于编写单元测试
- **可并行性**：可以安全地并行执行

### 2.1 纯函数示例

```python
# 纯函数
def add(a, b):
    return a + b

# 非纯函数 - 修改外部状态
counter = 0
def increment():
    global counter
    counter += 1
    return counter

# 非纯函数 - 依赖外部状态
def get_current_time():
    import datetime
    return datetime.datetime.now()

# 非纯函数 - 修改输入参数
def append_to_list(lst, item):
    lst.append(item)
    return lst
```

### 2.2 纯函数的优势

```python
# 纯函数可以安全地缓存结果
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

# 纯函数可以安全地并行执行
from multiprocessing import Pool

def square(x):
    return x * x

with Pool(4) as p:
    results = p.map(square, [1, 2, 3, 4, 5])
    print(results)  # [1, 4, 9, 16, 25]
```

## 3. 不可变性

不可变性是函数式编程的另一个核心概念，它意味着数据一旦创建，就不能被修改。在Python中，我们可以使用不可变数据结构，或者通过函数式编程风格来实现不可变性。

### 3.1 不可变数据类型

Python内置了一些不可变数据类型：

```python
# 不可变数据类型
immutable_string = "hello"
immutable_tuple = (1, 2, 3)
immutable_frozenset = frozenset([1, 2, 3])

# 尝试修改不可变数据类型会引发错误
# immutable_string[0] = "H"  # TypeError: 'str' object does not support item assignment
# immutable_tuple[0] = 0      # TypeError: 'tuple' object does not support item assignment
```

### 3.2 实现不可变性

对于可变数据类型，我们可以通过函数式编程风格来实现不可变性：

```python
# 可变数据类型的函数式处理

def add_to_list(lst, item):
    # 创建新列表，不修改原列表
    return lst + [item]

def update_dict(d, key, value):
    # 创建新字典，不修改原字典
    return {**d, key: value}

def remove_from_set(s, item):
    # 创建新集合，不修改原集合
    return s - {item}

# 使用示例
original_list = [1, 2, 3]
new_list = add_to_list(original_list, 4)
print(original_list)  # [1, 2, 3] (原列表不变)
print(new_list)       # [1, 2, 3, 4] (新列表)

original_dict = {"a": 1, "b": 2}
new_dict = update_dict(original_dict, "c", 3)
print(original_dict)  # {'a': 1, 'b': 2} (原字典不变)
print(new_dict)       # {'a': 1, 'b': 2, 'c': 3} (新字典)
```

## 4. 高阶函数

高阶函数是指可以接受函数作为参数，或者返回函数作为结果的函数。Python内置了许多高阶函数，如`map`、`filter`、`reduce`等。

### 4.1 map函数

`map`函数将一个函数应用于可迭代对象的每个元素，并返回一个迭代器。

```python
# 使用map函数
def upper(s):
    return s.upper()

# 基本用法
words = ['sentence', 'fragment']
uppercase_words = list(map(upper, words))
print(uppercase_words)  # ['SENTENCE', 'FRAGMENT']

# 使用lambda表达式
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x * x, numbers))
print(squared_numbers)  # [1, 4, 9, 16, 25]

# 多个可迭代对象
numbers1 = [1, 2, 3]
numbers2 = [4, 5, 6]
summed_numbers = list(map(lambda x, y: x + y, numbers1, numbers2))
print(summed_numbers)  # [5, 7, 9]

# 等价的列表推导式
uppercase_words = [upper(s) for s in words]
squared_numbers = [x * x for x in numbers]
summed_numbers = [x + y for x, y in zip(numbers1, numbers2)]
```

### 4.2 filter函数

`filter`函数用于过滤可迭代对象中的元素，只保留满足条件的元素。

```python
# 使用filter函数
def is_even(x):
    return x % 2 == 0

# 基本用法
numbers = range(10)
even_numbers = list(filter(is_even, numbers))
print(even_numbers)  # [0, 2, 4, 6, 8]

# 使用lambda表达式
odd_numbers = list(filter(lambda x: x % 2 != 0, numbers))
print(odd_numbers)  # [1, 3, 5, 7, 9]

# 等价的列表推导式
even_numbers = [x for x in numbers if is_even(x)]
odd_numbers = [x for x in numbers if x % 2 != 0]
```

### 4.3 reduce函数

`reduce`函数用于将可迭代对象中的元素累积为一个值。

```python
# 使用reduce函数
from functools import reduce

# 计算总和
numbers = [1, 2, 3, 4, 5]
sum_total = reduce(lambda x, y: x + y, numbers)
print(sum_total)  # 15

# 计算乘积
product_total = reduce(lambda x, y: x * y, numbers)
print(product_total)  # 120

# 使用初始值
sum_with_initial = reduce(lambda x, y: x + y, numbers, 10)
print(sum_with_initial)  # 25

# 更复杂的示例
items = [("a", 1), ("b", 2), ("c", 3)]
total_value = reduce(lambda a, b: (0, a[1] + b[1]), items)[1]
print(total_value)  # 6

# 等价的循环实现
total = 0
for item in items:
    total += item[1]
print(total)  # 6
```

### 4.4 sorted函数

`sorted`函数可以接受一个`key`参数，用于指定排序的依据。

```python
# 使用sorted函数

# 基本排序
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # [1, 1, 2, 3, 4, 5, 6, 9]

# 降序排序
desc_sorted = sorted(numbers, reverse=True)
print(desc_sorted)  # [9, 6, 5, 4, 3, 2, 1, 1]

# 使用key参数
words = ["apple", "banana", "cherry", "date"]
# 按长度排序
sorted_by_length = sorted(words, key=len)
print(sorted_by_length)  # ['date', 'apple', 'banana', 'cherry']

# 按最后一个字符排序
sorted_by_last_char = sorted(words, key=lambda x: x[-1])
print(sorted_by_last_char)  # ['banana', 'apple', 'date', 'cherry']

# 自定义对象排序
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

people = [
    Person("Alice", 30),
    Person("Bob", 25),
    Person("Charlie", 35)
]

# 按年龄排序
sorted_by_age = sorted(people, key=lambda p: p.age)
print(sorted_by_age)  # [Person(name='Bob', age=25), Person(name='Alice', age=30), Person(name='Charlie', age=35)]
```

## 5. Lambda表达式

Lambda表达式是一种创建匿名函数的简洁方式，它只能包含一个表达式。Lambda表达式的语法为：

```python
lambda parameters: expression
```

### 5.1 基本用法

```python
# 基本lambda表达式
adder = lambda x, y: x + y
print(adder(2, 3))  # 5

# 字符串格式化
print_assign = lambda name, value: f"{name}={value}"
print(print_assign("x", 10))  # x=10

# 条件表达式
max_value = lambda x, y: x if x > y else y
print(max_value(3, 5))  # 5

# 多个参数
multiply = lambda x, y, z: x * y * z
print(multiply(2, 3, 4))  # 24
```

### 5.2 Lambda表达式的应用场景

Lambda表达式通常用于以下场景：

1. **作为高阶函数的参数**
2. **用于简单的函数定义**
3. **用于排序和过滤**
4. **用于闭包**

```python
# 作为高阶函数的参数
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x * x, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# 用于排序
words = ["apple", "banana", "cherry", "date"]
sorted_by_length = sorted(words, key=lambda x: len(x))
print(sorted_by_length)  # ['date', 'apple', 'banana', 'cherry']

# 用于闭包
def make_multiplier(factor):
    return lambda x: x * factor

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

### 5.3 Lambda表达式的局限性

Lambda表达式也有一些局限性：

- 只能包含一个表达式
- 不能包含语句（如`if`、`for`、`while`等）
- 不能包含文档字符串
- 可读性较差，不适合复杂逻辑

对于复杂逻辑，应该使用标准的`def`语句定义函数：

```python
# 复杂逻辑应该使用def语句
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# 不应该使用lambda表达式实现复杂逻辑
# is_prime = lambda n: False if n < 2 else all(n % i != 0 for i in range(2, int(n ** 0.5) + 1))
```

## 6. 生成器和迭代器

生成器和迭代器是函数式编程中的重要概念，它们支持惰性求值，只在需要时才生成值。

### 6.1 迭代器

迭代器是实现了`__iter__`和`__next__`方法的对象。

```python
# 迭代器示例

# 内置迭代器
numbers = [1, 2, 3]
iterator = iter(numbers)

print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
# print(next(iterator))  # StopIteration

# 自定义迭代器
class Countdown:
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1

# 使用自定义迭代器
for i in Countdown(5):
    print(i)  # 5, 4, 3, 2, 1
```

### 6.2 生成器

生成器是一种特殊的迭代器，它使用`yield`关键字来生成值。

```python
# 生成器函数
def generate_ints(N):
    for i in range(N):
        yield i

# 使用生成器
for i in generate_ints(5):
    print(i)  # 0, 1, 2, 3, 4

# 生成器表达式
gen_expr = (x * x for x in range(5))
print(list(gen_expr))  # [0, 1, 4, 9, 16]

# 生成器作为函数参数
total = sum(x * x for x in range(100))
print(total)  # 328350

# 更复杂的生成器
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci(10):
    print(num)  # 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

### 6.3 itertools模块

`itertools`模块提供了许多用于函数式编程的工具函数。

```python
# 使用itertools模块
import itertools

# starmap - 对元组应用函数
coordinates = [(1, 2), (3, 4), (5, 6)]
distances = list(itertools.starmap(lambda x, y: (x**2 + y**2)**0.5, coordinates))
print(distances)  # [2.2360679775, 5.0, 7.8102496759]

# chain - 连接多个可迭代对象
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list(itertools.chain(list1, list2))
print(combined)  # [1, 2, 3, 4, 5, 6]

# cycle - 无限循环可迭代对象
counter = 0
for item in itertools.cycle(["A", "B", "C"]):
    print(item)
    counter += 1
    if counter >= 5:
        break
# A, B, C, A, B

# takewhile - 只要条件为真就获取元素
numbers = [1, 3, 5, 2, 4, 6]
odd_numbers = list(itertools.takewhile(lambda x: x % 2 != 0, numbers))
print(odd_numbers)  # [1, 3, 5]

# dropwhile - 跳过条件为真的元素
remaining_numbers = list(itertools.dropwhile(lambda x: x % 2 != 0, numbers))
print(remaining_numbers)  # [2, 4, 6]
```

## 7. 函数式编程库

除了Python内置的函数和模块外，还有一些第三方库可以帮助我们进行函数式编程。

### 7.1 functools模块

`functools`模块提供了一些用于函数式编程的工具函数。

```python
# 使用functools模块
import functools

# lru_cache - 缓存函数结果
@functools.lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print([fib(n) for n in range(10)])  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

# partial - 部分应用函数
def power(base, exponent):
    return base ** exponent

square = functools.partial(power, exponent=2)
cube = functools.partial(power, exponent=3)

print(square(5))  # 25
print(cube(5))    # 125

# wraps - 保留原函数的元数据
def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        """Wrapper function"""
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Greet someone"""
    return f"Hello, {name}!"

print(greet.__name__)  # greet (不是wrapper)
print(greet.__doc__)   # Greet someone (不是Wrapper function)
```

### 7.2 operator模块

`operator`模块提供了许多内置操作符的函数版本。

```python
# 使用operator模块
import operator

# 算术操作符
print(operator.add(1, 2))  # 3
print(operator.mul(3, 4))  # 12
print(operator.pow(2, 3))  # 8

# 比较操作符
print(operator.eq(1, 2))  # False
print(operator.gt(3, 4))  # False
print(operator.lt(3, 4))  # True

# 序列操作符
print(operator.getitem([1, 2, 3], 1))  # 2
print(operator.setitem([1, 2, 3], 1, 4))  # None (修改原列表)
print(operator.concat([1, 2], [3, 4]))  # [1, 2, 3, 4]

# 属性访问
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Alice", 30)
print(operator.attrgetter("name")(person))  # Alice
print(operator.attrgetter("age")(person))   # 30

# 用于排序
people = [Person("Alice", 30), Person("Bob", 25), Person("Charlie", 35)]
sorted_by_age = sorted(people, key=operator.attrgetter("age"))
print([p.name for p in sorted_by_age])  # ['Bob', 'Alice', 'Charlie']

# 结合reduce使用
numbers = [1, 2, 3, 4, 5]
sum_total = functools.reduce(operator.add, numbers)
print(sum_total)  # 15

product_total = functools.reduce(operator.mul, numbers)
print(product_total)  # 120
```

### 7.3 toolz/dtoolz库

`toolz`（或`dtoolz`，分布式版本）是一个函数式编程库，提供了许多有用的函数。

```python
# 安装：pip install toolz

from toolz import pipe, compose, curry

# pipe - 将函数按顺序应用
result = pipe(
    5,
    lambda x: x * 2,
    lambda x: x + 3,
    lambda x: x ** 2
)
print(result)  # (5*2+3)^2 = 13^2 = 169

# compose - 函数组合（从右到左）
func = compose(
    lambda x: x ** 2,
    lambda x: x + 3,
    lambda x: x * 2
)
print(func(5))  # 同样得到169

# curry - 柯里化
@curry
def add(x, y, z):
    return x + y + z

add_5 = add(5)
add_5_and_3 = add_5(3)
print(add_5_and_3(2))  # 5+3+2 = 10
```

## 8. 函数式编程最佳实践

### 8.1 优先使用纯函数

纯函数具有确定性和无副作用的特点，更容易测试和调试。

### 8.2 避免修改状态

尽量避免修改外部状态，而是返回新的值。

### 8.3 使用高阶函数

高阶函数可以提高代码的抽象程度和复用性。

### 8.4 使用生成器和迭代器

生成器和迭代器支持惰性求值，可以提高内存效率。

### 8.5 合理使用Lambda表达式

Lambda表达式适合简单的函数定义，对于复杂逻辑应该使用标准的`def`语句。

### 8.6 函数组合

将多个简单函数组合成更复杂的函数，可以提高代码的可读性和复用性。

### 8.7 避免过度使用函数式编程

Python是一种多范式编程语言，应该根据具体情况选择合适的编程风格。

## 9. 总结

函数式编程是一种强大的编程范式，它强调纯函数、不可变性、高阶函数和惰性求值。Python虽然不是纯函数式编程语言，但它支持许多函数式编程特性，允许开发者以函数式风格编写代码。

通过学习函数式编程，我们可以：

- 编写更简洁、更可读的代码
- 提高代码的可测试性和可维护性
- 充分利用Python的内置函数和模块
- 提高代码的抽象程度和复用性

在实际开发中，我们应该根据具体情况，合理使用函数式编程风格，与其他编程范式（如面向对象编程、命令式编程）结合使用，以达到最佳的开发效果。