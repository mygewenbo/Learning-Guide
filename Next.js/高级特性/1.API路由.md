# API路由

## 一、API路由概述

### 1.1 API路由的重要性

API路由是Web应用开发中的核心环节，用于处理服务器端逻辑，如数据获取、数据修改、认证授权等。Next.js提供了内置的API路由功能，允许开发者在同一个项目中构建前端和后端，实现全栈开发。

### 1.2 Next.js的API路由方式

Next.js支持两种API路由方式：

| API路由方式 | 适用场景 | 特点 |
|-------------|----------|------|
| **Route Handlers** | App Router | 基于Web Request/Response API，支持多种HTTP方法，集成Next.js特性 |
| **API Routes** | Pages Router | 基于Express风格，支持多种HTTP方法，适合传统Express开发者 |

### 1.3 API路由选择

选择合适的API路由方式需要考虑以下因素：

1. **路由系统**：使用App Router的项目适合Route Handlers，使用Pages Router的项目适合API Routes
2. **开发经验**：熟悉Express的开发者适合API Routes，熟悉Web API的开发者适合Route Handlers
3. **功能需求**：需要集成Next.js特性（如缓存、Server Components）的项目适合Route Handlers
4. **迁移计划**：计划迁移到App Router的项目适合Route Handlers
5. **性能要求**：Route Handlers基于Web API，性能更好

## 二、App Router中的Route Handlers

### 2.1 Route Handlers概述

Route Handlers是App Router中的API路由功能，允许开发者创建自定义的请求处理程序，使用Web Request和Response API。Route Handlers文件使用`route.ts`或`route.js`命名，位于`app`目录中。

### 2.2 Route Handlers实现

Route Handlers支持多种HTTP方法，包括GET、POST、PUT、PATCH、DELETE、HEAD和OPTIONS。可以在同一个文件中定义多个HTTP方法的处理程序。

```tsx
// src/app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { fetchPosts, createPost, updatePost, deletePost } from '@/lib/posts'

export async function GET(request: NextRequest) {
  // 获取查询参数
  const searchParams = request.nextUrl.searchParams
  const page = searchParams.get('page') || '1'
  const limit = searchParams.get('limit') || '10'

  // 获取帖子列表
  const posts = await fetchPosts(Number(page), Number(limit))

  return NextResponse.json(posts)
}

export async function POST(request: NextRequest) {
  // 获取请求体
  const body = await request.json()

  // 创建帖子
  const newPost = await createPost(body)

  return NextResponse.json(newPost, { status: 201 })
}

export async function PUT(request: NextRequest) {
  // 获取请求体
  const body = await request.json()

  // 更新帖子
  const updatedPost = await updatePost(body.id, body)

  if (!updatedPost) {
    return NextResponse.json({ error: 'Post not found' }, { status: 404 })
  }

  return NextResponse.json(updatedPost)
}

export async function DELETE(request: NextRequest) {
  // 获取查询参数
  const searchParams = request.nextUrl.searchParams
  const id = searchParams.get('id')

  if (!id) {
    return NextResponse.json({ error: 'ID is required' }, { status: 400 })
  }

  // 删除帖子
  const deleted = await deletePost(Number(id))

  if (!deleted) {
    return NextResponse.json({ error: 'Post not found' }, { status: 404 })
  }

  return NextResponse.json({ message: 'Post deleted successfully' })
}
```

### 2.3 Route Handlers的高级特性

#### 2.3.1 NextRequest和NextResponse

Route Handlers支持Next.js扩展的`NextRequest`和`NextResponse` API，提供了更多的功能：

```tsx
// src/app/api/auth/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  // 获取请求头
  const authorization = request.headers.get('authorization')

  // 获取cookies
  const token = request.cookies.get('token')?.value

  // 获取IP地址
  const ip = request.ip || request.headers.get('x-forwarded-for')

  // 重定向
  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // 设置cookies
  const response = NextResponse.json({ message: 'Authenticated' })
  response.cookies.set('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24, // 24小时
  })

  return response
}
```

#### 2.3.2 动态路由

Route Handlers支持动态路由，可以处理带有参数的请求：

```tsx
// src/app/api/posts/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { fetchPostById } from '@/lib/posts'

export async function GET(
  request: NextRequest,
  {
    params,
  }: {
    params: { id: string }
  }
) {
  // 获取动态参数
  const id = params.id

  // 获取帖子详情
  const post = await fetchPostById(Number(id))

  if (!post) {
    return NextResponse.json({ error: 'Post not found' }, { status: 404 })
  }

  return NextResponse.json(post)
}
```

#### 2.3.3 流式响应

Route Handlers支持流式响应，可以返回大型数据或实时数据：

```tsx
// src/app/api/stream/route.ts
import { NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  // 创建可读流
  const stream = new ReadableStream({
    async start(controller) {
      // 发送数据
      controller.enqueue(new TextEncoder().encode('Hello, '))
      await new Promise(resolve => setTimeout(resolve, 1000))
      controller.enqueue(new TextEncoder().encode('World!'))
      await new Promise(resolve => setTimeout(resolve, 1000))
      controller.enqueue(new TextEncoder().encode(' This is a streaming response.'))
      controller.close()
    },
  })

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/plain',
    },
  })
}
```

#### 2.3.4 缓存配置

Route Handlers支持缓存配置，可以使用`next`选项设置缓存策略：

```tsx
// src/app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { fetchPosts } from '@/lib/posts'

export async function GET(request: NextRequest) {
  // 缓存10秒
  const posts = await fetchPosts(1, 10)

  return NextResponse.json(posts, {
    headers: {
      'Cache-Control': 's-maxage=10, stale-while-revalidate',
    },
  })
}
```

### 2.4 Route Handlers的最佳实践

1. **使用TypeScript**：提高代码的类型安全性和可维护性
2. **模块化设计**：将业务逻辑抽象到单独的文件中，提高代码复用性
3. **处理错误**：使用try-catch块处理错误，返回友好的错误信息
4. **验证请求**：验证请求参数、请求体和请求头，确保数据的完整性和安全性
5. **使用NextResponse**：使用NextResponse的扩展功能，如重定向、设置cookies等
6. **合理使用缓存**：根据数据更新频率设置合适的缓存策略
7. **考虑性能**：优化数据库查询，减少API调用，使用流式响应处理大型数据
8. **测试API**：编写单元测试和集成测试，确保API的正确性和可靠性

## 三、Pages Router中的API Routes

### 3.1 API Routes概述

API Routes是Pages Router中的API路由功能，基于Express风格，允许开发者创建自定义的请求处理程序。API Routes文件位于`pages/api`目录中，每个文件对应一个API端点。

### 3.2 API Routes实现

API Routes使用Express风格的请求和响应对象，支持多种HTTP方法：

```tsx
// src/pages/api/posts.ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { fetchPosts, createPost, updatePost, deletePost } from '@/lib/posts'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    switch (req.method) {
      case 'GET':
        // 获取查询参数
        const { page = '1', limit = '10' } = req.query
        const posts = await fetchPosts(Number(page), Number(limit))
        res.status(200).json(posts)
        break

      case 'POST':
        // 获取请求体
        const newPost = await createPost(req.body)
        res.status(201).json(newPost)
        break

      case 'PUT':
        // 获取请求体
        const updatedPost = await updatePost(req.body.id, req.body)
        if (!updatedPost) {
          res.status(404).json({ error: 'Post not found' })
          return
        }
        res.status(200).json(updatedPost)
        break

      case 'DELETE':
        // 获取查询参数
        const { id } = req.query
        if (!id) {
          res.status(400).json({ error: 'ID is required' })
          return
        }
        const deleted = await deletePost(Number(id))
        if (!deleted) {
          res.status(404).json({ error: 'Post not found' })
          return
        }
        res.status(200).json({ message: 'Post deleted successfully' })
        break

      default:
        res.setHeader('Allow', ['GET', 'POST', 'PUT', 'DELETE'])
        res.status(405).end(`Method ${req.method} Not Allowed`)
    }
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

### 3.3 API Routes的高级特性

#### 3.3.1 动态路由

API Routes支持动态路由，可以处理带有参数的请求：

```tsx
// src/pages/api/posts/[id].ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { fetchPostById } from '@/lib/posts'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // 获取动态参数
    const { id } = req.query
    if (!id) {
      res.status(400).json({ error: 'ID is required' })
      return
    }

    // 获取帖子详情
    const post = await fetchPostById(Number(id))
    if (!post) {
      res.status(404).json({ error: 'Post not found' })
      return
    }

    res.status(200).json(post)
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

#### 3.3.2 中间件

API Routes支持中间件，可以使用第三方中间件或自定义中间件：

```tsx
// src/pages/api/middleware.ts
import type { NextApiRequest, NextApiResponse } from 'next'

export function withAuth(
  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>
) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    // 验证token
    const token = req.headers.authorization?.split(' ')[1]
    if (!token) {
      res.status(401).json({ error: 'Unauthorized' })
      return
    }

    // 验证token有效性
    try {
      // 验证token逻辑
      const decoded = verifyToken(token)
      req.user = decoded
      await handler(req, res)
    } catch (error) {
      res.status(401).json({ error: 'Invalid token' })
    }
  }
}

// src/pages/api/protected.ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { withAuth } from './middleware'

export default withAuth(async (req: NextApiRequest, res: NextApiResponse) => {
  res.status(200).json({ message: 'Protected route', user: req.user })
})
```

#### 3.3.3 流式响应

API Routes支持流式响应，可以返回大型数据或实时数据：

```tsx
// src/pages/api/stream.ts
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.setHeader('Content-Type', 'text/plain')
  res.setHeader('Transfer-Encoding', 'chunked')

  // 发送数据
  res.write('Hello, ')

  setTimeout(() => {
    res.write('World!')
  }, 1000)

  setTimeout(() => {
    res.write(' This is a streaming response.')
    res.end()
  }, 2000)
}
```

#### 3.3.4 缓存配置

API Routes支持缓存配置，可以使用`Cache-Control`头设置缓存策略：

```tsx
// src/pages/api/posts.ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { fetchPosts } from '@/lib/posts'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // 获取帖子列表
    const posts = await fetchPosts(1, 10)

    // 缓存10秒
    res.setHeader('Cache-Control', 's-maxage=10, stale-while-revalidate')
    res.status(200).json(posts)
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

### 3.4 API Routes的最佳实践

1. **使用TypeScript**：提高代码的类型安全性和可维护性
2. **模块化设计**：将业务逻辑抽象到单独的文件中，提高代码复用性
3. **处理错误**：使用try-catch块处理错误，返回友好的错误信息
4. **验证请求**：验证请求参数、请求体和请求头，确保数据的完整性和安全性
5. **使用中间件**：使用中间件处理认证、日志记录等通用逻辑
6. **合理使用缓存**：根据数据更新频率设置合适的缓存策略
7. **考虑性能**：优化数据库查询，减少API调用，使用流式响应处理大型数据
8. **测试API**：编写单元测试和集成测试，确保API的正确性和可靠性

## 四、API路由的最佳实践

### 4.1 设计原则

1. **RESTful设计**：遵循RESTful设计原则，使用合适的HTTP方法和状态码
2. **清晰的命名**：使用清晰、一致的命名约定，如`/api/posts`、`/api/users`等
3. **版本控制**：使用版本控制，如`/api/v1/posts`、`/api/v2/posts`等
4. **分页和过滤**：对大型数据集使用分页和过滤，如`/api/posts?page=1&limit=10`
5. **排序**：支持排序功能，如`/api/posts?sort=createdAt&order=desc`
6. **字段选择**：支持字段选择，如`/api/posts?fields=id,title,createdAt`
7. **一致的响应格式**：使用一致的响应格式，如`{ "data": [...], "meta": {...} }`
8. **错误处理**：返回一致的错误格式，如`{ "error": "Error message", "code": 404 }`

### 4.2 代码组织

1. **模块化设计**：将API路由的业务逻辑抽象到单独的文件中
2. **按功能分组**：按功能模块组织API路由，如`/api/posts`、`/api/users`等
3. **使用中间件**：将通用逻辑（如认证、日志记录）抽象为中间件
4. **使用服务层**：将业务逻辑抽象到服务层，提高代码复用性和可测试性
5. **使用数据访问层**：将数据访问逻辑抽象到数据访问层，提高代码复用性和可测试性

### 4.3 性能优化

1. **优化数据库查询**：使用索引，避免全表扫描，优化查询语句
2. **使用缓存**：根据数据更新频率设置合适的缓存策略
3. **使用流式响应**：处理大型数据时使用流式响应
4. **减少API调用**：合并API调用，减少网络请求
5. **使用边缘计算**：将部分API逻辑迁移到边缘节点，减少延迟
6. **优化响应大小**：只返回必要的数据，使用压缩技术减少响应大小

### 4.4 安全性

1. **验证请求**：验证请求参数、请求体和请求头，确保数据的完整性和安全性
2. **使用HTTPS**：使用HTTPS传输数据，防止数据泄露
3. **使用CORS**：合理配置CORS，防止跨站请求伪造
4. **使用认证和授权**：实现认证和授权机制，保护敏感数据
5. **使用速率限制**：限制API的访问频率，防止恶意攻击
6. **使用输入验证**：验证用户输入，防止SQL注入、XSS等攻击
7. **使用参数化查询**：使用参数化查询，防止SQL注入
8. **保护敏感数据**：不返回敏感数据，如密码、API密钥等

## 五、API路由的测试

### 5.1 单元测试

使用Jest等测试框架测试API路由的业务逻辑：

```tsx
// src/lib/posts.test.ts
import { fetchPosts, createPost } from './posts'

// 模拟fetch
global.fetch = jest.fn(() =>
  Promise.resolve({
    ok: true,
    json: () => Promise.resolve([{ id: 1, title: 'Test Post' }]),
  })
) as jest.Mock

describe('Posts API', () => {
  it('should fetch posts', async () => {
    const posts = await fetchPosts(1, 10)
    expect(posts).toEqual([{ id: 1, title: 'Test Post' }])
  })

  it('should create post', async () => {
    const newPost = await createPost({ title: 'New Post', content: 'New Content' })
    expect(newPost).toEqual(expect.objectContaining({ title: 'New Post' }))
  })
})
```

### 5.2 集成测试

使用Supertest等测试框架测试API路由的集成：

```tsx
// src/pages/api/posts.test.ts
import request from 'supertest'
import { createServer } from 'http'
import { handler } from './posts'

// 创建测试服务器
const server = createServer((req, res) => {
  handler(req as any, res as any)
})

describe('Posts API', () => {
  afterAll(() => {
    server.close()
  })

  it('should return posts', async () => {
    const response = await request(server).get('/api/posts')
    expect(response.status).toBe(200)
    expect(response.body).toEqual([{ id: 1, title: 'Test Post' }])
  })

  it('should create post', async () => {
    const response = await request(server)
      .post('/api/posts')
      .send({ title: 'New Post', content: 'New Content' })
    expect(response.status).toBe(201)
    expect(response.body).toEqual(expect.objectContaining({ title: 'New Post' }))
  })
})
```

### 5.3 端到端测试

使用Playwright或Cypress等测试框架测试API路由的端到端功能：

```tsx
// src/tests/api.spec.ts
import { test, expect } from '@playwright/test'

test('should fetch posts', async ({ request }) => {
  const response = await request.get('/api/posts')
  expect(response.status()).toBe(200)
  const posts = await response.json()
  expect(posts).toEqual([{ id: 1, title: 'Test Post' }])
})

test('should create post', async ({ request }) => {
  const response = await request.post('/api/posts', {
    data: { title: 'New Post', content: 'New Content' },
  })
  expect(response.status()).toBe(201)
  const newPost = await response.json()
  expect(newPost).toEqual(expect.objectContaining({ title: 'New Post' }))
})
```

## 六、API路由的部署

### 6.1 Vercel部署

Next.js API路由可以直接部署到Vercel，无需额外配置：

1. 登录Vercel账号
2. 连接GitHub仓库
3. 配置项目设置
4. 点击"Deploy"按钮

Vercel会自动检测Next.js项目，并部署API路由。

### 6.2 自定义服务器部署

Next.js API路由也可以部署到自定义服务器，如Express、Fastify等：

```tsx
// src/server.ts
import express from 'express'
import next from 'next'

const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
  const server = express()

  // 解析JSON请求体
  server.use(express.json())

  // 处理API路由
  server.all('/api/*', (req, res) => {
    return handle(req, res)
  })

  // 处理页面路由
  server.all('*', (req, res) => {
    return handle(req, res)
  })

  server.listen(3000, (err?: any) => {
    if (err) throw err
    console.log('> Ready on http://localhost:3000')
  })
})
```

### 6.3 Docker部署

Next.js API路由可以使用Docker部署：

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

## 七、总结

本章节我们学习了Next.js的API路由：

1. **API路由概述**：API路由的重要性、Next.js的API路由方式、API路由选择
2. **App Router中的Route Handlers**：Route Handlers的实现、高级特性（NextRequest和NextResponse、动态路由、流式响应、缓存配置）、最佳实践
3. **Pages Router中的API Routes**：API Routes的实现、高级特性（动态路由、中间件、流式响应、缓存配置）、最佳实践
4. **API路由的最佳实践**：设计原则、代码组织、性能优化、安全性
5. **API路由的测试**：单元测试、集成测试、端到端测试
6. **API路由的部署**：Vercel部署、自定义服务器部署、Docker部署

通过本章节的学习，你应该能够深入理解Next.js的API路由功能，并根据应用需求选择合适的API路由方式。在实际项目中，需要根据应用的具体需求，结合性能、安全性、可维护性等因素，选择合适的API路由方式和实现方案。

## 八、练习

1. 创建一个Next.js项目，实现以下API路由：
   - 使用Route Handlers实现帖子的CRUD操作
   - 使用API Routes实现用户的CRUD操作
2. 实现API路由的认证和授权机制
3. 实现API路由的缓存策略
4. 实现API路由的分页、过滤和排序功能
5. 编写API路由的单元测试和集成测试
6. 部署API路由到Vercel或自定义服务器
7. 优化API路由的性能，如使用缓存、流式响应等
8. 实现API路由的错误处理和日志记录

---

**下一章预告**：中间件

在接下来的章节中，我们将深入学习Next.js的中间件，包括App Router中的Middleware、Pages Router中的中间件、中间件的实现和使用场景等。