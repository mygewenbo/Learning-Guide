# App Router深入

## 一、App Router概述

### 1.1 什么是App Router

App Router是Next.js 13引入的新路由系统，基于React Server Components构建，提供了更现代化的开发体验。它支持嵌套布局、并行路由、拦截路由等高级功能，使开发者能够构建更复杂、更高效的应用架构。

### 1.2 App Router与Pages Router的比较

| 特性 | App Router | Pages Router |
|------|------------|--------------|
| **路由系统** | 文件系统路由 + 嵌套布局 | 文件系统路由 |
| **组件类型** | 服务器组件（默认）+ 客户端组件 | 客户端组件（默认） |
| **数据获取** | 服务器组件fetch + Server Actions | getStaticProps + getServerSideProps + getInitialProps |
| **布局** | 嵌套布局、并行布局 | 单页面布局、自定义布局 |
| **路由功能** | 并行路由、拦截路由、路由组 | 动态路由、嵌套路由 |
| **渲染策略** | SSR、SSG、ISR、CSR、PPR | SSR、SSG、ISR、CSR |
| **性能优化** | 自动代码分割、图像优化、字体优化 | 手动代码分割、图像优化 |
| **React特性** | 支持React 18+新特性、React Server Components | 支持React 16+特性 |

### 1.3 App Router的优势

1. **更现代的架构**：基于React Server Components，提供更好的性能和开发体验
2. **更灵活的布局系统**：支持嵌套布局、并行布局，满足复杂应用的需求
3. **更强大的路由功能**：支持并行路由、拦截路由，实现更复杂的导航逻辑
4. **更好的性能**：自动优化代码分割、图像、字体等，提升应用性能
5. **更好的开发者体验**：提供热模块替换、自动补全、类型安全等功能
6. **更好的SEO支持**：内置服务器端渲染，提升SEO表现

## 二、嵌套布局

### 2.1 嵌套布局概述

嵌套布局是App Router的核心特性之一，允许开发者在不同路由层级定义布局，子路由会自动继承父路由的布局。这种嵌套结构使得应用的布局更加模块化、可维护。

### 2.2 嵌套布局实现

在App Router中，布局组件使用`layout.tsx`文件定义，支持嵌套布局。布局组件接收`children` prop，用于渲染子路由的内容。

```tsx
// src/app/layout.tsx (根布局)
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <header>
          <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/blog">Blog</a></li>
              <li><a href="/dashboard">Dashboard</a></li>
            </ul>
          </nav>
        </header>
        <main>{children}</main>
        <footer>
          <p>© 2024 My Next.js App</p>
        </footer>
      </body>
    </html>
  )
}
```

```tsx
// src/app/blog/layout.tsx (博客布局)
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="blog">
      <aside>
        <h2>Blog Categories</h2>
        <ul>
          <li><a href="/blog">All Posts</a></li>
          <li><a href="/blog/category/technology">Technology</a></li>
          <li><a href="/blog/category/lifestyle">Lifestyle</a></li>
        </ul>
      </aside>
      <section>{children}</section>
    </div>
  )
}
```

```tsx
// src/app/blog/page.tsx (博客首页)
export default function BlogPage() {
  return <h1>Blog Home</h1>
}
```

```tsx
// src/app/blog/[slug]/page.tsx (博客文章页)
export default function BlogPost({
  params,
}: {
  params: { slug: string }
}) {
  return <h1>Blog Post: {params.slug}</h1>
}
```

### 2.3 嵌套布局的路由结构

```
src/app/
├── layout.tsx          # 根布局
├── page.tsx           # 首页
└── blog/
    ├── layout.tsx     # 博客布局
    ├── page.tsx       # 博客首页
    └── [slug]/
        └── page.tsx   # 博客文章页
```

在这个结构中，`/blog`路由会应用根布局和博客布局，`/blog/[slug]`路由也会应用根布局和博客布局。

### 2.4 嵌套布局的最佳实践

1. **保持布局简洁**：每个布局只负责自己层级的布局逻辑，避免过于复杂
2. **使用语义化的HTML结构**：提高可访问性和SEO
3. **合理使用CSS**：使用CSS Modules或Tailwind CSS，避免样式冲突
4. **考虑响应式设计**：确保布局在不同屏幕尺寸下都能正常显示
5. **避免过度嵌套**：嵌套层级不宜过深，一般不超过3-4层
6. **使用布局组件复用**：将常用的布局逻辑抽象为组件，提高复用性

## 三、并行路由

### 3.1 并行路由概述

并行路由允许开发者在同一布局中同时渲染多个路由，这些路由可以独立导航和渲染。并行路由对于构建复杂的UI非常有用，如仪表盘、社交媒体 feeds 等。

### 3.2 并行路由实现

并行路由使用`@slot`命名约定，在布局中定义并行路由的插槽，然后在对应的`@slot`目录中创建页面组件。

```tsx
// src/app/dashboard/layout.tsx (仪表盘布局)
export default function DashboardLayout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  team: React.ReactNode
  analytics: React.ReactNode
}) {
  return (
    <div className="dashboard">
      <header>
        <h1>Dashboard</h1>
      </header>
      <div className="dashboard-content">
        <main>{children}</main>
        <aside className="team-panel">{team}</aside>
        <aside className="analytics-panel">{analytics}</aside>
      </div>
    </div>
  )
}
```

```
src/app/dashboard/
├── layout.tsx          # 仪表盘布局
├── page.tsx           # 仪表盘首页
├── @team/             # 团队并行路由
│   ├── page.tsx       # 团队页面
│   └── default.tsx    # 默认团队页面（必填）
└── @analytics/        #  analytics并行路由
    ├── page.tsx       #  analytics页面
    └── default.tsx    # 默认analytics页面（必填）
```

### 3.3 并行路由的默认页面

在Next.js 16中，所有并行路由插槽都需要显式的`default.tsx`文件。如果没有提供，构建会失败。`default.tsx`文件可以返回`null`或调用`notFound()`。

```tsx
// src/app/dashboard/@team/default.tsx
import { notFound } from 'next/navigation'

export default function DefaultTeam() {
  // 或者返回 null
  return notFound()
}
```

### 3.4 并行路由的使用场景

1. **仪表盘**：同时显示主内容、团队信息、analytics数据
2. **社交媒体 feeds**：同时显示主feed、趋势、通知
3. **电商网站**：同时显示产品列表、筛选条件、购物车
4. **文档网站**：同时显示文档内容、目录、搜索结果

### 3.5 并行路由的最佳实践

1. **合理使用并行路由**：只在需要同时显示多个独立路由时使用
2. **保持插槽简洁**：每个插槽只负责自己的内容，避免过于复杂
3. **使用默认页面**：为每个并行路由插槽提供默认页面
4. **考虑性能**：并行路由会增加服务器负载，需要合理设计
5. **使用拦截路由**：结合拦截路由实现更复杂的UI，如模态框

## 四、拦截路由

### 4.1 拦截路由概述

拦截路由允许开发者从应用的一个部分加载另一个部分的路由，并在当前布局中显示。拦截路由对于构建模态框、弹出层等UI非常有用，可以保持上下文并支持深度链接。

### 4.2 拦截路由实现

拦截路由使用`(..)`命名约定，基于路由段而不是文件系统。可以使用不同的前缀来匹配不同层级的路由：

- `(.)`：匹配同一层级的路由段
- `(..)`：匹配上一层级的路由段
- `(..)(..)`：匹配上上层级的路由段
- `(...)`：匹配根目录的路由段

```
src/app/
├── feed/
│   ├── page.tsx           #  feed首页
│   └── (..)photo/         # 拦截photo路由
│       └── [id]/
│           └── page.tsx   #  photo详情页（模态框）
└── photo/
    └── [id]/
        └── page.tsx       #  photo详情页（完整页面）
```

### 4.3 拦截路由与模态框

拦截路由可以与并行路由结合使用，创建支持深度链接的模态框：

```tsx
// src/app/feed/layout.tsx (feed布局)
export default function FeedLayout({
  children,
  modal,
}: {
  children: React.ReactNode
  modal: React.ReactNode
}) {
  return (
    <div className="feed">
      {children}
      {modal} {/* 模态框插槽 */}
    </div>
  )
}
```

```
src/app/feed/
├── layout.tsx           #  feed布局
├── page.tsx             #  feed首页
├── @modal/              # 模态框并行路由
│   └── default.tsx      # 默认模态框（null）
└── (..)photo/           # 拦截photo路由
    └── [id]/
        └── page.tsx     #  photo详情页（模态框）
```

```tsx
// src/app/feed/@modal/default.tsx
export default function DefaultModal() {
  return null // 默认不显示模态框
}
```

```tsx
// src/app/feed/(..)photo/[id]/page.tsx (photo详情模态框)
'use client'
import { useRouter } from 'next/navigation'

export default function PhotoModal({
  params,
}: {
  params: { id: string }
}) {
  const router = useRouter()

  return (
    <div className="modal-overlay" onClick={() => router.back()}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <h1>Photo: {params.id}</h1>
        <button onClick={() => router.back()}>Close</button>
      </div>
    </div>
  )
}
```

### 4.4 拦截路由的优势

1. **支持深度链接**：模态框内容可以通过URL分享
2. **保持上下文**：页面刷新时保持模态框打开状态
3. **正确的导航行为**：后退导航关闭模态框，前进导航重新打开模态框
4. **更好的用户体验**：保持当前页面上下文，避免用户流失

### 4.5 拦截路由的最佳实践

1. **用于模态框和弹出层**：拦截路由最适合用于模态框、弹出层等UI
2. **保持模态框简洁**：模态框内容不宜过于复杂，影响用户体验
3. **使用正确的命名约定**：根据路由层级选择合适的前缀
4. **考虑可访问性**：确保模态框支持键盘导航和屏幕阅读器
5. **测试导航行为**：确保前进、后退、刷新等操作都能正常工作
6. **结合并行路由**：与并行路由结合使用，实现更复杂的UI

## 五、路由组

### 5.1 路由组概述

路由组允许开发者将路由组织在一起，而不会影响URL结构。路由组使用`(group)`命名约定，用于组织相关的路由，提高代码的可维护性。

### 5.2 路由组实现

路由组使用括号包裹目录名，如`(auth)`、`(dashboard)`等。路由组不会影响URL结构，只用于组织代码。

```
src/app/
├── (auth)/              # 认证路由组
│   ├── login/
│   │   └── page.tsx     # 登录页 → /login
│   └── register/
│       └── page.tsx     # 注册页 → /register
├── (dashboard)/         # 仪表盘路由组
│   ├── layout.tsx       # 仪表盘布局
│   ├── page.tsx         # 仪表盘首页 → /dashboard
│   └── settings/
│       └── page.tsx     # 设置页 → /dashboard/settings
└── layout.tsx           # 根布局
```

在这个结构中，`/login`和`/register`路由不会包含`(auth)`在URL中，`/dashboard`和`/dashboard/settings`路由也不会包含`(dashboard)`在URL中。

### 5.3 路由组的使用场景

1. **组织相关路由**：将认证、仪表盘、公共路由等组织在一起
2. **应用不同的布局**：为不同的路由组应用不同的布局
3. **实现权限控制**：为不同的路由组应用不同的权限控制
4. **提高代码可维护性**：使代码结构更加清晰，易于维护

### 5.4 路由组的最佳实践

1. **使用有意义的组名**：组名应该反映路由的用途，如`(auth)`、`(dashboard)`等
2. **合理分组**：根据功能或权限将路由分组，避免过度分组
3. **保持组内简洁**：每个组内的路由应该具有相似的功能或权限
4. **使用布局**：为不同的路由组应用不同的布局
5. **考虑权限控制**：结合中间件实现不同路由组的权限控制

## 六、动态路由

### 6.1 动态路由概述

动态路由允许开发者创建带有参数的路由，如博客文章、产品详情等。动态路由使用`[param]`命名约定，参数值可以通过`params` prop传递给页面组件。

### 6.2 动态路由实现

```tsx
// src/app/blog/[slug]/page.tsx (博客文章页)
export default function BlogPost({
  params,
}: {
  params: { slug: string }
}) {
  return <h1>Blog Post: {params.slug}</h1>
}
```

### 6.3 动态路由的生成

在App Router中，可以使用`generateStaticParams`函数生成静态路由，用于静态站点生成（SSG）：

```tsx
// src/app/blog/[slug]/page.tsx
export async function generateStaticParams() {
  // 获取所有博客文章的slug
  const posts = await fetchPosts()
  
  return posts.map((post) => ({
    slug: post.slug,
  }))
}

export default async function BlogPost({
  params,
}: {
  params: { slug: string }
}) {
  // 获取单个博客文章
  const post = await fetchPost(params.slug)
  
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  )
}
```

### 6.4 动态路由的类型安全

在TypeScript项目中，可以使用`InferGetStaticParamsType`类型辅助工具获取动态路由参数的类型：

```tsx
// src/app/blog/[slug]/page.tsx
import type { InferGetStaticParamsType } from 'next'

export async function generateStaticParams() {
  const posts = await fetchPosts()
  
  return posts.map((post) => ({
    slug: post.slug,
  }))
}

export default async function BlogPost({
  params,
}: {
  params: InferGetStaticParamsType<typeof generateStaticParams>
}) {
  // params.slug 会自动获得正确的类型
  const post = await fetchPost(params.slug)
  
  return <h1>{post.title}</h1>
}
```

### 6.5 动态路由的最佳实践

1. **使用有意义的参数名**：参数名应该反映参数的用途，如`[slug]`、`[id]`等
2. **验证参数**：在页面组件中验证参数的有效性，避免无效参数导致的错误
3. **使用generateStaticParams**：对于静态内容，使用generateStaticParams生成静态路由
4. **考虑SEO**：为动态路由添加合适的元数据，提高SEO
5. **使用错误处理**：为无效的动态路由提供友好的错误页面
6. **考虑性能**：动态路由会增加服务器负载，需要合理设计

## 七、加载状态

### 7.1 加载状态概述

加载状态允许开发者在页面或组件加载过程中显示加载指示器，提高用户体验。在App Router中，可以使用`loading.tsx`文件定义加载状态组件。

### 7.2 加载状态实现

```tsx
// src/app/blog/loading.tsx (博客加载状态)
export default function BlogLoading() {
  return (
    <div className="loading">
      <div className="spinner"></div>
      <p>Loading blog posts...</p>
    </div>
  )
}
```

当访问`/blog`路由时，如果数据加载需要时间，会先显示`loading.tsx`组件，直到数据加载完成。

### 7.3 嵌套加载状态

加载状态支持嵌套，每个路由段都可以定义自己的加载状态：

```
src/app/
├── loading.tsx          # 根加载状态
├── page.tsx           # 首页
└── blog/
    ├── loading.tsx     # 博客加载状态
    ├── page.tsx       # 博客首页
    └── [slug]/
        ├── loading.tsx # 博客文章加载状态
        └── page.tsx   # 博客文章页
```

在这个结构中，访问`/blog/[slug]`路由时，如果数据加载需要时间，会先显示根加载状态，然后显示博客加载状态，最后显示博客文章加载状态。

### 7.4 加载状态的最佳实践

1. **保持加载状态简洁**：加载状态不宜过于复杂，避免影响用户体验
2. **提供有用的反馈**：告诉用户正在加载什么内容
3. **使用动画**：使用简单的动画，如旋转加载器，提高用户体验
4. **考虑可访问性**：确保加载状态支持屏幕阅读器
5. **避免闪烁**：加载状态应该在数据加载需要时间时才显示，避免不必要的闪烁
6. **使用骨架屏**：对于复杂的UI，可以使用骨架屏，提供更好的用户体验

## 八、错误处理

### 8.1 错误处理概述

错误处理允许开发者在页面或组件发生错误时显示友好的错误页面，提高用户体验。在App Router中，可以使用`error.tsx`文件定义错误页面组件。

### 8.2 错误处理实现

```tsx
// src/app/blog/error.tsx (博客错误页面) 'use client'
export default function BlogError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div className="error">
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

当访问`/blog`路由时，如果发生错误，会显示`error.tsx`组件，用户可以点击"Try again"按钮重新加载页面。

### 8.3 嵌套错误处理

错误处理支持嵌套，每个路由段都可以定义自己的错误页面：

```
src/app/
├── error.tsx          # 根错误页面
├── page.tsx           # 首页
└── blog/
    ├── error.tsx     # 博客错误页面
    ├── page.tsx       # 博客首页
    └── [slug]/
        ├── error.tsx # 博客文章错误页面
        └── page.tsx   # 博客文章页
```

在这个结构中，访问`/blog/[slug]`路由时，如果发生错误，会先查找博客文章错误页面，如果没有，会查找博客错误页面，如果还没有，会查找根错误页面。

### 8.4 错误处理的最佳实践

1. **提供友好的错误信息**：避免显示技术错误信息，使用用户友好的语言
2. **提供重置功能**：允许用户重新加载页面，恢复正常状态
3. **记录错误**：将错误信息发送到日志系统，便于开发者调试
4. **考虑可访问性**：确保错误页面支持屏幕阅读器
5. **测试错误处理**：测试各种错误场景，确保错误页面能正常显示
6. **使用边界错误处理**：对于关键组件，可以使用React的Error Boundary

## 九、App Router最佳实践

### 9.1 路由设计最佳实践

1. **使用RESTful路由**：遵循RESTful设计原则，使路由更加直观
2. **保持路由简洁**：路由不宜过长，一般不超过3-4个段
3. **使用有意义的路由名**：路由名应该反映页面的用途，如`/blog`、`/dashboard`等
4. **避免深层嵌套**：嵌套层级不宜过深，一般不超过3-4层
5. **使用路由组**：将相关路由组织在一起，提高代码可维护性
6. **考虑SEO**：为路由添加合适的元数据，提高SEO

### 9.2 布局设计最佳实践

1. **保持布局简洁**：每个布局只负责自己层级的布局逻辑
2. **使用语义化的HTML结构**：提高可访问性和SEO
3. **合理使用CSS**：使用CSS Modules或Tailwind CSS，避免样式冲突
4. **考虑响应式设计**：确保布局在不同屏幕尺寸下都能正常显示
5. **使用布局组件复用**：将常用的布局逻辑抽象为组件，提高复用性
6. **避免过度嵌套**：嵌套层级不宜过深，影响性能和可维护性

### 9.3 性能优化最佳实践

1. **使用服务器组件**：优先使用服务器组件，减少客户端JavaScript体积
2. **优化数据获取**：使用fetch API的缓存功能，减少API调用
3. **优化图像**：使用Image组件，自动优化图像
4. **优化字体**：使用Font组件，自动优化字体加载
5. **优化脚本**：使用Script组件，智能加载第三方脚本
6. **使用代码分割**：自动代码分割，减少初始加载时间
7. **使用静态生成**：对于静态内容，使用静态生成，提高性能

### 9.4 代码组织最佳实践

1. **保持文件结构清晰**：按照功能或路由组织文件
2. **使用TypeScript**：提高代码的类型安全性和可维护性
3. **使用ESLint和Prettier**：保持代码风格一致
4. **使用Git**：使用Git进行版本控制，便于协作和回滚
5. **编写测试**：编写单元测试和集成测试，提高代码质量
6. **使用注释**：为复杂的代码添加注释，提高可维护性

## 十、总结

本章节我们学习了App Router的深入内容：

1. **App Router概述**：App Router的定义、与Pages Router的比较、优势
2. **嵌套布局**：嵌套布局的定义、实现、路由结构、最佳实践
3. **并行路由**：并行路由的定义、实现、默认页面、使用场景、最佳实践
4. **拦截路由**：拦截路由的定义、实现、与模态框结合、优势、最佳实践
5. **路由组**：路由组的定义、实现、使用场景、最佳实践
6. **动态路由**：动态路由的定义、实现、生成、类型安全、最佳实践
7. **加载状态**：加载状态的定义、实现、嵌套加载状态、最佳实践
8. **错误处理**：错误处理的定义、实现、嵌套错误处理、最佳实践
9. **App Router最佳实践**：路由设计、布局设计、性能优化、代码组织的最佳实践

通过本章节的学习，你应该能够深入理解App Router的高级功能，并能够使用这些功能构建复杂、高效的Next.js应用。在接下来的章节中，我们将学习Next.js的数据获取策略，包括服务器组件fetch、Server Actions、客户端数据获取等。

## 十一、练习

1. 创建一个Next.js项目，使用App Router实现嵌套布局
2. 实现并行路由，构建一个仪表盘UI，同时显示多个路由
3. 实现拦截路由，构建一个支持深度链接的模态框
4. 使用路由组组织相关路由
5. 实现动态路由，包括generateStaticParams
6. 为路由添加加载状态和错误处理
7. 应用App Router的最佳实践，优化应用的性能和可维护性
8. 测试各种路由场景，确保路由功能正常工作

---

**下一章预告**：Next.js数据获取策略

在接下来的章节中，我们将深入学习Next.js的数据获取策略，包括服务器组件fetch、Server Actions、客户端数据获取等。