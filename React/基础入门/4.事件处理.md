# 事件处理

## 一、事件处理基础

### 1.1 什么是事件

事件是用户与应用交互时发生的动作，例如点击按钮、输入文本、鼠标移动等。React提供了一套事件处理系统，用于处理这些用户交互。

### 1.2 React事件系统

React实现了自己的事件系统，称为合成事件（SyntheticEvent）。合成事件是React对原生DOM事件的封装，提供了跨浏览器的一致接口。

#### 1.2.1 合成事件的优势

- **跨浏览器兼容性**：React处理了不同浏览器之间的事件差异
- **事件委托**：React自动使用事件委托优化性能
- **统一的API**：所有事件都有相同的API，无论浏览器如何
- **自动绑定**：在React 16.8+中，函数组件的事件处理函数不需要手动绑定this

### 1.3 事件命名

React事件的命名采用驼峰式命名法（camelCase），而不是HTML的小写命名法。

```jsx
// HTML事件
<button onclick="handleClick()">Click me</button>

// React事件
<button onClick={handleClick}>Click me</button>
```

## 二、事件绑定方式

### 2.1 函数组件中的事件绑定

在函数组件中，事件处理函数直接作为变量定义在组件内部，不需要手动绑定this。

```jsx
function Component() {
  // 定义事件处理函数
  const handleClick = () => {
    console.log('Button clicked!');
  };

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

### 2.2 类组件中的事件绑定

在类组件中，事件处理函数需要绑定this，否则this会指向undefined。

#### 2.2.1 在构造函数中绑定

```jsx
class Component extends React.Component {
  constructor(props) {
    super(props);
    // 绑定this
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    console.log('Button clicked!', this.props);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```

#### 2.2.2 使用箭头函数绑定

```jsx
class Component extends React.Component {
  // 使用箭头函数，自动绑定this
  handleClick = () => {
    console.log('Button clicked!', this.props);
  };

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```

#### 2.2.3 在JSX中使用箭头函数

```jsx
class Component extends React.Component {
  handleClick() {
    console.log('Button clicked!', this.props);
  }

  render() {
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    );
  }
}
```

#### 2.2.4 在JSX中使用bind

```jsx
class Component extends React.Component {
  handleClick() {
    console.log('Button clicked!', this.props);
  }

  render() {
    return (
      <button onClick={this.handleClick.bind(this)}>
        Click me
      </button>
    );
  }
}
```

### 2.3 事件处理函数的比较

| 绑定方式 | 优点 | 缺点 |
|---------|------|------|
| 构造函数绑定 | 性能好，只绑定一次 | 代码冗余 |
| 箭头函数属性 | 语法简洁，自动绑定 | 每个实例都会创建新函数（轻微性能影响） |
| JSX箭头函数 | 语法简洁，可传递参数 | 每次渲染都会创建新函数 |
| JSX bind | 可传递参数 | 每次渲染都会创建新函数 |

## 三、事件对象

### 3.1 访问事件对象

在事件处理函数中，可以通过参数访问事件对象。

```jsx
function handleClick(event) {
  event.preventDefault(); // 阻止默认行为
  console.log('Button clicked!', event);
}

<button onClick={handleClick}>Click me</button>
```

### 3.2 合成事件对象的属性和方法

合成事件对象包含以下常用属性和方法：

#### 3.2.1 属性

- `event.target`：触发事件的元素
- `event.currentTarget`：绑定事件的元素
- `event.type`：事件类型
- `event.nativeEvent`：原生DOM事件对象
- `event.bubbles`：事件是否冒泡
- `event.cancelable`：事件是否可取消
- `event.timeStamp`：事件发生的时间戳

#### 3.2.2 方法

- `event.preventDefault()`：阻止默认行为（如链接跳转、表单提交）
- `event.stopPropagation()`：阻止事件冒泡
- `event.stopImmediatePropagation()`：阻止事件冒泡和当前元素上的其他事件处理函数
- `event.persist()`：在异步函数中保留事件对象（React 16+）

### 3.3 原生事件对象

如果需要访问原生DOM事件对象，可以使用`event.nativeEvent`属性。

```jsx
function handleClick(event) {
  console.log('Synthetic event:', event);
  console.log('Native event:', event.nativeEvent);
}
```

### 3.4 事件对象的异步访问

在React 16之前，事件对象在事件处理函数执行完毕后会被销毁。如果需要在异步函数中访问事件对象，需要调用`event.persist()`方法。

```jsx
function handleClick(event) {
  event.persist(); // 保留事件对象
  
  setTimeout(() => {
    console.log('Event type:', event.type); // 异步访问事件对象
  }, 1000);
}
```

在React 16+中，事件对象不再需要手动调用`persist()`，可以直接在异步函数中访问。

## 四、事件冒泡和捕获

### 4.1 事件流

DOM事件流分为三个阶段：

1. **捕获阶段**：事件从window对象向下传播到目标元素
2. **目标阶段**：事件到达目标元素
3. **冒泡阶段**：事件从目标元素向上传播到window对象

### 4.2 事件冒泡

默认情况下，事件会从目标元素向上冒泡到window对象。

```jsx
function handleParentClick() {
  console.log('Parent clicked!');
}

function handleChildClick(event) {
  console.log('Child clicked!');
  // event.stopPropagation(); // 阻止事件冒泡
}

function Component() {
  return (
    <div onClick={handleParentClick} className="parent">
      <button onClick={handleChildClick} className="child">
        Click me
      </button>
    </div>
  );
}
```

### 4.3 阻止事件冒泡

使用`event.stopPropagation()`方法可以阻止事件冒泡。

```jsx
function handleChildClick(event) {
  event.stopPropagation(); // 阻止事件冒泡
  console.log('Child clicked!');
}
```

### 4.4 事件捕获

默认情况下，React事件处理函数在冒泡阶段执行。如果需要在捕获阶段执行，可以使用`Capture`后缀。

```jsx
function handleParentClick() {
  console.log('Parent capture clicked!');
}

function handleChildClick() {
  console.log('Child clicked!');
}

function Component() {
  return (
    <div onClickCapture={handleParentClick} className="parent">
      <button onClick={handleChildClick} className="child">
        Click me
      </button>
    </div>
  );
}
```

### 4.5 事件委托

事件委托是一种优化技术，它将事件处理函数绑定到父元素上，而不是每个子元素上。当事件冒泡到父元素时，通过`event.target`判断触发事件的子元素。

```jsx
function handleClick(event) {
  if (event.target.tagName === 'BUTTON') {
    console.log('Button clicked:', event.target.textContent);
  }
}

function Component() {
  return (
    <div onClick={handleClick} className="button-container">
      <button>Button 1</button>
      <button>Button 2</button>
      <button>Button 3</button>
    </div>
  );
}
```

## 五、传递参数

### 5.1 使用箭头函数传递参数

```jsx
function handleClick(id, event) {
  event.preventDefault();
  console.log(`Button ${id} clicked!`);
}

<button onClick={(event) => handleClick(1, event)}>
  Button 1
</button>
```

### 5.2 使用bind传递参数

```jsx
function handleClick(id, event) {
  event.preventDefault();
  console.log(`Button ${id} clicked!`);
}

<button onClick={handleClick.bind(null, 1)}>
  Button 1
</button>
```

### 5.3 在类组件中传递参数

```jsx
class Component extends React.Component {
  handleClick = (id, event) => {
    event.preventDefault();
    console.log(`Button ${id} clicked!`);
  };

  render() {
    return (
      <button onClick={(event) => this.handleClick(1, event)}>
        Button 1
      </button>
    );
  }
}
```

## 六、常见事件类型

### 6.1 鼠标事件

- `onClick`：点击事件
- `onDoubleClick`：双击事件
- `onMouseDown`：鼠标按下事件
- `onMouseUp`：鼠标释放事件
- `onMouseEnter`：鼠标进入事件（不冒泡）
- `onMouseLeave`：鼠标离开事件（不冒泡）
- `onMouseOver`：鼠标悬停事件（冒泡）
- `onMouseOut`：鼠标移出事件（冒泡）
- `onMouseMove`：鼠标移动事件

### 6.2 键盘事件

- `onKeyDown`：键盘按下事件
- `onKeyUp`：键盘释放事件
- `onKeyPress`：键盘按下并释放事件（已废弃）

### 6.3 表单事件

- `onChange`：表单元素值变化事件
- `onInput`：表单元素输入事件
- `onSubmit`：表单提交事件
- `onReset`：表单重置事件
- `onFocus`：元素获得焦点事件
- `onBlur`：元素失去焦点事件

### 6.4 触摸事件

- `onTouchStart`：触摸开始事件
- `onTouchMove`：触摸移动事件
- `onTouchEnd`：触摸结束事件
- `onTouchCancel`：触摸取消事件

### 6.5 拖拽事件

- `onDrag`：拖拽事件
- `onDragStart`：拖拽开始事件
- `onDragEnd`：拖拽结束事件
- `onDragEnter`：拖拽进入事件
- `onDragLeave`：拖拽离开事件
- `onDragOver`：拖拽悬停事件
- `onDrop`：拖拽释放事件

## 七、表单事件处理

### 7.1 受控组件

受控组件是指表单元素的值由React状态控制。

```jsx
import { useState } from 'react';

function Form() {
  const [value, setValue] = useState('');

  const handleChange = (event) => {
    setValue(event.target.value);
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Submitted value:', value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={value}
        onChange={handleChange}
        placeholder="Enter text"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### 7.2 非受控组件

非受控组件是指表单元素的值由DOM本身控制，通过ref来获取值。

```jsx
import { useRef } from 'react';

function Form() {
  const inputRef = useRef(null);

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Submitted value:', inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" ref={inputRef} placeholder="Enter text" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### 7.3 处理多个表单字段

```jsx
import { useState } from 'react';

function Form() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: ''
  });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Submitted form data:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="name">Name:</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
      </div>
      <div>
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
      </div>
      <div>
        <label htmlFor="password">Password:</label>
        <input
          type="password"
          id="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
        />
      </div>
      <button type="submit">Submit</button>
    </form>
  );
}
```

## 八、事件处理最佳实践

### 8.1 避免内联事件处理函数

内联事件处理函数会在每次渲染时创建新的函数实例，可能导致性能问题。

```jsx
// 不推荐
<button onClick={() => console.log('Clicked!')}>Click me</button>

// 推荐
const handleClick = () => console.log('Clicked!');
<button onClick={handleClick}>Click me</button>
```

### 8.2 使用useCallback优化事件处理函数

当事件处理函数作为props传递给子组件时，使用`useCallback`可以避免不必要的重渲染。

```jsx
import { useCallback } from 'react';

function Parent() {
  const handleClick = useCallback(() => {
    console.log('Button clicked!');
  }, []); // 空依赖数组，只创建一次

  return <Child onClick={handleClick} />;
}

function Child({ onClick }) {
  return <button onClick={onClick}>Click me</button>;
}
```

### 8.3 正确使用event.preventDefault()

只在需要时调用`event.preventDefault()`，不要滥用。

```jsx
// 正确使用
function handleSubmit(event) {
  event.preventDefault(); // 阻止表单默认提交行为
  // 自定义提交逻辑
}

// 不必要的使用
function handleClick(event) {
  event.preventDefault(); // 按钮点击不需要阻止默认行为
  console.log('Button clicked!');
}
```

### 8.4 避免在事件处理函数中直接修改DOM

React通过状态管理DOM，避免在事件处理函数中直接修改DOM。

```jsx
// 不推荐
function handleClick() {
  document.getElementById('myElement').style.color = 'red';
}

// 推荐
function Component() {
  const [color, setColor] = useState('black');
  
  const handleClick = () => {
    setColor('red');
  };
  
  return <div style={{ color }} onClick={handleClick}>Click me</div>;
}
```

### 8.5 使用事件委托优化大量元素的事件处理

当需要为大量元素添加事件处理函数时，使用事件委托可以提高性能。

```jsx
function handleClick(event) {
  if (event.target.tagName === 'LI') {
    console.log('List item clicked:', event.target.textContent);
  }
}

function Component() {
  const items = Array.from({ length: 100 }, (_, i) => `Item ${i + 1}`);
  
  return (
    <ul onClick={handleClick}>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

## 九、常见问题与解决方案

### 9.1 事件处理函数不执行

- 检查事件名称是否正确（驼峰式命名）
- 检查事件处理函数是否正确传递（不要加括号）
- 检查组件是否正确渲染
- 检查事件是否被其他元素遮挡

### 9.2 this指向undefined

- 在类组件中，确保事件处理函数已正确绑定this
- 使用箭头函数作为事件处理函数
- 在构造函数中绑定this

### 9.3 事件对象在异步函数中访问不到

- 在React 16之前，调用`event.persist()`方法
- 在React 16+中，直接访问事件对象即可

### 9.4 事件冒泡导致多次触发

- 使用`event.stopPropagation()`阻止事件冒泡
- 使用`onMouseEnter`/`onMouseLeave`替代`onMouseOver`/`onMouseOut`

### 9.5 表单提交后页面刷新

- 在`onSubmit`事件处理函数中调用`event.preventDefault()`
- 确保表单的`method`属性不是`get`，或者使用`event.preventDefault()`

### 9.6 键盘事件不触发

- 检查元素是否可以获得焦点（添加`tabIndex`属性）
- 检查事件类型是否正确
- 检查元素是否处于禁用状态

## 十、总结

本章节我们学习了：

1. React事件系统的基础概念
2. 不同组件类型中的事件绑定方式
3. 事件对象的属性和方法
4. 事件冒泡和捕获机制
5. 事件委托的优化技术
6. 常见事件类型和表单事件处理
7. 事件处理的最佳实践
8. 常见问题与解决方案

事件处理是React开发中的重要部分，掌握好事件处理对于构建交互式应用至关重要。通过不断练习和实践，你将能够熟练地使用React事件系统构建复杂的交互式应用。

## 十一、练习

1. 创建一个按钮，点击后显示当前时间
2. 创建一个表单，包含姓名、邮箱和密码字段，实现表单验证和提交
3. 创建一个列表，点击列表项后高亮显示
4. 实现一个计数器，支持点击按钮增减数量
5. 创建一个拖拽组件，支持拖拽元素到指定位置
6. 实现一个键盘快捷键功能，按下Ctrl+S保存数据
7. 创建一个模态框，点击外部关闭模态框
8. 实现一个无限滚动列表，滚动到底部加载更多数据

---

**下一章预告**：生命周期（类组件）

在接下来的章节中，我们将深入学习类组件的生命周期，包括挂载、更新和卸载阶段的生命周期方法。