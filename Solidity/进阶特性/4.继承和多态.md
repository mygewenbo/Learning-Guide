# 继承和多态

## 一、继承概述

### 1.1 继承定义
- 继承是面向对象编程的核心概念之一
- 允许一个合约（子类）继承另一个合约（父类）的特性
- 支持代码复用和模块化设计
- 示例：
  ```solidity
  // 父合约
  contract Parent {
      uint256 public parentValue;
      
      function parentFunction() public view returns (uint256) {
          return parentValue;
      }
  }
  
  // 子合约，继承自Parent
  contract Child is Parent {
      uint256 public childValue;
      
      function childFunction() public view returns (uint256) {
          return childValue + parentValue;
      }
  }
  ```

### 1.2 继承的优势
- **代码复用**：避免重复编写相同的代码
- **模块化设计**：将功能分解为多个合约
- **可扩展性**：便于添加新功能
- **层次化结构**：清晰的合约关系
- **多态支持**：允许不同合约类型的统一处理

### 1.3 Solidity继承的特点
- 支持单继承和多继承
- 支持函数重写
- 支持修饰符继承和重写
- 支持构造函数继承
- 支持抽象合约和接口继承

## 二、单继承

### 2.1 单继承定义
- 一个子合约只继承一个父合约
- 最简单的继承形式
- 示例：
  ```solidity
  contract Animal {
      string public name;
      uint256 public age;
      
      constructor(string memory _name, uint256 _age) {
          name = _name;
          age = _age;
      }
      
      function makeSound() public virtual view returns (string memory) {
          return "Some sound";
      }
  }
  
  contract Dog is Animal {
      constructor(string memory _name, uint256 _age) Animal(_name, _age) {
          // 额外的初始化
      }
      
      function makeSound() public override view returns (string memory) {
          return "Woof!";
      }
      
      function fetch() public pure returns (string memory) {
          return "Fetching the ball!";
      }
  }
  ```

### 2.2 函数重写
- 使用`virtual`关键字标记父类中可重写的函数
- 使用`override`关键字标记子类中重写的函数
- 示例：
  ```solidity
  contract Parent {
      // 标记为可重写
      function doSomething() public virtual pure returns (string memory) {
          return "Parent doing something";
      }
  }
  
  contract Child is Parent {
      // 重写父类函数
      function doSomething() public override pure returns (string memory) {
          return "Child doing something";
      }
  }
  ```

### 2.3 构造函数继承
- 子类必须调用父类的构造函数
- 可以通过参数列表或初始化列表调用
- 示例：
  ```solidity
  contract Parent {
      uint256 public value;
      
      constructor(uint256 _value) {
          value = _value;
      }
  }
  
  // 方式1：通过参数列表调用父类构造函数
  contract Child1 is Parent {
      constructor(uint256 _value) Parent(_value) {
          // 子类构造函数逻辑
      }
  }
  
  // 方式2：通过初始化列表调用父类构造函数
  contract Child2 is Parent(100) {
      // 子类构造函数，父类构造函数自动调用，传入100
      constructor() {
          // 子类构造函数逻辑
      }
  }
  ```

### 2.4 修饰符继承和重写
- 修饰符可以被继承
- 修饰符可以被重写
- 示例：
  ```solidity
  contract Parent {
      address public owner;
      
      constructor() {
          owner = msg.sender;
      }
      
      modifier onlyOwner() {
          require(msg.sender == owner, "Not owner");
          _;
      }
      
      function parentFunction() public onlyOwner pure returns (string memory) {
          return "Parent function called";
      }
  }
  
  contract Child is Parent {
      // 重写修饰符
      modifier onlyOwner() {
          super.onlyOwner(); // 调用父类修饰符
          require(someAdditionalCondition, "Additional condition failed");
          _;
      }
      
      function childFunction() public onlyOwner pure returns (string memory) {
          return "Child function called";
      }
  }
  ```

## 三、多继承

### 3.1 多继承定义
- 一个子合约可以继承多个父合约
- 使用逗号分隔多个父合约
- 示例：
  ```solidity
  contract A {
      function functionA() public pure returns (string memory) {
          return "Function A";
      }
  }
  
  contract B {
      function functionB() public pure returns (string memory) {
          return "Function B";
      }
  }
  
  // 多继承：同时继承A和B
  contract C is A, B {
      function functionC() public pure returns (string memory) {
          return "Function C";
      }
  }
  ```

### 3.2 继承顺序
- 继承顺序影响函数调用和状态变量的解析
- 从左到右的顺序
- 示例：
  ```solidity
  contract Base {
      function whoAmI() public virtual pure returns (string memory) {
          return "Base";
      }
  }
  
  contract Left is Base {
      function whoAmI() public override pure returns (string memory) {
          return "Left";
      }
  }
  
  contract Right is Base {
      function whoAmI() public override pure returns (string memory) {
          return "Right";
      }
  }
  
  // 继承顺序：Left, Right
  contract Child1 is Left, Right {
      // 调用whoAmI()会返回"Right"，因为Right在继承列表中更靠右
  }
  
  // 继承顺序：Right, Left
  contract Child2 is Right, Left {
      // 调用whoAmI()会返回"Left"，因为Left在继承列表中更靠右
  }
  ```

### 3.3 菱形继承问题
- 当多个父合约继承自同一个祖父合约时产生
- Solidity通过C3线性化算法解决
- 确保每个合约只被初始化一次
- 示例：
  ```solidity
  contract Grandparent {
      constructor() {
          // 初始化逻辑
      }
  }
  
  contract Parent1 is Grandparent {
      constructor() Grandparent() {
          // 初始化逻辑
      }
  }
  
  contract Parent2 is Grandparent {
      constructor() Grandparent() {
          // 初始化逻辑
      }
  }
  
  // 菱形继承：Child继承Parent1和Parent2，它们都继承自Grandparent
  contract Child is Parent1, Parent2 {
      constructor() Parent1() Parent2() {
          // Grandparent只会被初始化一次
      }
  }
  ```

### 3.4 函数冲突解决
- 当多个父合约有同名函数时，必须在子合约中明确重写
- 使用`override`关键字并指定所有父合约
- 示例：
  ```solidity
  contract A {
      function foo() public virtual pure returns (string memory) {
          return "A.foo";
      }
  }
  
  contract B {
      function foo() public virtual pure returns (string memory) {
          return "B.foo";
      }
  }
  
  // 必须明确重写foo()函数
  contract C is A, B {
      function foo() public override(A, B) pure returns (string memory) {
          return "C.foo";
      }
  }
  ```

## 四、抽象合约

### 4.1 抽象合约定义
- 包含未实现函数的合约
- 使用`abstract`关键字标记
- 不能直接部署
- 用于定义接口和基础功能
- 示例：
  ```solidity
  abstract contract Shape {
      // 未实现的函数，必须在子类中实现
      function area() public virtual view returns (uint256);
      
      // 已实现的函数
      function getName() public pure returns (string memory) {
          return "Shape";
      }
  }
  ```

### 4.2 抽象合约的使用
- 作为父合约被继承
- 子类必须实现所有未实现的函数
- 示例：
  ```solidity
  abstract contract Shape {
      function area() public virtual view returns (uint256);
      function perimeter() public virtual view returns (uint256);
  }
  
  contract Rectangle is Shape {
      uint256 public width;
      uint256 public height;
      
      constructor(uint256 _width, uint256 _height) {
          width = _width;
          height = _height;
      }
      
      // 实现抽象合约的函数
      function area() public override view returns (uint256) {
          return width * height;
      }
      
      // 实现抽象合约的函数
      function perimeter() public override view returns (uint256) {
          return 2 * (width + height);
      }
  }
  
  contract Circle is Shape {
      uint256 public radius;
      
      constructor(uint256 _radius) {
          radius = _radius;
      }
      
      // 实现抽象合约的函数
      function area() public override view returns (uint256) {
          return 3141592653589793238 * radius * radius / 1000000000000000000;
      }
      
      // 实现抽象合约的函数
      function perimeter() public override view returns (uint256) {
          return 2 * 3141592653589793238 * radius / 1000000000000000000;
      }
  }
  ```

## 五、接口

### 5.1 接口定义
- 只包含函数声明，不包含实现
- 使用`interface`关键字
- 所有函数默认为`external`
- 不能包含状态变量
- 不能包含构造函数
- 示例：
  ```solidity
  interface IERC20 {
      function totalSupply() external view returns (uint256);
      function balanceOf(address account) external view returns (uint256);
      function transfer(address to, uint256 amount) external returns (bool);
      function allowance(address owner, address spender) external view returns (uint256);
      function approve(address spender, uint256 amount) external returns (bool);
      function transferFrom(address from, address to, uint256 amount) external returns (bool);
      
      event Transfer(address indexed from, address indexed to, uint256 value);
      event Approval(address indexed owner, address indexed spender, uint256 value);
  }
  ```

### 5.2 接口的使用
- 用于定义合约间的交互协议
- 用于调用外部合约
- 用于实现多态
- 示例：
  ```solidity
  interface IERC20 {
      function transfer(address to, uint256 value) external returns (bool);
      function balanceOf(address account) external view returns (uint256);
  }
  
  contract TokenHolder {
      // 可以接受任何实现了IERC20接口的代币
      function transferToken(IERC20 token, address to, uint256 amount) public returns (bool) {
          return token.transfer(to, amount);
      }
      
      function getBalance(IERC20 token, address account) public view returns (uint256) {
          return token.balanceOf(account);
      }
  }
  ```

### 5.3 接口与抽象合约的区别
| 特性 | 接口 | 抽象合约 |
|------|------|----------|
| 关键字 | `interface` | `abstract` |
| 函数实现 | 不允许 | 允许部分实现 |
| 状态变量 | 不允许 | 允许 |
| 构造函数 | 不允许 | 允许 |
| 函数可见性 | 默认为`external` | 可以是任何可见性 |
| 继承 | 可以被继承 | 可以被继承 |
| 部署 | 不能直接部署 | 不能直接部署 |

## 六、多态

### 6.1 多态定义
- 允许不同类型的对象对同一消息做出不同响应
- 基于继承和接口实现
- 示例：
  ```solidity
  abstract contract Animal {
      function makeSound() public virtual view returns (string memory);
  }
  
  contract Dog is Animal {
      function makeSound() public override view returns (string memory) {
          return "Woof!";
      }
  }
  
  contract Cat is Animal {
      function makeSound() public override view returns (string memory) {
          return "Meow!";
      }
  }
  
  contract Zoo {
      // 多态：接受任何Animal类型的合约
      function hearAnimalSound(Animal animal) public view returns (string memory) {
          return animal.makeSound();
      }
  }
  ```

### 6.2 多态的优势
- **代码灵活性**：可以处理不同类型的合约
- **可扩展性**：便于添加新的合约类型
- **统一接口**：使用统一的方式处理不同合约
- **简化代码**：减少条件判断

### 6.3 多态的应用场景
- **代币标准**：如ERC20、ERC721等
- **插件系统**：允许动态添加功能
- **策略模式**：允许切换不同的算法
- **工厂模式**：创建不同类型的合约

## 七、实践项目：动物收容所

### 7.1 项目概述
- 实现一个动物收容所合约
- 支持不同类型动物的管理
- 使用继承和多态实现
- 包含抽象合约和接口

### 7.2 合约代码
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 接口：可领养的
interface IAdoptable {
    function adopt() external returns (bool);
    function isAdopted() external view returns (bool);
    function getAdopter() external view returns (address);
}

// 抽象合约：动物
abstract contract Animal {
    string public name;
    uint256 public age;
    string public breed;
    bool public isAdopted;
    address public adopter;
    
    event AnimalAdopted(address indexed adopter, string name, string breed);
    
    constructor(string memory _name, uint256 _age, string memory _breed) {
        name = _name;
        age = _age;
        breed = _breed;
        isAdopted = false;
    }
    
    // 抽象函数：发出声音
    function makeSound() public virtual view returns (string memory);
    
    // 抽象函数：获取动物类型
    function getType() public virtual pure returns (string memory);
    
    // 实现IAdoptable接口
    function adopt() public virtual returns (bool) {
        require(!isAdopted, "Already adopted");
        isAdopted = true;
        adopter = msg.sender;
        emit AnimalAdopted(msg.sender, name, breed);
        return true;
    }
    
    function isAdopted() public view returns (bool) {
        return isAdopted;
    }
    
    function getAdopter() public view returns (address) {
        return adopter;
    }
}

// 具体合约：狗
contract Dog is Animal, IAdoptable {
    constructor(string memory _name, uint256 _age, string memory _breed) Animal(_name, _age, _breed) {
        // 初始化
    }
    
    function makeSound() public override view returns (string memory) {
        return "Woof!";
    }
    
    function getType() public override pure returns (string memory) {
        return "Dog";
    }
    
    // 狗特有的方法
    function fetch() public pure returns (string memory) {
        return "Fetching the ball!";
    }
}

// 具体合约：猫
contract Cat is Animal, IAdoptable {
    constructor(string memory _name, uint256 _age, string memory _breed) Animal(_name, _age, _breed) {
        // 初始化
    }
    
    function makeSound() public override view returns (string memory) {
        return "Meow!";
    }
    
    function getType() public override pure returns (string memory) {
        return "Cat";
    }
    
    // 猫特有的方法
    function purr() public pure returns (string memory) {
        return "Purring...";
    }
}

// 动物收容所合约
contract AnimalShelter {
    // 状态变量
    address public owner;
    Animal[] public animals;
    mapping(address => Animal[]) public adoptedAnimals;
    
    // 事件
    event AnimalAdded(address indexed addedBy, string name, string animalType);
    event AnimalAdopted(address indexed adopter, string name, string animalType);
    
    // 构造函数
    constructor() {
        owner = msg.sender;
    }
    
    // 修饰符
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    // 添加狗
    function addDog(string memory _name, uint256 _age, string memory _breed) public onlyOwner {
        Animal newDog = new Dog(_name, _age, _breed);
        animals.push(newDog);
        emit AnimalAdded(msg.sender, _name, "Dog");
    }
    
    // 添加猫
    function addCat(string memory _name, uint256 _age, string memory _breed) public onlyOwner {
        Animal newCat = new Cat(_name, _age, _breed);
        animals.push(newCat);
        emit AnimalAdded(msg.sender, _name, "Cat");
    }
    
    // 领养动物（多态调用）
    function adoptAnimal(uint256 _animalIndex) public returns (bool) {
        require(_animalIndex < animals.length, "Invalid animal index");
        Animal animal = animals[_animalIndex];
        
        bool success = animal.adopt();
        if (success) {
            adoptedAnimals[msg.sender].push(animal);
            emit AnimalAdopted(msg.sender, animal.name(), animal.getType());
        }
        
        return success;
    }
    
    // 让动物发出声音（多态调用）
    function hearAnimalSound(uint256 _animalIndex) public view returns (string memory) {
        require(_animalIndex < animals.length, "Invalid animal index");
        Animal animal = animals[_animalIndex];
        return animal.makeSound();
    }
    
    // 获取动物信息
    function getAnimalInfo(uint256 _animalIndex) public view returns (
        string memory name,
        string memory animalType,
        string memory breed,
        uint256 age,
        bool isAdopted,
        address adopter
    ) {
        require(_animalIndex < animals.length, "Invalid animal index");
        Animal animal = animals[_animalIndex];
        return (
            animal.name(),
            animal.getType(),
            animal.breed(),
            animal.age(),
            animal.isAdopted(),
            animal.getAdopter()
        );
    }
    
    // 获取收容所中的动物数量
    function getAnimalCount() public view returns (uint256) {
        return animals.length;
    }
    
    // 获取用户领养的动物数量
    function getAdoptedAnimalCount(address _user) public view returns (uint256) {
        return adoptedAnimals[_user].length;
    }
}
```

### 7.3 部署和测试
1. 在Remix中编译所有合约
2. 部署AnimalShelter合约
3. 测试添加动物：
   - 调用`addDog`函数添加狗
   - 调用`addCat`函数添加猫
4. 测试多态功能：
   - 调用`hearAnimalSound`函数，验证不同动物发出不同声音
   - 调用`getAnimalInfo`函数，获取动物信息
5. 测试领养功能：
   - 调用`adoptAnimal`函数领养动物
   - 验证动物状态变为已领养
   - 检查领养记录

## 七、练习

1. 实现一个基于继承的ERC20代币合约，包含基本功能和扩展功能
2. 编写一个多继承合约，处理函数冲突
3. 实现一个抽象合约，定义支付接口，然后创建具体实现
4. 设计一个插件系统，使用接口和多态支持动态功能扩展
5. 实现一个工厂合约，使用多态创建不同类型的合约实例

## 八、总结

通过本章的学习，你已经掌握了Solidity中的继承和多态特性，包括：

- 单继承：一个子合约继承一个父合约
- 多继承：一个子合约继承多个父合约
- 抽象合约：包含未实现函数的合约
- 接口：只包含函数声明的合约
- 多态：不同类型合约的统一处理

继承和多态是面向对象编程的核心概念，它们可以帮助你编写更加模块化、可复用和可扩展的智能合约。在实际开发中，合理使用继承和多态可以提高代码质量和开发效率，同时降低维护成本。