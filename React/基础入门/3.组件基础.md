# 组件基础

## 一、组件的定义与分类

### 1.1 什么是组件

组件是React应用的基本构建块，它将UI拆分为独立、可复用的部分。每个组件都有自己的逻辑和外观，可以接收输入（props）并返回React元素，描述在屏幕上应该显示什么。

### 1.2 组件的分类

React组件主要分为两类：

#### 1.2.1 函数组件

函数组件是使用JavaScript函数定义的组件，它接收props作为参数并返回React元素。函数组件是React 16.8引入Hooks后推荐的组件编写方式。

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### 1.2.2 类组件

类组件是使用ES6类定义的组件，它继承自`React.Component`，并实现了`render()`方法来返回React元素。虽然函数组件现在更常用，但类组件在一些旧项目中仍然存在。

```jsx
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

#### 1.2.3 其他类型组件

- **纯组件**：继承自`React.PureComponent`，实现了浅比较的`shouldComponentUpdate`方法
- **高阶组件**：接收一个组件并返回一个新组件的函数
- **受控组件**：由React状态控制的表单组件
- **非受控组件**：由DOM自身控制的表单组件
- **React Server Components**：在服务器端渲染的组件

## 二、函数组件

### 2.1 创建函数组件

函数组件是React中最基本的组件类型，它是一个接收props并返回React元素的JavaScript函数。

```jsx
// 基本函数组件
function Welcome() {
  return <h1>Welcome to React!</h1>;
}

// 使用箭头函数
const Welcome = () => {
  return <h1>Welcome to React!</h1>;
};

// 接收props
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

// 解构props
function Greeting({ name, age }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
    </div>
  );
}
```

### 2.2 渲染函数组件

要渲染函数组件，只需将其作为JSX元素使用即可。

```jsx
function Welcome() {
  return <h1>Welcome to React!</h1>;
}

function App() {
  return (
    <div>
      <Welcome />
      <Welcome />
    </div>
  );
}
```

### 2.3 使用Hooks

React 16.8引入了Hooks，允许函数组件使用状态和其他React特性。

```jsx
import { useState } from 'react';

function Counter() {
  // 声明一个状态变量count，初始值为0
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

## 三、类组件

### 3.1 创建类组件

类组件是使用ES6类定义的组件，它继承自`React.Component`。

```jsx
import React from 'react';

class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

### 3.2 构造函数和状态

类组件可以在构造函数中初始化状态。

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    // 初始化状态
    this.state = {
      count: 0
    };
    // 绑定事件处理函数
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // 更新状态
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={this.handleClick}>
          Click me
        </button>
      </div>
    );
  }
}
```

### 3.3 生命周期方法

类组件有一系列生命周期方法，可以在组件的不同阶段执行代码。

```jsx
class LifecycleDemo extends React.Component {
  // 组件挂载前
  componentDidMount() {
    console.log('Component did mount');
  }

  // 组件更新前
  componentDidUpdate(prevProps, prevState) {
    console.log('Component did update');
  }

  // 组件卸载前
  componentWillUnmount() {
    console.log('Component will unmount');
  }

  render() {
    return <div>Lifecycle Demo</div>;
  }
}
```

## 四、Props

### 4.1 什么是Props

Props（Properties）是组件之间传递数据的方式，它是只读的，组件不能修改自己的props。

### 4.2 传递Props

```jsx
function Greeting({ name, age }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      {/* 传递字符串、数字等基本类型 */}
      <Greeting name="John" age={30} />
      
      {/* 传递变量 */}
      <Greeting name={user.name} age={user.age} />
      
      {/* 传递表达式 */}
      <Greeting name={user.firstName + ' ' + user.lastName} age={2024 - user.birthYear} />
      
      {/* 传递布尔值 */}
      <Greeting name="John" age={30} isAdmin={true} />
      
      {/* 传递数组 */}
      <Greeting name="John" hobbies={['reading', 'coding', 'gaming']} />
      
      {/* 传递对象 */}
      <Greeting name="John" address={{ city: 'New York', country: 'USA' }} />
      
      {/* 传递函数 */}
      <Greeting name="John" onGreet={() => console.log('Hello!')} />
    </div>
  );
}
```

### 4.3 默认Props

可以为组件设置默认Props，当没有传递该Prop时使用默认值。

```jsx
// 函数组件 - 使用默认参数
function Greeting({ name = 'Guest', age = 0 }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
    </div>
  );
}

// 函数组件 - 使用defaultProps属性
function Greeting({ name, age }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
    </div>
  );
}

Greeting.defaultProps = {
  name: 'Guest',
  age: 0
};

// 类组件 - 使用defaultProps属性
class Greeting extends React.Component {
  render() {
    const { name, age } = this.props;
    return (
      <div>
        <h1>Hello, {name}!</h1>
        <p>Age: {age}</p>
      </div>
    );
  }
}

Greeting.defaultProps = {
  name: 'Guest',
  age: 0
};
```

### 4.4 Props类型检查

可以使用TypeScript或PropTypes来进行Props类型检查。

#### 4.4.1 使用PropTypes

```jsx
import PropTypes from 'prop-types';

function Greeting({ name, age, hobbies }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
      <p>Hobbies: {hobbies.join(', ')}</p>
    </div>
  );
}

Greeting.propTypes = {
  // 必填字符串
  name: PropTypes.string.isRequired,
  // 可选数字
  age: PropTypes.number,
  // 可选数组
  hobbies: PropTypes.arrayOf(PropTypes.string),
  // 可选对象
  address: PropTypes.shape({
    city: PropTypes.string,
    country: PropTypes.string
  }),
  // 可选函数
  onGreet: PropTypes.func,
  // 可选布尔值
  isAdmin: PropTypes.bool
};
```

#### 4.4.2 使用TypeScript

```tsx
interface GreetingProps {
  // 必填字符串
  name: string;
  // 可选数字
  age?: number;
  // 可选数组
  hobbies?: string[];
  // 可选对象
  address?: {
    city: string;
    country: string;
  };
  // 可选函数
  onGreet?: () => void;
  // 可选布尔值
  isAdmin?: boolean;
}

function Greeting({ name, age = 0, hobbies = [] }: GreetingProps) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
      <p>Hobbies: {hobbies.join(', ')}</p>
    </div>
  );
}
```

## 五、状态管理

### 5.1 什么是状态

状态（State）是组件内部管理的数据，当状态发生变化时，组件会重新渲染。

### 5.2 useState Hook

`useState`是React提供的一个Hook，用于在函数组件中添加状态。

```jsx
import { useState } from 'react';

function Counter() {
  // 声明一个状态变量count，初始值为0
  // setCount是更新count的函数
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

### 5.3 状态更新

#### 5.3.1 更新基本类型

```jsx
const [count, setCount] = useState(0);
const [name, setName] = useState('');
const [isActive, setIsActive] = useState(false);

// 更新数字
setCount(count + 1);
setCount(prevCount => prevCount + 1); // 函数式更新

// 更新字符串
setName('John');
setName(prevName => prevName + ' Doe');

// 更新布尔值
setIsActive(!isActive);
setIsActive(prevIsActive => !prevIsActive);
```

#### 5.3.2 更新对象

更新对象时，需要创建一个新的对象，而不是直接修改原对象。

```jsx
const [user, setUser] = useState({
  name: 'John',
  age: 30
});

// 错误：直接修改状态
// user.age = 31;

// 正确：创建新对象
setUser({
  ...user,
  age: 31
});

// 函数式更新
setUser(prevUser => ({
  ...prevUser,
  age: prevUser.age + 1
}));
```

#### 5.3.3 更新数组

更新数组时，需要创建一个新的数组，而不是直接修改原数组。

```jsx
const [todos, setTodos] = useState([
  { id: 1, text: 'Learn React', completed: false },
  { id: 2, text: 'Build an app', completed: false }
]);

// 添加元素
setTodos([...todos, { id: 3, text: 'Deploy to production', completed: false }]);

// 删除元素
setTodos(todos.filter(todo => todo.id !== 2));

// 更新元素
setTodos(todos.map(todo => 
  todo.id === 1 ? { ...todo, completed: true } : todo
));

// 函数式更新
setTodos(prevTodos => [...prevTodos, { id: 3, text: 'New todo', completed: false }]);
```

### 5.4 状态的不可变性

React依赖于状态的不可变性来检测变化并重新渲染组件。直接修改状态会导致React无法检测到变化，从而导致组件不重新渲染。

```jsx
// 错误：直接修改状态
const [user, setUser] = useState({ name: 'John', age: 30 });
user.age = 31; // 直接修改，React无法检测到变化
setUser(user); // 不会重新渲染

// 正确：创建新对象
setUser({
  ...user,
  age: 31
}); // 会重新渲染
```

## 六、组件生命周期

### 6.1 函数组件生命周期

函数组件使用Hooks来模拟生命周期行为。

#### 6.1.1 挂载阶段

```jsx
import { useEffect } from 'react';

function Component() {
  // 组件挂载时执行一次
  useEffect(() => {
    console.log('Component mounted');
    
    // 可以在这里执行副作用，如API请求、事件监听等
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 1000);
    
    // 清理函数，组件卸载时执行
    return () => {
      console.log('Component unmounted');
      clearInterval(timer); // 清理副作用
    };
  }, []); // 空依赖数组，只在挂载和卸载时执行

  return <div>Component</div>;
}
```

#### 6.1.2 更新阶段

```jsx
import { useEffect, useState } from 'react';

function Component({ prop }) {
  const [state, setState] = useState(0);
  
  // 组件挂载和更新时执行
  useEffect(() => {
    console.log('Component updated');
    console.log('prop:', prop);
    console.log('state:', state);
  }); // 没有依赖数组，每次渲染后执行
  
  // 组件挂载和prop变化时执行
  useEffect(() => {
    console.log('prop changed:', prop);
  }, [prop]); // 依赖prop，当prop变化时执行
  
  // 组件挂载和state变化时执行
  useEffect(() => {
    console.log('state changed:', state);
  }, [state]); // 依赖state，当state变化时执行
  
  // 组件挂载和prop或state变化时执行
  useEffect(() => {
    console.log('prop or state changed');
  }, [prop, state]); // 依赖多个值

  return (
    <div>
      <p>prop: {prop}</p>
      <p>state: {state}</p>
      <button onClick={() => setState(state + 1)}>Increment</button>
    </div>
  );
}
```

### 6.2 类组件生命周期

类组件有一系列生命周期方法，用于在组件的不同阶段执行代码。

#### 6.2.1 挂载阶段

1. `constructor()` - 组件实例化时调用
2. `static getDerivedStateFromProps()` - 在渲染前调用，用于根据props更新state
3. `render()` - 渲染组件
4. `componentDidMount()` - 组件挂载到DOM后调用

#### 6.2.2 更新阶段

1. `static getDerivedStateFromProps()` - 在渲染前调用
2. `shouldComponentUpdate()` - 决定是否重新渲染组件
3. `render()` - 渲染组件
4. `getSnapshotBeforeUpdate()` - 在DOM更新前调用，用于获取DOM状态
5. `componentDidUpdate()` - 组件更新后调用

#### 6.2.3 卸载阶段

1. `componentWillUnmount()` - 组件卸载前调用，用于清理副作用

#### 6.2.4 错误处理

1. `static getDerivedStateFromError()` - 捕获子组件错误并更新state
2. `componentDidCatch()` - 捕获子组件错误并执行副作用

## 七、组件的组合和复用

### 7.1 组件组合

组件组合是React中实现代码复用的主要方式，它允许你将组件嵌套在一起，形成更复杂的组件。

```jsx
// 基础组件
function Button({ children, onClick }) {
  return (
    <button onClick={onClick} className="btn">
      {children}
    </button>
  );
}

// 组合组件
function Card({ title, children }) {
  return (
    <div className="card">
      <div className="card-header">
        <h2>{title}</h2>
      </div>
      <div className="card-body">
        {children}
      </div>
    </div>
  );
}

// 使用组合组件
function App() {
  return (
    <Card title="Welcome">
      <p>Hello, React!</p>
      <Button onClick={() => console.log('Clicked!')}>
        Click me
      </Button>
    </Card>
  );
}
```

### 7.2 组件复用

#### 7.2.1 通过props复用

```jsx
function Button({ variant = 'primary', children, onClick }) {
  return (
    <button 
      onClick={onClick} 
      className={`btn btn-${variant}`}
    >
      {children}
    </button>
  );
}

function App() {
  return (
    <div>
      <Button variant="primary">Primary Button</Button>
      <Button variant="secondary">Secondary Button</Button>
      <Button variant="success">Success Button</Button>
      <Button variant="danger">Danger Button</Button>
    </div>
  );
}
```

#### 7.2.2 通过自定义Hooks复用逻辑

```jsx
import { useState, useEffect } from 'react';

// 自定义Hook，用于获取窗口大小
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    function handleResize() {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}

// 在组件中使用自定义Hook
function Component() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>Window width: {width}</p>
      <p>Window height: {height}</p>
    </div>
  );
}
```

## 八、常见问题与解决方案

### 8.1 组件不重新渲染

- 检查是否直接修改了状态，而不是使用setter函数
- 检查setter函数是否传递了新的引用（对于对象和数组）
- 检查是否有条件渲染阻止了组件的显示
- 检查组件是否被React.memo包裹，且props没有变化

### 8.2 无限循环

- 检查useEffect的依赖数组，确保没有包含每次渲染都会变化的值
- 检查是否在useEffect中更新了依赖项
- 检查是否在渲染过程中调用了setter函数

### 8.3 Props不更新

- 检查父组件是否正确传递了props
- 检查props是否被正确解构
- 检查是否使用了默认props，导致传递的props被覆盖

### 8.4 状态更新延迟

- 检查是否使用了函数式更新，特别是当新状态依赖于旧状态时
- 检查是否在事件处理函数中多次调用了setter函数，React会批量更新

### 8.5 组件挂载时执行多次

- 检查是否在开发模式下，React会执行两次渲染以检测副作用
- 检查是否使用了React.StrictMode，它会导致某些函数执行两次

## 九、总结

本章节我们学习了：

1. 组件的定义和分类（函数组件和类组件）
2. 如何创建和渲染函数组件
3. 如何创建和渲染类组件
4. Props的传递和使用
5. 默认Props和Props类型检查
6. 状态管理（useState Hook）
7. 状态更新的正确方式和不可变性原则
8. 组件生命周期（函数组件和类组件）
9. 组件的组合和复用
10. 常见问题与解决方案

组件是React开发的核心，掌握好组件的创建、props传递、状态管理和生命周期对于学习React至关重要。通过不断练习和实践，你将能够熟练地使用组件构建复杂的React应用。

## 十、练习

1. 创建一个简单的函数组件，显示用户信息
2. 创建一个类组件，实现计数器功能
3. 实现一个可复用的Button组件，支持不同的变体（primary、secondary、success、danger）
4. 实现一个Card组件，支持自定义标题和内容
5. 使用useState Hook实现一个表单，支持输入和提交
6. 使用useEffect Hook实现一个时钟组件，显示当前时间
7. 实现一个TodoList组件，支持添加、删除和标记完成功能
8. 创建一个自定义Hook，用于获取API数据

---

**下一章预告**：事件处理

在接下来的章节中，我们将深入学习React中的事件处理，包括事件绑定、事件对象、事件冒泡等内容。