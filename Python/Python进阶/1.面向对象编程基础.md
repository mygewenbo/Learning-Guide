# 面向对象编程基础

## 一、面向对象编程概述

### 1.1 什么是面向对象编程

面向对象编程（Object-Oriented Programming，简称OOP）是一种编程范式，它将现实世界中的事物抽象为程序中的对象，通过对象之间的交互来实现功能。

在面向对象编程中，我们关注的是**对象**和**对象之间的关系**，而不是具体的实现步骤。这种编程方式更加符合人类的思维方式，使得代码更加易于理解、维护和扩展。

### 1.2 面向对象编程的核心概念

- **对象（Object）**：现实世界中具体的事物，具有属性和行为
- **类（Class）**：对象的抽象模板，定义了对象的属性和行为
- **属性（Attribute）**：对象的特征，如颜色、大小、名称等
- **方法（Method）**：对象的行为，如吃饭、睡觉、工作等
- **封装（Encapsulation）**：将数据和操作数据的方法绑定在一起，隐藏内部实现细节
- **继承（Inheritance）**：子类继承父类的属性和方法，实现代码复用
- **多态（Polymorphism）**：不同对象对同一消息做出不同的响应

### 1.3 面向对象编程的优势

- **代码复用**：通过继承机制，可以复用已有的代码
- **模块化设计**：每个类都是一个独立的模块，便于维护和扩展
- **提高代码可读性**：类的设计更加符合人类的思维方式
- **增强代码可维护性**：修改一个类不会影响其他类，降低了耦合度
- **支持大型项目开发**：适合团队协作开发大型复杂项目

## 二、类与对象

### 2.1 类的定义

在Python中，使用`class`关键字来定义类。类的命名通常使用驼峰命名法（首字母大写）。

```python
# 定义一个简单的类
class Person:
    pass
```

### 2.2 对象的创建

类是对象的模板，通过类可以创建多个对象。创建对象的过程称为**实例化**。

```python
# 创建Person类的对象
person1 = Person()
person2 = Person()

print(person1)  # 输出：<__main__.Person object at 0x0000012345678900>
print(person2)  # 输出：<__main__.Person object at 0x0000012345678910>
```

### 2.3 类的属性

类的属性分为**类属性**和**实例属性**。

#### 2.3.1 类属性

类属性是属于类的属性，所有对象共享同一个类属性。

```python
class Person:
    # 类属性
    species = "人类"

# 创建对象
person1 = Person()
person2 = Person()

# 访问类属性
print(Person.species)  # 输出：人类
print(person1.species)  # 输出：人类
print(person2.species)  # 输出：人类

# 修改类属性
Person.species = "智人"
print(person1.species)  # 输出：智人
print(person2.species)  # 输出：智人
```

#### 2.3.2 实例属性

实例属性是属于对象的属性，每个对象都有自己独立的实例属性。

```python
class Person:
    def __init__(self, name, age):
        # 实例属性
        self.name = name
        self.age = age

# 创建对象
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

# 访问实例属性
print(person1.name)  # 输出：Alice
print(person1.age)   # 输出：25
print(person2.name)  # 输出：Bob
print(person2.age)   # 输出：30

# 修改实例属性
person1.age = 26
print(person1.age)   # 输出：26
print(person2.age)   # 输出：30（不受影响）
```

### 2.4 类的方法

类的方法是定义在类中的函数，用于描述对象的行为。

#### 2.4.1 实例方法

实例方法是最常用的方法类型，它的第一个参数必须是`self`，表示调用该方法的对象。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # 实例方法
    def say_hello(self):
        print(f"Hello, my name is {self.name}, I'm {self.age} years old.")

# 创建对象
person = Person("Alice", 25)

# 调用实例方法
person.say_hello()  # 输出：Hello, my name is Alice, I'm 25 years old.
```

#### 2.4.2 类方法

类方法使用`@classmethod`装饰器修饰，它的第一个参数必须是`cls`，表示调用该方法的类。

```python
class Person:
    species = "人类"
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # 类方法
    @classmethod
    def change_species(cls, new_species):
        cls.species = new_species

# 调用类方法
Person.change_species("智人")
print(Person.species)  # 输出：智人

# 通过对象调用类方法
person = Person("Alice", 25)
person.change_species("现代人")
print(Person.species)  # 输出：现代人
```

#### 2.4.3 静态方法

静态方法使用`@staticmethod`装饰器修饰，它不需要`self`或`cls`参数，与类和对象的状态无关。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # 静态方法
    @staticmethod
    def is_adult(age):
        return age >= 18

# 调用静态方法
print(Person.is_adult(25))  # 输出：True
print(Person.is_adult(17))  # 输出：False

# 通过对象调用静态方法
person = Person("Alice", 25)
print(person.is_adult(20))  # 输出：True
```

## 三、构造函数与析构函数

### 3.1 构造函数

构造函数是一种特殊的方法，用于在创建对象时初始化对象的属性。在Python中，构造函数的名称固定为`__init__`。

```python
class Person:
    def __init__(self, name, age, gender):
        # 初始化实例属性
        self.name = name
        self.age = age
        self.gender = gender
    
    def introduce(self):
        print(f"我叫{self.name}，今年{self.age}岁，是{self.gender}生。")

# 创建对象时自动调用构造函数
person = Person("Alice", 25, "女")
person.introduce()  # 输出：我叫Alice，今年25岁，是女生。
```

### 3.2 析构函数

析构函数是一种特殊的方法，用于在对象被销毁时执行清理操作。在Python中，析构函数的名称固定为`__del__`。

```python
class Person:
    def __init__(self, name):
        self.name = name
        print(f"{self.name}被创建了")
    
    def __del__(self):
        print(f"{self.name}被销毁了")

# 创建对象
person1 = Person("Alice")  # 输出：Alice被创建了
person2 = Person("Bob")    # 输出：Bob被创建了

# 删除对象
del person1  # 输出：Alice被销毁了

# 程序结束时，剩余对象会被自动销毁
# 输出：Bob被销毁了
```

> **注意**：在Python中，对象的销毁时间是不确定的，因为Python使用垃圾回收机制来管理内存。析构函数的调用时机取决于垃圾回收器的运行时间。

## 四、访问控制

### 4.1 公有属性和方法

在Python中，默认情况下，类的属性和方法都是公有的（public），可以在类的内部和外部访问。

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # 公有属性
        self.age = age    # 公有属性
    
    def say_hello(self):  # 公有方法
        print(f"Hello, my name is {self.name}.")

# 创建对象
person = Person("Alice", 25)

# 访问公有属性
print(person.name)  # 输出：Alice
print(person.age)   # 输出：25

# 修改公有属性
person.age = 26
print(person.age)   # 输出：26

# 调用公有方法
person.say_hello()  # 输出：Hello, my name is Alice.
```

### 4.2 私有属性和方法

在Python中，使用双下划线`__`前缀来定义私有属性和方法。私有属性和方法只能在类的内部访问，不能在类的外部直接访问。

```python
class Person:
    def __init__(self, name, age, salary):
        self.name = name        # 公有属性
        self.__age = age        # 私有属性
        self.__salary = salary  # 私有属性
    
    def say_hello(self):        # 公有方法
        print(f"Hello, my name is {self.name}.")
        self.__print_salary()   # 在类内部可以调用私有方法
    
    def __print_salary(self):   # 私有方法
        print(f"My salary is {self.__salary}.")

# 创建对象
person = Person("Alice", 25, 5000)

# 访问公有属性
print(person.name)  # 输出：Alice

# 尝试访问私有属性（会报错）
# print(person.__age)  # AttributeError: 'Person' object has no attribute '__age'
# print(person.__salary)  # AttributeError: 'Person' object has no attribute '__salary'

# 调用公有方法
person.say_hello()  # 输出：Hello, my name is Alice.
                    # 输出：My salary is 5000.

# 尝试调用私有方法（会报错）
# person.__print_salary()  # AttributeError: 'Person' object has no attribute '__print_salary'
```

### 4.3 名称修饰

Python中的私有属性和方法并不是真正的私有，而是通过**名称修饰**（name mangling）机制实现的。Python会将私有属性和方法的名称修改为`_类名__属性名`或`_类名__方法名`的形式。

```python
class Person:
    def __init__(self, name, age):
        self.__name = name  # 私有属性
        self.__age = age    # 私有属性

# 创建对象
person = Person("Alice", 25)

# 通过名称修饰访问私有属性
print(person._Person__name)  # 输出：Alice
print(person._Person__age)   # 输出：25

# 修改私有属性
person._Person__age = 26
print(person._Person__age)   # 输出：26
```

> **注意**：不建议在类的外部通过名称修饰来访问私有属性和方法，这违反了封装的原则。

### 4.4 受保护属性

在Python中，使用单下划线`_`前缀来定义受保护属性（protected）。受保护属性可以在类的内部和子类中访问，但不建议在类的外部直接访问。

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # 公有属性
        self._age = age   # 受保护属性

# 创建对象
person = Person("Alice", 25)

# 访问受保护属性（不建议）
print(person._age)  # 输出：25
```

## 五、属性装饰器

### 5.1 @property装饰器

`@property`装饰器用于将一个方法转换为属性，可以像访问属性一样调用方法，而不需要括号。

```python
class Person:
    def __init__(self, name, height, weight):
        self.name = name
        self.height = height  # 身高（米）
        self.weight = weight  # 体重（千克）
    
    # 使用@property装饰器将方法转换为属性
    @property
    def bmi(self):
        """计算BMI指数"""
        return self.weight / (self.height ** 2)

# 创建对象
person = Person("Alice", 1.65, 55)

# 像访问属性一样调用bmi方法
print(person.bmi)  # 输出：20.202020202020204

# 尝试修改bmi属性（会报错）
# person.bmi = 22  # AttributeError: can't set attribute
```

### 5.2 @property.setter装饰器

`@property.setter`装饰器用于为属性设置器方法，允许修改通过`@property`装饰的属性。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = age  # 受保护属性
    
    @property
    def age(self):
        """获取年龄"""
        return self._age
    
    @age.setter
    def age(self, value):
        """设置年龄，进行合法性检查"""
        if value < 0:
            raise ValueError("年龄不能为负数")
        if value > 150:
            raise ValueError("年龄不能超过150岁")
        self._age = value

# 创建对象
person = Person("Alice", 25)

# 获取年龄
print(person.age)  # 输出：25

# 设置年龄
person.age = 26
print(person.age)  # 输出：26

# 尝试设置非法年龄（会报错）
# person.age = -5  # ValueError: 年龄不能为负数
# person.age = 200  # ValueError: 年龄不能超过150岁
```

### 5.3 @property.deleter装饰器

`@property.deleter`装饰器用于为属性删除器方法，允许删除通过`@property`装饰的属性。

```python
class Person:
    def __init__(self, name, email):
        self.name = name
        self._email = email
    
    @property
    def email(self):
        """获取邮箱"""
        return self._email
    
    @email.setter
    def email(self, value):
        """设置邮箱"""
        self._email = value
    
    @email.deleter
    def email(self):
        """删除邮箱"""
        print(f"删除{self.name}的邮箱")
        del self._email

# 创建对象
person = Person("Alice", "alice@example.com")

# 获取邮箱
print(person.email)  # 输出：alice@example.com

# 设置邮箱
person.email = "alice_new@example.com"
print(person.email)  # 输出：alice_new@example.com

# 删除邮箱
del person.email  # 输出：删除Alice的邮箱

# 尝试访问已删除的邮箱（会报错）
# print(person.email)  # AttributeError: 'Person' object has no attribute '_email'
```

## 六、类的继承

### 6.1 继承的基本概念

继承是面向对象编程的重要特性之一，它允许一个类（子类）继承另一个类（父类）的属性和方法，实现代码复用。

在Python中，使用`class 子类名(父类名):`的语法来定义继承关系。

```python
# 定义父类
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name}正在吃东西")
    
    def sleep(self):
        print(f"{self.name}正在睡觉")

# 定义子类，继承自Animal
class Dog(Animal):
    def bark(self):
        print(f"{self.name}正在汪汪叫")

# 创建子类对象
dog = Dog("旺财", 3)

# 访问继承的属性
print(dog.name)  # 输出：旺财
print(dog.age)   # 输出：3

# 调用继承的方法
dog.eat()   # 输出：旺财正在吃东西
dog.sleep()  # 输出：旺财正在睡觉

# 调用子类自己的方法
dog.bark()  # 输出：旺财正在汪汪叫
```

### 6.2 方法重写

子类可以重写父类的方法，实现自己的功能。

```python
# 定义父类
class Animal:
    def __init__(self, name):
        self.name = name
    
    def make_sound(self):
        print(f"{self.name}发出了声音")

# 定义子类，重写父类方法
class Dog(Animal):
    def make_sound(self):
        print(f"{self.name}汪汪叫")

# 定义另一个子类，重写父类方法
class Cat(Animal):
    def make_sound(self):
        print(f"{self.name}喵喵叫")

# 创建对象
dog = Dog("旺财")
cat = Cat("咪咪")

# 调用重写后的方法
dog.make_sound()  # 输出：旺财汪汪叫
cat.make_sound()  # 输出：咪咪喵喵叫
```

### 6.3 调用父类方法

在子类中，可以使用`super()`函数来调用父类的方法。

```python
# 定义父类
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name}正在吃东西")

# 定义子类
class Dog(Animal):
    def __init__(self, name, age, breed):
        # 调用父类的构造函数
        super().__init__(name, age)
        self.breed = breed  # 子类自己的属性
    
    def eat(self):
        # 调用父类的eat方法
        super().eat()
        print(f"{self.name}最喜欢吃骨头")

# 创建对象
dog = Dog("旺财", 3, "金毛")

# 访问属性
print(dog.name)   # 输出：旺财
print(dog.age)    # 输出：3
print(dog.breed)  # 输出：金毛

# 调用方法
dog.eat()  # 输出：旺财正在吃东西
           # 输出：旺财最喜欢吃骨头
```

### 6.4 多重继承

Python支持多重继承，一个子类可以继承多个父类。

```python
# 定义第一个父类
class Flyable:
    def fly(self):
        print("正在飞行")

# 定义第二个父类
class Swimmable:
    def swim(self):
        print("正在游泳")

# 定义子类，继承自两个父类
class Duck(Flyable, Swimmable):
    def quack(self):
        print("嘎嘎叫")

# 创建对象
duck = Duck()

# 调用继承的方法
duck.fly()   # 输出：正在飞行
duck.swim()  # 输出：正在游泳
duck.quack()  # 输出：嘎嘎叫
```

> **注意**：多重继承可能会导致**菱形继承问题**（钻石问题），即一个子类继承自两个父类，而这两个父类又继承自同一个祖父类。Python通过**C3线性化算法**来解决这个问题，确保方法调用的顺序是正确的。

## 七、多态

### 7.1 多态的基本概念

多态是指不同对象对同一消息做出不同的响应。在Python中，多态是通过**动态类型**和**方法重写**实现的。

```python
# 定义父类
class Animal:
    def __init__(self, name):
        self.name = name
    
    def make_sound(self):
        print(f"{self.name}发出了声音")

# 定义子类
class Dog(Animal):
    def make_sound(self):
        print(f"{self.name}汪汪叫")

class Cat(Animal):
    def make_sound(self):
        print(f"{self.name}喵喵叫")

class Bird(Animal):
    def make_sound(self):
        print(f"{self.name}叽叽喳喳叫")

# 定义一个函数，接收Animal类型的参数
def animal_sound(animal):
    animal.make_sound()

# 创建不同的动物对象
dog = Dog("旺财")
cat = Cat("咪咪")
bird = Bird("小鸟")

# 调用同一个函数，传入不同的对象
animal_sound(dog)   # 输出：旺财汪汪叫
animal_sound(cat)   # 输出：咪咪喵喵叫
animal_sound(bird)  # 输出：小鸟叽叽喳喳叫
```

### 7.2 多态的优势

- **提高代码的灵活性**：可以根据不同的对象类型执行不同的操作
- **提高代码的可扩展性**：添加新的子类不需要修改现有的代码
- **提高代码的可维护性**：将通用逻辑抽象到父类中，子类只需要实现自己的特殊逻辑

## 八、类的特殊方法

Python中有许多特殊方法（也称为魔术方法或双下划线方法），用于实现类的特殊功能。这些方法的名称以双下划线开头和结尾。

### 8.1 `__str__`方法

`__str__`方法用于返回对象的字符串表示，当使用`print()`函数或`str()`函数时会调用该方法。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"Person(name='{self.name}', age={self.age})"

# 创建对象
person = Person("Alice", 25)

# 调用print()函数，会自动调用__str__方法
print(person)  # 输出：Person(name='Alice', age=25)

# 调用str()函数，会自动调用__str__方法
print(str(person))  # 输出：Person(name='Alice', age=25)
```

### 8.2 `__repr__`方法

`__repr__`方法用于返回对象的官方字符串表示，当使用`repr()`函数或在交互式环境中直接输入对象名时会调用该方法。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

# 创建对象
person = Person("Alice", 25)

# 调用repr()函数，会自动调用__repr__方法
print(repr(person))  # 输出：Person(name='Alice', age=25)

# 在交互式环境中直接输入对象名，会自动调用__repr__方法
# >>> person
# Person(name='Alice', age=25)
```

### 8.3 算术运算符重载

Python允许重载算术运算符，通过实现相应的特殊方法来实现。

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    # 重载加法运算符
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    # 重载减法运算符
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)
    
    # 重载乘法运算符
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

# 创建向量对象
v1 = Vector(1, 2)
v2 = Vector(3, 4)

# 测试加法
v3 = v1 + v2
print(v3)  # 输出：Vector(4, 6)

# 测试减法
v4 = v2 - v1
print(v4)  # 输出：Vector(2, 2)

# 测试乘法
v5 = v1 * 3
print(v5)  # 输出：Vector(3, 6)
```

### 8.4 比较运算符重载

Python允许重载比较运算符，通过实现相应的特殊方法来实现。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # 重载等于运算符
    def __eq__(self, other):
        return self.age == other.age
    
    # 重载大于运算符
    def __gt__(self, other):
        return self.age > other.age
    
    # 重载小于运算符
    def __lt__(self, other):
        return self.age < other.age

# 创建对象
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)
person3 = Person("Charlie", 25)

# 测试等于运算符
print(person1 == person3)  # 输出：True
print(person1 == person2)  # 输出：False

# 测试大于运算符
print(person2 > person1)  # 输出：True
print(person1 > person2)  # 输出：False

# 测试小于运算符
print(person1 < person2)  # 输出：True
print(person2 < person1)  # 输出：False
```

## 九、类的组合

除了继承之外，类的组合也是实现代码复用的一种方式。组合是指一个类包含另一个类的对象作为其属性。

```python
# 定义发动机类
class Engine:
    def start(self):
        print("发动机启动")
    
    def stop(self):
        print("发动机关闭")

# 定义轮胎类
class Tire:
    def roll(self):
        print("轮胎滚动")

# 定义汽车类，包含发动机和轮胎对象
class Car:
    def __init__(self, brand):
        self.brand = brand
        self.engine = Engine()  # 组合发动机对象
        self.tires = [Tire() for _ in range(4)]  # 组合4个轮胎对象
    
    def drive(self):
        print(f"{self.brand}汽车开始行驶")
        self.engine.start()
        for tire in self.tires:
            tire.roll()
    
    def park(self):
        print(f"{self.brand}汽车停止行驶")
        self.engine.stop()

# 创建汽车对象
car = Car("特斯拉")

# 调用方法
car.drive()  # 输出：特斯拉汽车开始行驶
             # 输出：发动机启动
             # 输出：轮胎滚动
             # 输出：轮胎滚动
             # 输出：轮胎滚动
             # 输出：轮胎滚动

car.park()  # 输出：特斯拉汽车停止行驶
            # 输出：发动机关闭
```

> **继承 vs 组合**：
> - 继承表示"是一个"（is-a）关系，例如Dog是一个Animal
> - 组合表示"有一个"（has-a）关系，例如Car有一个Engine
> - 优先使用组合，而不是继承，因为组合更加灵活，耦合度更低

## 十、常见设计模式

### 10.1 单例模式

单例模式确保一个类只有一个实例，并提供一个全局访问点。

```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, name):
        self.name = name

# 创建对象
s1 = Singleton("实例1")
s2 = Singleton("实例2")

# 两个对象是同一个实例
print(s1 is s2)  # 输出：True
print(s1.name)   # 输出：实例2（因为s2覆盖了s1的name属性）
print(s2.name)   # 输出：实例2
```

### 10.2 工厂模式

工厂模式用于创建对象，隐藏对象创建的细节。

```python
# 定义产品类
class Dog:
    def speak(self):
        return "汪汪叫"

class Cat:
    def speak(self):
        return "喵喵叫"

# 定义工厂类
class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError("不支持的动物类型")

# 使用工厂创建对象
dog = AnimalFactory.create_animal("dog")
print(dog.speak())  # 输出：汪汪叫

cat = AnimalFactory.create_animal("cat")
print(cat.speak())  # 输出：喵喵叫
```

## 十一、总结

本章介绍了面向对象编程的基础知识，包括：

1. 面向对象编程的概述和核心概念
2. 类与对象的定义和使用
3. 构造函数与析构函数
4. 访问控制（公有、私有、受保护）
5. 属性装饰器（@property、@property.setter、@property.deleter）
6. 类的继承和方法重写
7. 多态的实现和应用
8. 类的特殊方法
9. 类的组合
10. 常见设计模式（单例模式、工厂模式）

通过本章的学习，你应该已经掌握了面向对象编程的基本概念和语法，可以开始设计和实现自己的类和对象了。面向对象编程是Python编程的重要组成部分，也是开发大型复杂项目的基础。

## 十二、练习

1. 定义一个`Circle`类，包含半径属性和计算面积、周长的方法。
2. 定义一个`Student`类，包含姓名、学号、成绩等属性，以及计算平均分、显示学生信息的方法。
3. 定义一个`BankAccount`类，包含账号、余额等属性，以及存款、取款、查询余额的方法，注意实现访问控制。
4. 定义一个`Shape`基类，包含计算面积和周长的方法，然后定义`Rectangle`和`Triangle`子类，重写这些方法。
5. 实现一个`Vector`类，支持向量的加法、减法、乘法（标量）和比较运算。
6. 使用单例模式实现一个日志类，确保只有一个日志实例。
7. 使用工厂模式实现一个图形工厂，能够创建不同类型的图形对象。
8. 设计一个`Computer`类，包含CPU、内存、硬盘等组件，使用组合的方式实现。

## 十三、参考资料

1. Python官方文档：https://docs.python.org/zh-cn/3/tutorial/classes.html
2. 《流畅的Python》（Luciano Ramalho）
3. 《Python Cookbook》（David Beazley）
4. 《Head First Python》（Paul Barry）
5. 《面向对象设计模式》（Erich Gamma等）