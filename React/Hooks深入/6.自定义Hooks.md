# 自定义Hooks详解

## 1. 什么是自定义Hooks？

自定义Hooks是React中一种特殊的函数，用于封装可复用的状态逻辑。它们遵循React Hooks的规则，可以调用其他Hooks，并且可以在多个组件之间共享逻辑。

### 核心特性
- 以 `use` 开头命名，遵循Hooks命名约定
- 可以调用其他Hooks（如useState、useEffect等）
- 用于封装可复用的状态逻辑
- 可以在多个组件之间共享
- 不影响组件的UI，只关注逻辑

## 2. 语法和基本使用

### 基本结构

```javascript
import { useState, useEffect } from 'react';

// 自定义Hook以use开头命名
function useCustomHook(initialValue) {
  // 可以调用其他Hooks
  const [state, setState] = useState(initialValue);
  
  useEffect(() => {
    // 副作用逻辑
  }, [dependencies]);
  
  // 返回需要共享的状态和方法
  return {
    state,
    setState,
    // 其他方法
  };
}

// 在组件中使用自定义Hook
function Component() {
  const { state, setState } = useCustomHook(initialValue);
  
  return <div>{state}</div>;
}
```

### 简单示例：计数器Hook

```javascript
import { useState } from 'react';

// 自定义计数器Hook
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const reset = () => setCount(initialValue);
  const incrementBy = (amount) => setCount(prev => prev + amount);
  
  return {
    count,
    increment,
    decrement,
    reset,
    incrementBy
  };
}

// 使用自定义Hook
function Component() {
  const { count, increment, decrement, reset, incrementBy } = useCounter(5);
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
      <button onClick={reset}>Reset</button>
      <button onClick={() => incrementBy(5)}>Increment by 5</button>
    </div>
  );
}
```

## 3. 常见用例

### 3.1 本地存储Hook

```javascript
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // 从localStorage获取初始值
  const getInitialValue = () => {
    try {
      const storedValue = localStorage.getItem(key);
      return storedValue ? JSON.parse(storedValue) : initialValue;
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return initialValue;
    }
  };
  
  const [value, setValue] = useState(getInitialValue);
  
  // 当value变化时，保存到localStorage
  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Error writing to localStorage:', error);
    }
  }, [key, value]);
  
  return [value, setValue];
}

// 使用示例
function Component() {
  const [username, setUsername] = useLocalStorage('username', '');
  
  return (
    <input
      value={username}
      onChange={(e) => setUsername(e.target.value)}
      placeholder="Username (saved to localStorage)"
    />
  );
}
```

### 3.2 数据获取Hook

```javascript
import { useState, useEffect } from 'react';

function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isMounted = true;
    
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        if (isMounted) {
          setData(result);
        }
      } catch (err) {
        if (isMounted) {
          setError(err.message);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    // 清理函数，防止内存泄漏
    return () => {
      isMounted = false;
    };
  }, [url, options]);
  
  return { data, loading, error };
}

// 使用示例
function Component() {
  const { data, loading, error } = useFetch('https://api.example.com/data');
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;
  
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

### 3.3 表单处理Hook

```javascript
import { useState } from 'react';

function useForm(initialValues, validate = () => {}) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({
      ...prev,
      [name]: value
    }));
    
    // 实时验证
    const newErrors = validate({ ...values, [name]: value });
    setErrors(prev => ({
      ...prev,
      [name]: newErrors[name]
    }));
  };
  
  const handleSubmit = (e, onSubmit) => {
    e.preventDefault();
    
    const validationErrors = validate(values);
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length === 0) {
      setIsSubmitting(true);
      onSubmit(values);
      setIsSubmitting(false);
    }
  };
  
  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
  };
  
  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
    resetForm
  };
}

// 使用示例
function LoginForm() {
  const validate = (values) => {
    const errors = {};
    if (!values.email) errors.email = 'Email is required';
    if (!values.password) errors.password = 'Password is required';
    return errors;
  };
  
  const { values, errors, handleChange, handleSubmit } = useForm(
    { email: '', password: '' },
    validate
  );
  
  const onSubmit = (values) => {
    console.log('Login submitted:', values);
  };
  
  return (
    <form onSubmit={(e) => handleSubmit(e, onSubmit)}>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={values.email}
          onChange={handleChange}
        />
        {errors.email && <span>{errors.email}</span>}
      </div>
      <div>
        <label>Password:</label>
        <input
          type="password"
          name="password"
          value={values.password}
          onChange={handleChange}
        />
        {errors.password && <span>{errors.password}</span>}
      </div>
      <button type="submit">Login</button>
    </form>
  );
}
```

### 3.4 窗口尺寸Hook

```javascript
import { useState, useEffect } from 'react';

function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return windowSize;
}

// 使用示例
function Component() {
  const { width, height } = useWindowSize();
  
  return (
    <div>
      <h2>Window Size</h2>
      <p>Width: {width}px</p>
      <p>Height: {height}px</p>
    </div>
  );
}
```

## 3. 最佳实践

### 3.1 命名约定

- 自定义Hook必须以 `use` 开头命名，以便React识别它是一个Hook
- 命名应清晰描述Hook的功能

```javascript
// ✅ 好的命名
function useCounter() {}
function useLocalStorage() {}
function useFetch() {}

// ❌ 不好的命名
function counterHook() {}
function localStore() {}
function getData() {}
```

### 3.2 单一职责原则

- 每个自定义Hook应只负责一个功能
- 避免创建过于复杂的Hook

```javascript
// ✅ 单一职责
function useCounter() {}
function useLocalStorage() {}

// ❌ 职责过多
function useEverything() {
  // 同时处理计数器、本地存储、数据获取等
}
```

### 3.3 提供合理的默认值

- 为Hook的参数提供合理的默认值
- 使Hook更加灵活易用

```javascript
// ✅ 提供默认值
function useCounter(initialValue = 0) {}
function useFetch(url, options = {}) {}

// ❌ 没有默认值
function useCounter(initialValue) {
  // 如果调用时不传递initialValue，会导致问题
}
```

### 3.4 处理清理逻辑

- 对于有副作用的Hook，确保提供清理逻辑
- 防止内存泄漏

```javascript
// ✅ 处理清理逻辑
function useEventListener(event, handler, element = window) {
  useEffect(() => {
    element.addEventListener(event, handler);
    
    return () => {
      element.removeEventListener(event, handler);
    };
  }, [event, handler, element]);
}

// ❌ 没有清理逻辑
function useEventListener(event, handler, element = window) {
  useEffect(() => {
    element.addEventListener(event, handler);
    // 没有清理函数，会导致内存泄漏
  }, [event, handler, element]);
}
```

### 3.5 类型安全

- 为Hook添加TypeScript类型定义
- 提高代码的可维护性和可靠性

```typescript
// TypeScript示例
function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  // 实现...
}

// 使用时会有类型提示
const [username, setUsername] = useLocalStorage<string>('username', '');
```

## 4. 与其他Hooks的配合使用

### 4.1 组合多个自定义Hooks

自定义Hooks可以相互组合，形成更复杂的逻辑：

```javascript
// 组合useLocalStorage和useFetch
function useFetchedDataWithCache(url, cacheKey) {
  const [cachedData, setCachedData] = useLocalStorage(cacheKey, null);
  const { data, loading, error } = useFetch(url);
  
  useEffect(() => {
    if (data) {
      setCachedData(data);
    }
  }, [data, setCachedData]);
  
  return {
    data: data || cachedData,
    loading,
    error
  };
}
```

### 4.2 在自定义Hook中使用内置Hooks

自定义Hook可以调用任何内置Hooks：

```javascript
function useCustomHook() {
  const [state, setState] = useState();
  const ref = useRef();
  const context = useContext(MyContext);
  
  useEffect(() => {
    // 副作用逻辑
  }, [dependencies]);
  
  const memoizedValue = useMemo(() => {
    // 计算逻辑
  }, [dependencies]);
  
  const memoizedCallback = useCallback(() => {
    // 回调逻辑
  }, [dependencies]);
  
  return {
    state,
    setState,
    memoizedValue,
    memoizedCallback
  };
}
```

## 5. 测试自定义Hooks

### 使用React Testing Library测试

```javascript
import { renderHook, act } from '@testing-library/react';
import useCounter from './useCounter';

test('initializes with correct value', () => {
  const { result } = renderHook(() => useCounter(5));
  expect(result.current.count).toBe(5);
});

test('increments count', () => {
  const { result } = renderHook(() => useCounter(0));
  
  act(() => {
    result.current.increment();
  });
  
  expect(result.current.count).toBe(1);
});

test('decrements count', () => {
  const { result } = renderHook(() => useCounter(5));
  
  act(() => {
    result.current.decrement();
  });
  
  expect(result.current.count).toBe(4);
});

test('resets count', () => {
  const { result } = renderHook(() => useCounter(5));
  
  act(() => {
    result.current.increment();
    result.current.reset();
  });
  
  expect(result.current.count).toBe(5);
});
```

## 6. 高级技巧

### 6.1 使用Hook工厂

创建一个函数，返回自定义Hook，用于配置Hook的行为：

```javascript
function createUseFetch(defaultOptions) {
  return function useFetchWithDefaults(url, options = {}) {
    const mergedOptions = { ...defaultOptions, ...options };
    // 使用mergedOptions实现数据获取逻辑
  };
}

// 使用Hook工厂创建配置好的Hook
const useAuthenticatedFetch = createUseFetch({
  headers: {
    Authorization: 'Bearer token'
  }
});

// 在组件中使用
function Component() {
  const { data } = useAuthenticatedFetch('https://api.example.com/data');
  // ...
}
```

### 6.2 使用Ref保存不稳定值

在自定义Hook中，使用Ref保存不稳定值，避免不必要的重新计算：

```javascript
function useEventCallback(fn) {
  const ref = useRef(fn);
  
  useEffect(() => {
    ref.current = fn;
  });
  
  return useCallback((...args) => {
    return ref.current(...args);
  }, []);
}
```

### 6.3 使用Context在自定义Hook中共享状态

将自定义Hook与Context结合，实现全局状态管理：

```javascript
const CounterContext = createContext();

function CounterProvider({ children }) {
  const counter = useCounter();
  
  return (
    <CounterContext.Provider value={counter}>
      {children}
    </CounterContext.Provider>
  );
}

function useCounterContext() {
  const context = useContext(CounterContext);
  if (context === undefined) {
    throw new Error('useCounterContext must be used within a CounterProvider');
  }
  return context;
}

// 在组件中使用
function Component() {
  const { count, increment } = useCounterContext();
  // ...
}
```

## 7. React 19 中的自定义Hooks

React 19 对自定义Hooks的支持没有重大变化，但有一些相关的改进：

1. **自动批处理**：自定义Hooks中的状态更新也会自动批处理
2. **改进的错误消息**：当在自定义Hook中违反Hooks规则时，会提供更清晰的错误消息
3. **与React Server Components兼容**：自定义Hooks可以在客户端组件中正常使用
4. **支持异步Hook**：可以在自定义Hook中使用异步逻辑

## 8. 总结

自定义Hooks是React中强大的功能，用于封装可复用的状态逻辑。通过合理使用自定义Hooks，可以：

- 提高代码的可复用性和可维护性
- 减少组件中的重复代码
- 使组件更加关注UI，而不是逻辑
- 促进团队协作和代码共享
- 提高代码的测试覆盖率

遵循自定义Hooks的最佳实践，创建高质量的Hook，可以显著提高React应用的开发效率和代码质量。

通过掌握自定义Hooks，你已经掌握了React中代码复用的核心机制，为构建复杂的React应用打下了坚实的基础。