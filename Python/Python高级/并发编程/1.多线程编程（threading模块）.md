# Python多线程编程（threading模块）

## 一、什么是多线程编程

多线程编程是指在一个程序中同时运行多个线程，每个线程执行不同的任务。线程是程序执行的最小单位，一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。

在Python中，多线程编程主要用于处理I/O密集型任务，如网络请求、文件读写等。对于CPU密集型任务，由于Python的全局解释器锁（GIL）限制，多线程可能无法充分利用多核CPU。

## 二、Python中的threading模块

Python的`threading`模块提供了创建和管理线程的功能，它是对底层`_thread`模块的封装，提供了更高级的线程管理接口。

### 1. 基本概念

- **线程（Thread）**：程序执行的最小单位，每个线程有自己的执行栈和局部变量。
- **主线程**：Python程序启动时自动创建的线程，负责执行主程序代码。
- **子线程**：通过`threading.Thread`创建的线程，用于执行并发任务。
- **GIL（全局解释器锁）**：Python解释器的一个机制，确保同一时刻只有一个线程执行Python字节码。

### 2. 创建线程的两种方式

#### 方式一：继承Thread类

```python
import threading
import time

class MyThread(threading.Thread):
    def __init__(self, name, delay):
        super().__init__()
        self.name = name
        self.delay = delay
    
    def run(self):
        print(f"线程 {self.name} 开始执行")
        time.sleep(self.delay)
        print(f"线程 {self.name} 执行结束")

# 创建线程实例
thread1 = MyThread("Thread-1", 2)
thread2 = MyThread("Thread-2", 3)

# 启动线程
thread1.start()
thread2.start()

# 等待线程结束
thread1.join()
thread2.join()

print("所有线程执行完毕")
```

#### 方式二：传递target函数

```python
import threading
import time

def task(name, delay):
    print(f"任务 {name} 开始执行")
    time.sleep(delay)
    print(f"任务 {name} 执行结束")

# 创建线程
thread1 = threading.Thread(target=task, args=("Task-1", 2))
thread2 = threading.Thread(target=task, kwargs={"name": "Task-2", "delay": 3})

# 启动线程
thread1.start()
thread2.start()

# 等待线程结束
thread1.join()
thread2.join()

print("所有任务执行完毕")
```

## 三、线程的状态管理

### 1. 线程的生命周期

- **新建（New）**：创建线程对象，但尚未调用`start()`方法。
- **就绪（Runnable）**：调用`start()`方法后，线程等待CPU调度。
- **运行（Running）**：线程获得CPU资源，正在执行`run()`方法。
- **阻塞（Blocked）**：线程等待某些条件满足，如I/O操作、锁获取等。
- **终止（Terminated）**：线程执行完毕或异常终止。

### 2. 线程的主要方法

| 方法 | 描述 |
|------|------|
| `start()` | 启动线程，调用线程的`run()`方法 |
| `run()` | 线程的主要执行逻辑，可被子类重写 |
| `join([timeout])` | 等待线程结束，可选超时时间 |
| `is_alive()` | 检查线程是否仍在运行 |
| `getName()` / `setName()` | 获取/设置线程名称 |
| `isDaemon()` / `setDaemon()` | 获取/设置线程是否为守护线程 |

### 3. 守护线程

守护线程是一种特殊的线程，当所有非守护线程结束时，守护线程会自动终止。守护线程通常用于执行后台任务，如日志记录、监控等。

```python
import threading
import time

def daemon_task():
    while True:
        print("守护线程运行中...")
        time.sleep(1)

# 创建守护线程
daemon_thread = threading.Thread(target=daemon_task)
daemon_thread.setDaemon(True)  # 设置为守护线程

# 启动守护线程
daemon_thread.start()

# 主线程执行5秒后结束
print("主线程开始执行")
time.sleep(5)
print("主线程执行结束")
# 所有非守护线程结束，守护线程自动终止
```

## 四、线程同步机制

由于多个线程共享进程的内存空间，当它们同时访问共享资源时，可能会导致数据不一致的问题。为了解决这个问题，Python提供了多种线程同步机制。

### 1. 锁（Lock）

锁是最基本的线程同步机制，用于保护临界区（同一时刻只能由一个线程访问的代码段）。

```python
import threading

# 创建锁对象
lock = threading.Lock()
count = 0

def increment():
    global count
    for _ in range(100000):
        # 获取锁
        lock.acquire()
        try:
            # 临界区代码
            count += 1
        finally:
            # 释放锁
            lock.release()

def decrement():
    global count
    for _ in range(100000):
        # 使用with语句自动获取和释放锁
        with lock:
            count -= 1

# 创建线程
thread1 = threading.Thread(target=increment)
thread2 = threading.Thread(target=decrement)

# 启动线程
thread1.start()
thread2.start()

# 等待线程结束
thread1.join()
thread2.join()

print(f"最终结果: {count}")  # 预期输出: 0
```

### 2. 可重入锁（RLock）

可重入锁允许同一个线程多次获取锁，避免死锁问题。

```python
import threading

# 创建可重入锁对象
rlock = threading.RLock()
count = 0

def nested_increment(n):
    global count
    if n == 0:
        return
    with rlock:
        count += 1
        nested_increment(n - 1)

def nested_decrement(n):
    global count
    if n == 0:
        return
    with rlock:
        count -= 1
        nested_decrement(n - 1)

# 创建线程
thread1 = threading.Thread(target=nested_increment, args=(5,))
thread2 = threading.Thread(target=nested_decrement, args=(5,))

# 启动线程
thread1.start()
thread2.start()

# 等待线程结束
thread1.join()
thread2.join()

print(f"最终结果: {count}")  # 预期输出: 0
```

### 3. 信号量（Semaphore）

信号量用于控制同时访问资源的线程数量，适用于资源有限的场景。

```python
import threading
import time

# 创建信号量对象，最多允许3个线程同时访问
max_connections = 3
semaphore = threading.Semaphore(value=max_connections)

def connect(name):
    print(f"{name} 等待连接...")
    with semaphore:
        print(f"{name} 获得连接")
        time.sleep(2)  # 模拟连接使用
        print(f"{name} 释放连接")

# 创建10个线程
threads = []
for i in range(10):
    thread = threading.Thread(target=connect, args=(f"Thread-{i+1}",))
    threads.append(thread)

# 启动所有线程
for thread in threads:
    thread.start()

# 等待所有线程结束
for thread in threads:
    thread.join()

print("所有连接完成")
```

### 4. 事件（Event）

事件用于线程间的通信，一个线程可以等待事件发生，另一个线程可以触发事件。

```python
import threading
import time

# 创建事件对象
event = threading.Event()

def waiter():
    print("等待者: 等待事件发生...")
    event.wait()  # 等待事件被设置
    print("等待者: 事件已发生，继续执行")

def setter():
    print("设置者: 准备触发事件")
    time.sleep(3)  # 模拟准备时间
    event.set()  # 设置事件
    print("设置者: 事件已触发")

# 创建线程
waiter_thread = threading.Thread(target=waiter)
setter_thread = threading.Thread(target=setter)

# 启动线程
waiter_thread.start()
setter_thread.start()

# 等待线程结束
waiter_thread.join()
setter_thread.join()

print("所有线程执行完毕")
```

### 5. 条件变量（Condition）

条件变量用于线程间的复杂通信，允许线程等待特定条件满足，或者在条件满足时通知其他线程。

```python
import threading
import time

# 创建条件变量对象
condition = threading.Condition()
queue = []
MAX_QUEUE_SIZE = 5

def producer():
    for i in range(10):
        with condition:
            # 等待队列不满
            while len(queue) >= MAX_QUEUE_SIZE:
                print(f"生产者: 队列已满，等待消费者消费")
                condition.wait()
            # 生产数据
            queue.append(i)
            print(f"生产者: 生产了数据 {i}，当前队列: {queue}")
            # 通知消费者
            condition.notify_all()
        time.sleep(0.5)

def consumer():
    for _ in range(10):
        with condition:
            # 等待队列不为空
            while len(queue) == 0:
                print(f"消费者: 队列已空，等待生产者生产")
                condition.wait()
            # 消费数据
            data = queue.pop(0)
            print(f"消费者: 消费了数据 {data}，当前队列: {queue}")
            # 通知生产者
            condition.notify_all()
        time.sleep(1)

# 创建线程
producer_thread = threading.Thread(target=producer)
consumer_thread = threading.Thread(target=consumer)

# 启动线程
producer_thread.start()
consumer_thread.start()

# 等待线程结束
producer_thread.join()
consumer_thread.join()

print("所有线程执行完毕")
```

### 6. 定时器（Timer）

定时器用于在指定时间后执行特定任务。

```python
import threading

def delayed_task():
    print("延迟任务执行")

# 创建定时器，3秒后执行delayed_task
timer = threading.Timer(3, delayed_task)

# 启动定时器
timer.start()

print("定时器已启动")

# 取消定时器（如果在执行前调用）
# timer.cancel()
```

## 五、线程池

线程池是一种线程管理机制，用于复用线程、减少线程创建和销毁的开销。Python的`concurrent.futures`模块提供了`ThreadPoolExecutor`类，用于创建和管理线程池。

```python
import concurrent.futures
import time

def task(name, delay):
    print(f"任务 {name} 开始执行")
    time.sleep(delay)
    print(f"任务 {name} 执行结束")
    return f"任务 {name} 完成"

# 创建线程池，最大工作线程数为3
with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    # 提交任务到线程池
    future1 = executor.submit(task, "Task-1", 2)
    future2 = executor.submit(task, "Task-2", 3)
    future3 = executor.submit(task, "Task-3", 1)
    future4 = executor.submit(task, "Task-4", 2)
    
    # 获取任务结果
    print(f"任务1结果: {future1.result()}")
    print(f"任务2结果: {future2.result()}")
    print(f"任务3结果: {future3.result()}")
    print(f"任务4结果: {future4.result()}")

print("所有任务执行完毕")
```

### 使用map方法批量处理任务

```python
import concurrent.futures
import time

def task(item):
    name, delay = item
    print(f"任务 {name} 开始执行")
    time.sleep(delay)
    print(f"任务 {name} 执行结束")
    return f"任务 {name} 完成"

# 任务列表
tasks = [
    ("Task-1", 2),
    ("Task-2", 3),
    ("Task-3", 1),
    ("Task-4", 2)
]

# 创建线程池
with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    # 使用map方法批量处理任务
    results = executor.map(task, tasks)
    
    # 遍历结果
    for result in results:
        print(result)

print("所有任务执行完毕")
```

### 使用as_completed方法处理完成的任务

```python
import concurrent.futures
import time

def task(name, delay):
    print(f"任务 {name} 开始执行")
    time.sleep(delay)
    print(f"任务 {name} 执行结束")
    return f"任务 {name} 完成"

# 任务列表
tasks = [
    ("Task-1", 2),
    ("Task-2", 3),
    ("Task-3", 1),
    ("Task-4", 2)
]

# 创建线程池
with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    # 提交所有任务
    future_to_task = {executor.submit(task, name, delay): (name, delay) for name, delay in tasks}
    
    # 处理完成的任务
    for future in concurrent.futures.as_completed(future_to_task):
        name, delay = future_to_task[future]
        try:
            result = future.result()
            print(f"任务 {name} 结果: {result}")
        except Exception as e:
            print(f"任务 {name} 执行出错: {e}")

print("所有任务执行完毕")
```

## 六、多线程编程的最佳实践

1. **避免共享状态**：尽量减少线程间的共享数据，使用不可变对象或线程局部存储。
2. **使用线程安全的数据结构**：如`queue.Queue`，它是线程安全的。
3. **避免死锁**：确保获取锁的顺序一致，使用`with`语句自动管理锁。
4. **使用线程池**：复用线程，减少线程创建和销毁的开销。
5. **避免使用全局变量**：全局变量是线程共享的，容易导致数据不一致。
6. **使用守护线程处理后台任务**：如日志记录、监控等。
7. **合理设置线程数**：根据CPU核心数和任务类型设置合适的线程数。
8. **处理异常**：在线程函数中捕获异常，避免线程意外终止。

## 七、实践练习

### 练习1：多线程爬取网页

编写一个多线程爬虫程序，使用`threading`模块或`ThreadPoolExecutor`同时爬取多个网页，并统计每个网页的大小。

### 练习2：生产者-消费者模型

使用条件变量实现一个生产者-消费者模型，生产者生成随机数，消费者计算随机数的平方，队列大小限制为10。

### 练习3：线程安全的计数器

实现一个线程安全的计数器类，支持递增、递减和获取当前值的操作，使用锁机制确保线程安全。

### 练习4：多线程文件下载器

编写一个多线程文件下载器，支持同时下载多个文件，并显示每个文件的下载进度。

## 八、总结

多线程编程是Python高级编程中的重要内容，掌握多线程编程可以提高程序的并发处理能力，特别是对于I/O密集型任务。在实际应用中，需要根据任务类型选择合适的并发模型，并注意线程同步和线程安全问题。

通过学习本章节，你应该能够：
- 理解多线程编程的基本概念和原理
- 掌握`threading`模块的使用方法
- 理解和使用各种线程同步机制
- 掌握线程池的使用方法
- 编写线程安全的多线程程序

下一章节，我们将学习多进程编程，它适用于CPU密集型任务，可以充分利用多核CPU的优势。