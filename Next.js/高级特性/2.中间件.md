# 中间件

## 一、中间件概述

### 1.1 中间件的重要性

中间件是Web应用开发中的核心环节，用于在请求到达目标路由之前或响应返回客户端之前执行代码。中间件可以用于处理认证授权、日志记录、请求修改、响应修改、重定向、限流等功能，是构建安全、高效Web应用的重要工具。

### 1.2 Next.js的中间件方式

Next.js支持两种中间件方式：

| 中间件方式 | 适用场景 | 特点 |
|-----------|----------|------|
| **Proxy**（原Middleware） | App Router | 基于Web Request/Response API，支持多种操作，如重定向、重写、修改请求/响应头 |
| **Pages Router中间件** | Pages Router | 基于Express风格，支持多种操作，如重定向、重写、修改请求/响应头 |

### 1.3 中间件重命名为Proxy

从Next.js 16开始，Middleware被重命名为Proxy，以更好地反映其用途。这一变化的原因包括：

1. 避免与Express.js中间件混淆，后者具有不同的用途和设计理念
2. 明确Proxy的用途：作为请求处理的最后手段，而非首选方案
3. 提供更清晰的API命名，如`proxy.ts`文件和`proxy`函数

### 1.4 中间件/Proxy的适用场景

中间件/Proxy适用于以下场景：

1. **认证授权**：验证用户身份，保护敏感路由
2. **国际化**：根据请求头或URL参数设置语言
3. **A/B测试**：根据用户特征或随机分配测试版本
4. **重定向**：将旧URL重定向到新URL
5. **重写**：修改请求URL，将请求路由到不同的处理程序
6. **日志记录**：记录请求和响应信息
7. **限流**：限制API的访问频率，防止恶意攻击
8. **修改请求/响应**：修改请求头、响应头或响应体

## 二、App Router中的Proxy

### 2.1 Proxy概述

Proxy是App Router中的中间件功能，允许开发者在请求到达目标路由之前执行代码。Proxy文件使用`proxy.ts`或`proxy.js`命名，位于项目根目录中。

### 2.2 Proxy实现

Proxy使用`proxy`函数，接收`NextRequest`对象，返回`NextResponse`对象或`undefined`：

```tsx
// src/proxy.ts
import { NextRequest, NextResponse } from 'next/server'

export function proxy(request: NextRequest) {
  // 获取请求URL
  const url = request.nextUrl

  // 示例：重定向旧URL到新URL
  if (url.pathname === '/old-path') {
    return NextResponse.redirect(new URL('/new-path', request.url))
  }

  // 示例：修改请求头
  const response = NextResponse.next()
  response.headers.set('X-Custom-Header', 'Custom Value')
  return response
}
```

### 2.3 Proxy的高级特性

#### 2.3.1 匹配规则

Proxy支持匹配规则，可以指定哪些请求需要经过Proxy处理：

```tsx
// src/proxy.ts
import { NextRequest, NextResponse } from 'next/server'

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}

export function proxy(request: NextRequest) {
  // Proxy logic
}
```

#### 2.3.2 重定向

Proxy可以用于重定向请求：

```tsx
// src/proxy.ts
import { NextRequest, NextResponse } from 'next/server'

export function proxy(request: NextRequest) {
  const url = request.nextUrl

  // 重定向HTTP到HTTPS
  if (url.protocol === 'http:') {
    url.protocol = 'https:'
    return NextResponse.redirect(url)
  }

  // 重定向旧路由到新路由
  if (url.pathname.startsWith('/blog/old')) {
    const newPath = url.pathname.replace('/blog/old', '/blog/new')
    return NextResponse.redirect(new URL(newPath, request.url))
  }

  return NextResponse.next()
}
```

#### 2.3.3 重写

Proxy可以用于重写请求，将请求路由到不同的处理程序：

```tsx
// src/proxy.ts
import { NextRequest, NextResponse } from 'next/server'

export function proxy(request: NextRequest) {
  const url = request.nextUrl

  // 重写请求，将/api/v1/posts路由到/api/posts
  if (url.pathname.startsWith('/api/v1/posts')) {
    const newPath = url.pathname.replace('/api/v1/posts', '/api/posts')
    url.pathname = newPath
    return NextResponse.rewrite(url)
  }

  // 重写请求，将/blog路由到/pages/blog
  if (url.pathname.startsWith('/blog')) {
    const newPath = `/pages${url.pathname}`
    return NextResponse.rewrite(new URL(newPath, request.url))
  }

  return NextResponse.next()
}
```

#### 2.3.4 修改请求/响应

Proxy可以用于修改请求头、响应头或响应体：

```tsx
// src/proxy.ts
import { NextRequest, NextResponse } from 'next/server'

export function proxy(request: NextRequest) {
  // 修改请求头
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('X-Forwarded-Host', request.headers.get('host') || '')

  // 创建响应
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })

  // 修改响应头
  response.headers.set('X-Custom-Header', 'Custom Value')
  response.headers.set('Cache-Control', 's-maxage=10, stale-while-revalidate')

  return response
}
```

#### 2.3.5 认证授权

Proxy可以用于处理认证授权，保护敏感路由：

```tsx
// src/proxy.ts
import { NextRequest, NextResponse } from 'next/server'

export function proxy(request: NextRequest) {
  const url = request.nextUrl

  // 公开路由，无需认证
  const publicPaths = ['/login', '/register', '/api/public']
  if (publicPaths.includes(url.pathname) || url.pathname.startsWith('/api/public')) {
    return NextResponse.next()
  }

  // 获取token
  const token = request.cookies.get('token')?.value
  if (!token) {
    // 未认证，重定向到登录页
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // 验证token
  try {
    const decoded = verifyToken(token)
    // token有效，继续处理请求
    return NextResponse.next()
  } catch (error) {
    // token无效，清除cookie并重定向到登录页
    const response = NextResponse.redirect(new URL('/login', request.url))
    response.cookies.delete('token')
    return response
  }
}
```

### 2.4 Proxy的最佳实践

1. **使用匹配规则**：使用匹配规则限制Proxy的处理范围，提高性能
2. **保持Proxy简洁**：Proxy只负责请求处理，业务逻辑应放在其他地方
3. **使用TypeScript**：提高代码的类型安全性和可维护性
4. **处理错误**：使用try-catch块处理错误，返回友好的错误信息
5. **考虑性能**：Proxy会处理所有匹配的请求，应优化代码，减少处理时间
6. **避免过度使用**：Proxy是请求处理的最后手段，应优先使用其他Next.js特性
7. **测试Proxy**：编写测试用例，确保Proxy的正确性和可靠性
8. **记录日志**：记录Proxy的处理信息，便于调试和监控

## 三、Pages Router中的中间件

### 3.1 Pages Router中间件概述

Pages Router中的中间件是基于Express风格的中间件，允许开发者在请求到达目标路由之前执行代码。中间件文件使用`_middleware.ts`或`_middleware.js`命名，位于`pages`目录中。

### 3.2 Pages Router中间件实现

Pages Router中间件使用`middleware`函数，接收`NextRequest`对象，返回`NextResponse`对象或`undefined`：

```tsx
// src/pages/_middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // 获取请求URL
  const url = request.nextUrl

  // 示例：重定向旧URL到新URL
  if (url.pathname === '/old-path') {
    return NextResponse.redirect(new URL('/new-path', request.url))
  }

  // 示例：修改请求头
  const response = NextResponse.next()
  response.headers.set('X-Custom-Header', 'Custom Value')
  return response
}
```

### 3.3 Pages Router中间件的高级特性

#### 3.3.1 嵌套中间件

Pages Router支持嵌套中间件，中间件会按照从根目录到目标路由的顺序执行：

```
src/pages/
├── _middleware.ts       # 根中间件，处理所有请求
├── api/
│   └── _middleware.ts   # API路由中间件，处理/api/*请求
└── dashboard/
    └── _middleware.ts   # 仪表板中间件，处理/dashboard/*请求
```

嵌套中间件的执行顺序是：根中间件 → API路由中间件 → 仪表板中间件。

#### 3.3.2 匹配规则

Pages Router中间件支持匹配规则，可以指定哪些请求需要经过中间件处理：

```tsx
// src/pages/_middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  const url = request.nextUrl

  // 只处理GET请求
  if (request.method !== 'GET') {
    return NextResponse.next()
  }

  // 只处理特定路径的请求
  if (url.pathname.startsWith('/api') || url.pathname.startsWith('/dashboard')) {
    // 中间件逻辑
  }

  return NextResponse.next()
}
```

#### 3.3.3 认证授权

Pages Router中间件可以用于处理认证授权，保护敏感路由：

```tsx
// src/pages/dashboard/_middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // 获取token
  const token = request.cookies.get('token')?.value
  if (!token) {
    // 未认证，重定向到登录页
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // 验证token
  try {
    const decoded = verifyToken(token)
    // token有效，继续处理请求
    return NextResponse.next()
  } catch (error) {
    // token无效，清除cookie并重定向到登录页
    const response = NextResponse.redirect(new URL('/login', request.url))
    response.cookies.delete('token')
    return response
  }
}
```

### 3.4 Pages Router中间件的最佳实践

1. **使用嵌套中间件**：按功能模块组织中间件，提高代码复用性和可维护性
2. **保持中间件简洁**：中间件只负责请求处理，业务逻辑应放在其他地方
3. **使用TypeScript**：提高代码的类型安全性和可维护性
4. **处理错误**：使用try-catch块处理错误，返回友好的错误信息
5. **考虑性能**：中间件会处理所有匹配的请求，应优化代码，减少处理时间
6. **避免过度使用**：中间件是请求处理的最后手段，应优先使用其他Next.js特性
7. **测试中间件**：编写测试用例，确保中间件的正确性和可靠性
8. **记录日志**：记录中间件的处理信息，便于调试和监控

## 四、中间件的最佳实践

### 4.1 设计原则

1. **单一职责**：每个中间件只负责一个功能，如认证、日志记录等
2. **顺序执行**：中间件按照特定顺序执行，确保依赖关系正确
3. **错误处理**：中间件应处理自身的错误，避免影响后续中间件
4. **可测试性**：中间件应易于测试，便于验证其正确性
5. **性能优化**：中间件应优化代码，减少处理时间
6. **安全性**：中间件应考虑安全性，如防止XSS、CSRF等攻击
7. **可配置性**：中间件应支持配置，便于调整行为
8. **文档化**：中间件应提供清晰的文档，说明其用途和使用方法

### 4.2 代码组织

1. **模块化设计**：将中间件的业务逻辑抽象到单独的文件中
2. **按功能分组**：按功能模块组织中间件，如认证中间件、日志中间件等
3. **使用工厂函数**：使用工厂函数创建中间件，提高可配置性
4. **使用服务层**：将业务逻辑抽象到服务层，提高代码复用性和可测试性
5. **使用数据访问层**：将数据访问逻辑抽象到数据访问层，提高代码复用性和可测试性

### 4.3 性能优化

1. **使用匹配规则**：使用匹配规则限制中间件的处理范围，提高性能
2. **优化代码**：优化中间件代码，减少处理时间
3. **使用缓存**：对于频繁访问的数据，使用缓存，减少数据库查询
4. **避免同步操作**：避免在中间件中执行同步操作，如文件IO、数据库查询等
5. **使用异步操作**：使用异步操作，提高中间件的并发处理能力
6. **考虑边缘计算**：将部分中间件逻辑迁移到边缘节点，减少延迟

### 4.4 安全性

1. **验证请求**：验证请求参数、请求体和请求头，确保数据的完整性和安全性
2. **使用HTTPS**：使用HTTPS传输数据，防止数据泄露
3. **使用CORS**：合理配置CORS，防止跨站请求伪造
4. **使用认证和授权**：实现认证和授权机制，保护敏感路由
5. **使用速率限制**：限制API的访问频率，防止恶意攻击
6. **使用输入验证**：验证用户输入，防止SQL注入、XSS等攻击
7. **保护敏感数据**：不返回敏感数据，如密码、API密钥等
8. **使用安全头**：设置安全头，如Content-Security-Policy、X-XSS-Protection等

## 五、中间件的测试

### 5.1 单元测试

使用Jest等测试框架测试中间件的业务逻辑：

```tsx
// src/proxy.test.ts
import { proxy } from './proxy'
import { NextRequest, NextResponse } from 'next/server'

// 模拟NextRequest
const createMockRequest = (url: string, method: string = 'GET') => {
  return new NextRequest(new URL(url), {
    method,
    headers: {
      host: 'example.com',
    },
  })
}

describe('Proxy', () => {
  it('should redirect old path to new path', () => {
    const request = createMockRequest('http://example.com/old-path')
    const response = proxy(request)
    expect(response).toBeInstanceOf(NextResponse)
    expect(response?.headers.get('location')).toBe('http://example.com/new-path')
  })

  it('should add custom header', () => {
    const request = createMockRequest('http://example.com/')
    const response = proxy(request)
    expect(response).toBeInstanceOf(NextResponse)
    expect(response?.headers.get('X-Custom-Header')).toBe('Custom Value')
  })
})
```

### 5.2 集成测试

使用Supertest等测试框架测试中间件的集成：

```tsx
// src/tests/proxy.spec.ts
import request from 'supertest'
import { createServer } from 'http'
import next from 'next'

const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

describe('Proxy', () => {
  let server: any

  beforeAll(async () => {
    await app.prepare()
    server = createServer((req, res) => {
      handle(req, res)
    })
    server.listen(3000)
  })

  afterAll(async () => {
    await app.close()
    server.close()
  })

  it('should redirect old path to new path', async () => {
    const response = await request(server).get('/old-path')
    expect(response.status).toBe(307)
    expect(response.headers.location).toBe('http://localhost:3000/new-path')
  })

  it('should add custom header', async () => {
    const response = await request(server).get('/')
    expect(response.status).toBe(200)
    expect(response.headers['x-custom-header']).toBe('Custom Value')
  })
})
```

### 5.3 端到端测试

使用Playwright或Cypress等测试框架测试中间件的端到端功能：

```tsx
// src/tests/proxy.e2e.ts
import { test, expect } from '@playwright/test'

test('should redirect old path to new path', async ({ page }) => {
  const response = await page.goto('/old-path')
  expect(response?.status()).toBe(307)
  expect(page.url()).toBe('http://localhost:3000/new-path')
})

test('should add custom header', async ({ request }) => {
  const response = await request.get('/')
  expect(response.status()).toBe(200)
  expect(response.headers()['x-custom-header']).toBe('Custom Value')
})
```

## 六、中间件的部署

### 6.1 Vercel部署

Next.js中间件可以直接部署到Vercel，无需额外配置：

1. 登录Vercel账号
2. 连接GitHub仓库
3. 配置项目设置
4. 点击"Deploy"按钮

Vercel会自动检测Next.js项目，并部署中间件。

### 6.2 自定义服务器部署

Next.js中间件也可以部署到自定义服务器，如Express、Fastify等：

```tsx
// src/server.ts
import express from 'express'
import next from 'next'

const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
  const server = express()

  // 解析JSON请求体
  server.use(express.json())

  // 自定义中间件
  server.use((req, res, next) => {
    console.log(`${req.method} ${req.url}`)
    next()
  })

  // 处理Next.js请求
  server.all('*', (req, res) => {
    return handle(req, res)
  })

  server.listen(3000, (err?: any) => {
    if (err) throw err
    console.log('> Ready on http://localhost:3000')
  })
})
```

### 6.3 Docker部署

Next.js中间件可以使用Docker部署：

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

## 七、总结

本章节我们学习了Next.js的中间件功能：

1. **中间件概述**：介绍了中间件的重要性、Next.js的中间件方式，以及Next.js 16将Middleware重命名为Proxy的变化
2. **App Router中的Proxy**：详细介绍了Proxy的实现和高级特性，包括匹配规则、重定向、重写、修改请求/响应、认证授权等
3. **Pages Router中的中间件**：介绍了Pages Router中的中间件实现和高级特性，包括嵌套中间件、匹配规则、认证授权等
4. **中间件的最佳实践**：介绍了中间件的设计原则、代码组织、性能优化、安全性等
5. **中间件的测试**：介绍了中间件的单元测试、集成测试、端到端测试
6. **中间件的部署**：介绍了中间件的Vercel部署、自定义服务器部署、Docker部署

通过本章节的学习，你应该能够深入理解Next.js的中间件功能，并根据应用需求选择合适的中间件方式。在实际项目中，需要根据应用的具体需求，结合性能、安全性、可维护性等因素，选择合适的中间件方式和实现方案。

## 八、练习

1. 创建一个Next.js项目，实现以下中间件功能：
   - 使用Proxy实现认证授权，保护敏感路由
   - 使用Proxy实现重定向，将旧URL重定向到新URL
   - 使用Proxy实现请求修改，添加自定义请求头
   - 使用Proxy实现响应修改，添加自定义响应头
2. 实现Pages Router中的中间件，处理API路由的认证授权
3. 编写中间件的单元测试和集成测试
4. 部署中间件到Vercel或自定义服务器
5. 优化中间件的性能，如使用匹配规则、缓存等
6. 实现中间件的日志记录功能
7. 实现中间件的限流功能，防止恶意攻击
8. 实现中间件的国际化功能，根据请求头或URL参数设置语言

---

**下一章预告**：国际化

在接下来的章节中，我们将深入学习Next.js的国际化功能，包括App Router中的国际化、Pages Router中的国际化、国际化的实现和使用场景等。