# 部署和交互

## 3.1 部署脚本编写

### 3.1.1 部署脚本的重要性

部署脚本是智能合约开发的重要组成部分，它可以：
- 自动化合约部署流程
- 确保部署的一致性
- 支持多网络部署
- 便于版本控制和审计
- 简化团队协作

### 3.1.2 Hardhat部署脚本

**基本部署脚本结构：**
```javascript
// scripts/deploy.js
const { ethers } = require("hardhat");

async function main() {
  // 获取合约工厂
  const MyContract = await ethers.getContractFactory("MyContract");
  
  // 部署合约，传递构造函数参数
  const myContract = await MyContract.deploy("Initial Value");
  
  // 等待合约部署完成
  await myContract.deployed();
  
  // 输出合约地址
  console.log("MyContract deployed to:", myContract.address);
  
  // 可以在这里添加初始化逻辑
  await myContract.initialize();
}

// 执行部署脚本
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

**部署命令：**
```bash
# 部署到本地网络
npx hardhat run scripts/deploy.js

# 部署到Goerli测试网
npx hardhat run scripts/deploy.js --network goerli
```

### 3.1.3 Foundry部署命令

**使用Forge部署：**
```bash
# 部署到本地网络
forge create --rpc-url http://localhost:8545 --private-key $PRIVATE_KEY src/MyContract.sol:MyContract

# 部署到Goerli测试网
forge create --rpc-url $GOERLI_URL --private-key $PRIVATE_KEY src/MyContract.sol:MyContract

# 部署时传递构造函数参数
forge create --rpc-url $GOERLI_URL --private-key $PRIVATE_KEY src/MyContract.sol:MyContract --constructor-args "Initial Value"
```

## 3.2 合约验证

### 3.2.1 合约验证的重要性

合约验证是将合约源代码上传到区块链浏览器，以便：
- 提高透明度和可信度
- 允许用户查看和审计合约代码
- 支持与合约的直接交互
- 便于调试和错误分析

### 3.2.2 使用Hardhat验证合约

**安装插件：**
```bash
npm install --save-dev @nomiclabs/hardhat-etherscan
```

**配置hardhat.config.js：**
```javascript
require("@nomiclabs/hardhat-etherscan");

module.exports = {
  // ...其他配置
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY,
  },
};
```

**验证命令：**
```bash
# 验证合约
npx hardhat verify --network goerli CONTRACT_ADDRESS "Constructor Argument"

# 验证带有多个构造函数参数的合约
npx hardhat verify --network goerli CONTRACT_ADDRESS --constructor-args arguments.js
```

**arguments.js示例：**
```javascript
module.exports = [
  "Argument 1",
  "Argument 2",
  123,
];
```

### 3.2.3 使用Foundry验证合约

**使用Forge验证：**
```bash
# 验证合约
forge verify-contract --chain-id 5 --num-of-optimizations 200 --constructor-args "0x$(cast abi-encode "constructor(string)" "Initial Value")" --etherscan-api-key $ETHERSCAN_API_KEY CONTRACT_ADDRESS src/MyContract.sol:MyContract
```

## 3.3 Web3.js/Ethers.js：前端交互

### 3.3.1 Web3.js简介

Web3.js是一个JavaScript库，用于与以太坊区块链交互。它提供了与以太坊节点通信的API，支持合约交互、交易发送等功能。

**安装：**
```bash
npm install web3
```

**基本使用：**
```javascript
const Web3 = require('web3');

// 连接到以太坊节点
const web3 = new Web3('https://goerli.infura.io/v3/YOUR_INFURA_KEY');

// 获取账户余额
async function getBalance() {
  const balance = await web3.eth.getBalance('0x...');
  console.log('Balance:', web3.utils.fromWei(balance, 'ether'), 'ETH');
}

// 发送交易
async function sendTransaction() {
  const tx = {
    from: '0x...',
    to: '0x...',
    value: web3.utils.toWei('0.1', 'ether'),
    gas: 21000,
  };
  
  const signedTx = await web3.eth.accounts.signTransaction(tx, 'PRIVATE_KEY');
  const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
  console.log('Transaction receipt:', receipt);
}
```

### 3.3.2 Ethers.js简介

Ethers.js是一个轻量级的JavaScript库，用于与以太坊区块链交互。它提供了更简洁的API和更好的类型支持，是Hardhat的默认库。

**安装：**
```bash
npm install ethers
```

**基本使用：**
```javascript
const { ethers } = require('ethers');

// 连接到以太坊节点
const provider = new ethers.providers.JsonRpcProvider('https://goerli.infura.io/v3/YOUR_INFURA_KEY');

// 获取账户余额
async function getBalance() {
  const balance = await provider.getBalance('0x...');
  console.log('Balance:', ethers.utils.formatEther(balance), 'ETH');
}

// 发送交易
async function sendTransaction() {
  const wallet = new ethers.Wallet('PRIVATE_KEY', provider);
  
  const tx = {
    to: '0x...',
    value: ethers.utils.parseEther('0.1'),
  };
  
  const receipt = await wallet.sendTransaction(tx);
  await receipt.wait();
  console.log('Transaction receipt:', receipt);
}
```

### 3.3.3 与合约交互

**使用Ethers.js与合约交互：**
```javascript
// 合约ABI
const abi = [
  "function balanceOf(address) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "event Transfer(address indexed from, address indexed to, uint256 value)",
];

// 合约地址
const contractAddress = '0x...';

// 创建合约实例
const contract = new ethers.Contract(contractAddress, abi, provider);

// 调用视图函数
async function getBalance() {
  const balance = await contract.balanceOf('0x...');
  console.log('Balance:', ethers.utils.formatEther(balance));
}

// 发送交易（修改状态）
async function transferTokens() {
  const wallet = new ethers.Wallet('PRIVATE_KEY', provider);
  const contractWithSigner = contract.connect(wallet);
  
  const tx = await contractWithSigner.transfer('0x...', ethers.utils.parseEther('100'));
  await tx.wait();
  console.log('Transfer completed:', tx.hash);
}

// 监听事件
contract.on('Transfer', (from, to, value) => {
  console.log(`Transfer: ${from} -> ${to} ${ethers.utils.formatEther(value)} tokens`);
});
```

## 3.4 The Graph：区块链数据索引

### 3.4.1 The Graph简介

The Graph是一个去中心化的索引协议，用于查询区块链数据。它允许开发者构建和部署子图（Subgraphs），以便高效地查询区块链上的数据。

### 3.4.2 The Graph的核心概念

1. **子图（Subgraph）**：
   - 定义要索引的数据和查询方式
   - 包含数据源、模式定义和映射函数
   - 部署到Graph节点

2. **GraphQL API**：
   - 用于查询索引的数据
   - 支持复杂查询和过滤
   - 提供实时更新

3. **映射函数**：
   - 定义如何将区块链事件转换为GraphQL实体
   - 使用AssemblyScript编写
   - 处理区块、交易和事件

### 3.4.3 构建子图

**安装Graph CLI：**
```bash
npm install -g @graphprotocol/graph-cli
```

**初始化子图：**
```bash
graph init --product subgraph-studio --from-contract CONTRACT_ADDRESS --network goerli --abi ./abi/Contract.json
```

**子图配置文件（subgraph.yaml）：**
```yaml
description: "My Contract Subgraph"
repository: "https://github.com/username/my-subgraph"
dataSources:
  - kind: ethereum
    name: MyContract
    network: goerli
    source:
      address: "CONTRACT_ADDRESS"
      abi: MyContract
      startBlock: 1234567
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - Transfer
      abis:
        - name: MyContract
          file: ./abis/MyContract.json
      eventHandlers:
        - event: Transfer(indexed address,indexed address,uint256)
          handler: handleTransfer
      file: ./src/mapping.ts
```

**映射函数（src/mapping.ts）：**
```typescript
import { Transfer } from '../generated/schema';
import { Transfer as TransferEvent } from '../generated/MyContract/MyContract';

export function handleTransfer(event: TransferEvent): void {
  let entity = new Transfer(event.transaction.hash.toHex() + '-' + event.logIndex.toString());
  entity.from = event.params.from;
  entity.to = event.params.to;
  entity.value = event.params.value;
  entity.blockNumber = event.block.number;
  entity.blockTimestamp = event.block.timestamp;
  entity.transactionHash = event.transaction.hash;
  entity.save();
}
```

**部署子图：**
```bash
graph codegen
graph build
graph deploy --studio my-subgraph
```

**查询子图：**
```graphql
query {
  transfers(first: 5, orderBy: blockTimestamp, orderDirection: desc) {
    id
    from
    to
    value
    blockTimestamp
  }
}
```

## 3.5 实践练习

### 3.5.1 部署脚本编写

1. 编写一个Hardhat部署脚本，用于部署一个ERC20代币合约
2. 支持传递构造函数参数（名称、符号、小数位数）
3. 部署后自动初始化合约
4. 支持多网络部署

### 3.5.2 合约交互练习

1. 使用Ethers.js编写一个脚本，与已部署的ERC20合约交互
2. 实现以下功能：
   - 查询账户余额
   - 转账代币
   - 监听Transfer事件
   - 调用合约的其他函数

### 3.5.3 The Graph子图开发

1. 为一个简单的众筹合约构建子图
2. 索引以下事件：
   - 捐款事件
   - 提款事件
   - 退款事件
3. 定义GraphQL模式，支持查询：
   - 所有捐款记录
   - 特定用户的捐款
   - 众筹的总捐款金额
   - 众筹的状态

## 3.6 学习资源

- [Hardhat部署文档](https://hardhat.org/tutorial/deploying-to-a-live-network.html)
- [Ethers.js官方文档](https://docs.ethers.org/)
- [Web3.js官方文档](https://web3js.readthedocs.io/)
- [The Graph官方文档](https://thegraph.com/docs/)
- [Etherscan验证指南](https://docs.etherscan.io/contract-verification/verifying-a-contract)

## 3.7 总结

部署和交互是智能合约开发的重要环节。通过编写部署脚本，可以自动化合约部署流程，确保部署的一致性和可靠性。合约验证可以提高透明度和可信度，便于用户查看和审计合约代码。

Web3.js和Ethers.js是与智能合约交互的主要工具，它们提供了丰富的API，支持合约调用、交易发送和事件监听。The Graph则提供了高效的区块链数据索引和查询功能，便于构建复杂的去中心化应用。

在实际开发中，建议结合使用这些工具，构建完整的智能合约应用。同时，要注意安全最佳实践，如保护私钥、验证合约代码、使用安全的交易方式等。