# 高级合约模式

## 2.1 工厂模式

工厂模式是一种创建型设计模式，用于批量创建和管理合约实例。当需要创建多个相似的合约时，工厂模式可以简化部署流程并提供集中管理。

### 2.1.1 工厂模式的优势

- 集中管理合约部署
- 简化合约创建流程
- 记录所有创建的合约实例
- 可以实现权限控制
- 便于升级和维护

### 2.1.2 工厂模式实现

**基本工厂合约：**
```solidity
// 要创建的合约
contract SimpleToken {
    address public owner;
    string public name;
    string public symbol;
    uint8 public decimals;
    
    constructor(address _owner, string memory _name, string memory _symbol, uint8 _decimals) {
        owner = _owner;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
}

// 工厂合约
contract TokenFactory {
    // 记录所有创建的代币合约
    SimpleToken[] public tokens;
    // 记录每个地址创建的合约数量
    mapping(address => uint) public deployerCount;
    
    // 事件：记录合约创建
    event TokenCreated(address indexed tokenAddress, address indexed deployer, string name, string symbol);
    
    // 创建新的代币合约
    function createToken(string memory _name, string memory _symbol, uint8 _decimals) public returns (SimpleToken) {
        // 创建新合约实例
        SimpleToken newToken = new SimpleToken(msg.sender, _name, _symbol, _decimals);
        // 记录合约
        tokens.push(newToken);
        deployerCount[msg.sender]++;
        // 触发事件
        emit TokenCreated(address(newToken), msg.sender, _name, _symbol);
        return newToken;
    }
    
    // 获取所有创建的合约数量
    function getTokensCount() public view returns (uint) {
        return tokens.length;
    }
    
    // 获取指定索引的合约
    function getToken(uint _index) public view returns (SimpleToken) {
        require(_index < tokens.length, "Token index out of range");
        return tokens[_index];
    }
}
```

### 2.1.3 工厂模式的应用场景

- 代币发行平台
- NFT铸造平台
- 去中心化交易所的交易对创建
- DAO组织的提案创建

## 2.2 代理模式和升级合约

代理模式允许合约在不改变地址的情况下进行升级，解决了智能合约一旦部署就无法修改的问题。

### 2.2.1 代理模式的工作原理

- 代理合约：接收所有外部调用并转发给实现合约
- 实现合约：包含实际的业务逻辑
- 管理员：负责升级实现合约

### 2.2.2 代理模式的类型

#### 2.2.2.1 透明代理模式

透明代理模式中，代理合约会检查调用者是否为管理员，如果是则执行管理功能，否则转发给实现合约。

**透明代理实现：**
```solidity
// 实现合约接口
interface IImplementation {
    function increment() external;
    function getCount() external view returns (uint);
}

// 代理合约
contract TransparentProxy {
    address public implementation;
    address public admin;
    
    // 存储插槽，避免与实现合约的存储冲突
    bytes32 private constant IMPLEMENTATION_SLOT = keccak256("implementation");
    bytes32 private constant ADMIN_SLOT = keccak256("admin");
    
    constructor(address _implementation, address _admin) {
        implementation = _implementation;
        admin = _admin;
    }
    
    // 管理员升级实现合约
    function upgradeTo(address _newImplementation) public {
        require(msg.sender == admin, "Not admin");
        implementation = _newImplementation;
    }
    
    // 回退函数，转发所有调用给实现合约
    fallback() external payable {
        address impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
    
    // 接收以太币
    receive() external payable {}
}

// 初始实现合约
contract ImplementationV1 is IImplementation {
    uint public count;
    
    function increment() external {
        count++;
    }
    
    function getCount() external view returns (uint) {
        return count;
    }
}

// 升级后的实现合约
contract ImplementationV2 is IImplementation {
    uint public count;
    
    function increment() external {
        count += 2; // 升级：每次增加2
    }
    
    function getCount() external view returns (uint) {
        return count;
    }
    
    // 新增功能
    function reset() external {
        count = 0;
    }
}
```

#### 2.2.2.2 UUPS代理模式

UUPS（Universal Upgradeable Proxy Standard）代理模式将升级逻辑放在实现合约中，而不是代理合约中，减少了代理合约的复杂性。

### 2.2.3 代理模式的注意事项

- 存储布局兼容性：升级后的合约必须保持相同的存储布局
- 初始化顺序：确保代理合约正确初始化
- 权限控制：严格控制升级权限
- 事件处理：确保事件正确触发
- 测试：充分测试升级过程

## 2.3 治理合约

治理合约用于管理去中心化组织（DAO）的决策过程，允许代币持有者对提案进行投票。

### 2.3.1 治理合约的核心组件

- 提案创建：允许用户创建提案
- 投票机制：代币持有者投票支持或反对提案
- 提案执行：当提案获得足够支持时自动执行
- 时间锁定：提案通过后需要等待一段时间才能执行

### 2.3.2 治理合约实现

**基本治理合约：**
```solidity
contract Governance {
    // 提案结构体
    struct Proposal {
        uint id;
        string description;
        address proposer;
        uint voteCount;
        uint endTime;
        bool executed;
        mapping(address => bool) voted;
    }
    
    // 状态变量
    uint public proposalCount;
    mapping(uint => Proposal) public proposals;
    uint public votingDelay = 1 days;
    uint public votingPeriod = 7 days;
    uint public quorum = 50; // 投票通过所需的最低票数百分比
    
    // 事件
    event ProposalCreated(uint indexed id, string description, address indexed proposer);
    event Voted(uint indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint indexed id);
    
    // 创建提案
    function createProposal(string memory _description) public returns (uint) {
        proposalCount++;
        Proposal storage proposal = proposals[proposalCount];
        proposal.id = proposalCount;
        proposal.description = _description;
        proposal.proposer = msg.sender;
        proposal.endTime = block.timestamp + votingPeriod;
        
        emit ProposalCreated(proposalCount, _description, msg.sender);
        return proposalCount;
    }
    
    // 投票
    function vote(uint _proposalId, bool _support) public {
        Proposal storage proposal = proposals[_proposalId];
        require(block.timestamp < proposal.endTime, "Voting period ended");
        require(!proposal.voted[msg.sender], "Already voted");
        
        proposal.voted[msg.sender] = true;
        if (_support) {
            proposal.voteCount++;
        }
        
        emit Voted(_proposalId, msg.sender, _support);
    }
    
    // 执行提案
    function executeProposal(uint _proposalId) public {
        Proposal storage proposal = proposals[_proposalId];
        require(block.timestamp > proposal.endTime, "Voting period not ended");
        require(!proposal.executed, "Already executed");
        require(proposal.voteCount >= quorum, "Not enough votes");
        
        proposal.executed = true;
        // 这里可以添加提案执行的具体逻辑
        
        emit ProposalExecuted(_proposalId);
    }
}
```

### 2.3.3 治理合约的应用场景

- DAO组织管理
- 去中心化协议升级
- 资金分配决策
- 参数调整

## 2.4 时间锁合约

时间锁合约用于延迟执行敏感操作，增加系统的安全性，防止恶意行为或错误操作。

### 2.4.1 时间锁合约的工作原理

- 用户提交操作请求
- 等待指定的时间延迟
- 时间到期后执行操作
- 可以取消未执行的操作

### 2.4.2 时间锁合约实现

**基本时间锁合约：**
```solidity
contract Timelock {
    // 时间锁延迟（秒）
    uint public delay;
    
    // 操作结构体
    struct Operation {
        bytes32 id;
        address target;
        uint value;
        bytes data;
        uint eta;
        bool executed;
    }
    
    // 状态变量
    mapping(bytes32 => Operation) public operations;
    
    // 事件
    event OperationScheduled(bytes32 indexed id, address indexed target, uint value, bytes data, uint eta);
    event OperationExecuted(bytes32 indexed id, address indexed target, uint value, bytes data);
    event OperationCanceled(bytes32 indexed id);
    
    constructor(uint _delay) {
        delay = _delay;
    }
    
    // 计算操作ID
    function getOperationId(address _target, uint _value, bytes memory _data, uint _eta) public pure returns (bytes32) {
        return keccak256(abi.encode(_target, _value, _data, _eta));
    }
    
    // 调度操作
    function schedule(address _target, uint _value, bytes memory _data) public returns (bytes32) {
        uint eta = block.timestamp + delay;
        bytes32 id = getOperationId(_target, _value, _data, eta);
        
        operations[id] = Operation({
            id: id,
            target: _target,
            value: _value,
            data: _data,
            eta: eta,
            executed: false
        });
        
        emit OperationScheduled(id, _target, _value, _data, eta);
        return id;
    }
    
    // 执行操作
    function execute(address _target, uint _value, bytes memory _data, uint _eta) public returns (bytes memory) {
        bytes32 id = getOperationId(_target, _value, _data, _eta);
        Operation storage operation = operations[id];
        
        require(block.timestamp >= operation.eta, "Operation not ready");
        require(!operation.executed, "Operation already executed");
        
        operation.executed = true;
        
        // 执行操作
        (bool success, bytes memory result) = _target.call{value: _value}(_data);
        require(success, "Operation execution failed");
        
        emit OperationExecuted(id, _target, _value, _data);
        return result;
    }
    
    // 取消操作
    function cancel(address _target, uint _value, bytes memory _data, uint _eta) public {
        bytes32 id = getOperationId(_target, _value, _data, _eta);
        Operation storage operation = operations[id];
        
        require(!operation.executed, "Operation already executed");
        
        delete operations[id];
        
        emit OperationCanceled(id);
    }
}
```

### 2.4.3 时间锁合约的应用场景

- 治理提案执行
- 合约升级
- 资金转移
- 敏感参数调整

## 2.5 其他高级合约模式

### 2.5.1 提款模式

提款模式将资金转移的控制权交给用户，而不是合约主动转账，减少了重入攻击的风险。

**提款模式实现：**
```solidity
contract WithdrawalPattern {
    mapping(address => uint) public balances;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    // 用户主动提款，而不是合约主动转账
    function withdraw() public {
        uint amount = balances[msg.sender];
        require(amount > 0, "No balance");
        
        // 先更新状态
        balances[msg.sender] = 0;
        
        // 用户主动提款
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

### 2.5.2 拉取模式

拉取模式与提款模式类似，用于处理批量操作，如批量奖励发放。

### 2.5.3 状态机模式

状态机模式用于管理合约的不同状态，如众筹合约的不同阶段（筹资中、成功、失败）。

## 2.6 实践练习

### 2.6.1 工厂模式练习

设计一个NFT工厂合约，包含以下功能：
- 允许用户创建自定义NFT集合
- 记录所有创建的NFT集合
- 实现权限控制，只有管理员可以创建NFT集合
- 支持NFT集合的元数据管理

### 2.6.2 代理模式练习

实现一个简单的代理升级系统，包含：
- 代理合约
- 初始实现合约（计数器功能）
- 升级后的实现合约（增加重置功能）
- 管理员升级流程

### 2.6.3 治理合约练习

扩展基本治理合约，添加：
- 基于代币数量的投票权重
- 提案执行的时间锁定
- 提案撤销功能
- 投票委托功能

## 2.7 学习资源

- [OpenZeppelin代理合约](https://docs.openzeppelin.com/contracts/4.x/api/proxy)
- [Compound Governance](https://compound.finance/governance)
- [Aave Governance](https://docs.aave.com/faq/governance)
- [EIP-1967: Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967)
- [EIP-2535: Diamond Standard](https://eips.ethereum.org/EIPS/eip-2535)

## 2.8 总结

高级合约模式是构建复杂去中心化应用的关键，它们提供了灵活、安全和可扩展的解决方案。通过学习和应用这些模式，可以构建更健壮、更易于维护的智能合约系统。

在实际开发中，建议使用经过审计的库（如OpenZeppelin）来实现这些模式，而不是从零开始编写，以提高安全性和可靠性。