# 2. Node.js模块化系统

## 2.1 模块化概述

模块化是将一个大的程序拆分成多个小的、独立的模块，每个模块只负责特定的功能，然后通过一定的方式将这些模块组合起来，形成一个完整的应用。

### 模块化的优势
- **代码复用**：可以将常用的功能封装成模块，在多个项目中复用
- **代码组织**：将代码按照功能划分，便于维护和管理
- **避免命名冲突**：每个模块有自己的作用域，不会污染全局作用域
- **依赖管理**：清晰地表达模块之间的依赖关系

## 2.2 CommonJS模块系统

Node.js最初采用的是CommonJS模块系统，这是Node.js的默认模块系统。

### 2.2.1 模块导出

在CommonJS中，使用`module.exports`或`exports`对象来导出模块的内容。

#### 导出单个值

```javascript
// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

module.exports = {
  add,
  subtract
};
```

#### 导出单个函数

```javascript
// greet.js
module.exports = (name) => {
  return `Hello, ${name}!`;
};
```

#### 使用exports对象

```javascript
// utils.js
exports.formatDate = (date) => {
  return date.toISOString();
};

exports.capitalize = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
```

### 2.2.2 模块导入

使用`require()`函数来导入模块。

#### 导入自定义模块

```javascript
// app.js
const math = require('./math');
const greet = require('./greet');
const utils = require('./utils');

console.log(math.add(1, 2)); // 3
console.log(greet('Node.js')); // Hello, Node.js!
console.log(utils.formatDate(new Date())); // 2023-10-05T14:48:00.000Z
```

#### 导入内置模块

```javascript
const fs = require('node:fs');
const http = require('node:http');
const path = require('node:path');
```

#### 导入第三方模块

```javascript
const express = require('express');
const mongoose = require('mongoose');
```

### 2.2.3 module.exports vs exports

- `module.exports`是真正的导出对象，而`exports`只是`module.exports`的一个引用
- 当你给`exports`赋值一个新对象时，它会断开与`module.exports`的连接
- 建议始终使用`module.exports`来避免混淆

## 2.3 ES模块系统

从Node.js 12开始，Node.js支持ES模块系统（ECMAScript Modules），这是JavaScript的标准模块系统。

### 2.3.1 启用ES模块

要在Node.js中使用ES模块，有两种方式：

1. 将文件扩展名改为`.mjs`
2. 在`package.json`中设置`"type": "module"`

### 2.3.2 模块导出

使用`export`关键字来导出模块的内容。

#### 命名导出

```javascript
// math.mjs
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
```

#### 默认导出

```javascript
// greet.mjs
export default (name) => {
  return `Hello, ${name}!`;
};
```

#### 混合导出

```javascript
// utils.mjs
export const formatDate = (date) => {
  return date.toISOString();
};

export const capitalize = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

export default {
  formatDate,
  capitalize
};
```

### 2.3.3 模块导入

使用`import`关键字来导入模块。

#### 导入命名导出

```javascript
// app.mjs
import { add, subtract } from './math.mjs';

console.log(add(1, 2)); // 3
console.log(subtract(5, 3)); // 2
```

#### 导入默认导出

```javascript
// app.mjs
import greet from './greet.mjs';

console.log(greet('Node.js')); // Hello, Node.js!
```

#### 导入所有内容

```javascript
// app.mjs
import * as math from './math.mjs';

console.log(math.add(1, 2)); // 3
console.log(math.subtract(5, 3)); // 2
```

#### 导入内置模块

```javascript
import fs from 'node:fs';
import http from 'node:http';
import path from 'node:path';
```

## 2.4 模块解析

当使用`require()`或`import`导入模块时，Node.js会按照一定的规则来查找模块文件。

### 2.4.1 模块类型

1. **内置模块**：Node.js提供的核心模块，如`fs`、`http`等
2. **自定义模块**：开发者自己创建的模块，使用相对路径或绝对路径导入
3. **第三方模块**：通过npm安装的模块，存放在`node_modules`目录中

### 2.4.2 解析规则

#### 导入内置模块

直接使用模块名，不需要路径。

```javascript
const fs = require('node:fs');
```

#### 导入自定义模块

- 使用相对路径（以`./`或`../`开头）
- 可以省略文件扩展名，Node.js会自动查找`.js`、`.json`、`.node`等文件
- 如果路径指向一个目录，Node.js会查找该目录下的`index.js`或`index.mjs`文件，或者根据`package.json`中的`main`字段来确定入口文件

```javascript
const math = require('./math'); // 查找./math.js、./math.json或./math/index.js
const config = require('../config'); // 查找../config.js、../config.json或../config/index.js
```

#### 导入第三方模块

- Node.js会从当前目录开始，向上遍历目录树，查找`node_modules`目录
- 找到`node_modules`目录后，会在其中查找与模块名匹配的目录
- 然后查找该目录下的`package.json`文件，根据`main`字段确定入口文件
- 如果没有`package.json`文件，会查找`index.js`或`index.mjs`文件

```javascript
const express = require('express');
```

## 2.5 模块缓存

Node.js会缓存已加载的模块，当再次导入同一个模块时，会直接返回缓存中的模块，而不会重新加载和执行模块文件。

### 缓存的好处
- 提高性能，避免重复加载和执行模块
- 确保模块的单例性，多次导入同一个模块得到的是同一个实例

### 缓存的验证

```javascript
// counter.js
let count = 0;

module.exports = {
  increment: () => {
    count++;
    return count;
  },
  getCount: () => count
};
```

```javascript
// app.js
const counter1 = require('./counter');
const counter2 = require('./counter');

console.log(counter1.increment()); // 1
console.log(counter2.increment()); // 2
console.log(counter1.getCount()); // 2
console.log(counter2.getCount()); // 2
```

## 2.6 模块作用域

每个模块都有自己的作用域，在模块中定义的变量、函数和类只在该模块内部可见，不会污染全局作用域。

```javascript
// module1.js
const name = 'Module 1';

module.exports = {
  getName: () => name
};
```

```javascript
// module2.js
const name = 'Module 2';

module.exports = {
  getName: () => name
};
```

```javascript
// app.js
const module1 = require('./module1');
const module2 = require('./module2');

console.log(module1.getName()); // Module 1
console.log(module2.getName()); // Module 2
console.log(name); // ReferenceError: name is not defined
```

## 2.7 模块间通信

### 2.7.1 通过导出和导入通信

这是最常见的模块间通信方式，通过导出模块的功能，然后在其他模块中导入使用。

### 2.7.2 通过全局对象通信

虽然不推荐，但可以通过`global`对象在模块间共享数据。

```javascript
// module1.js
global.sharedData = 'Hello from module 1';
```

```javascript
// module2.js
console.log(global.sharedData); // Hello from module 1
```

### 2.7.3 通过事件发射器通信

使用Node.js的`EventEmitter`类来实现模块间的事件通信。

```javascript
// eventBus.js
const EventEmitter = require('node:events');

module.exports = new EventEmitter();
```

```javascript
// module1.js
const eventBus = require('./eventBus');

setTimeout(() => {
  eventBus.emit('message', 'Hello from module 1');
}, 1000);
```

```javascript
// module2.js
const eventBus = require('./eventBus');

eventBus.on('message', (message) => {
  console.log(message); // Hello from module 1
});
```

## 2.8 最佳实践

### 2.8.1 模块设计原则

- **单一职责原则**：每个模块只负责一个特定的功能
- **高内聚低耦合**：模块内部的功能应该紧密相关，模块之间的依赖关系应该尽量简单
- **接口清晰**：模块的导出应该清晰明了，便于其他模块使用
- **避免循环依赖**：尽量避免模块之间的循环依赖，否则可能导致模块加载失败

### 2.8.2 命名规范

- 模块文件名应该使用小写字母，多个单词之间使用连字符（-）或下划线（_）分隔
- 模块名应该清晰地表达模块的功能
- 避免使用保留字作为模块名

### 2.8.3 目录结构

- 将相关的模块组织到同一个目录中
- 使用`index.js`或`index.mjs`作为目录的入口文件
- 合理划分模块的层次结构，便于维护和扩展

## 2.9 实践练习

1. 创建一个包含多个函数的数学模块，导出并在另一个文件中使用
2. 使用ES模块系统创建一个工具模块，包含日期格式化、字符串处理等功能
3. 实现一个简单的事件总线模块，用于模块间通信
4. 创建一个配置模块，用于加载和管理应用的配置信息
5. 设计一个模块化的日志系统，支持不同级别的日志输出

通过以上练习，你将掌握Node.js模块化系统的核心概念和使用方法，能够设计和实现模块化的Node.js应用。