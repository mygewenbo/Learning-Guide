# 子进程与集群

## 1. 子进程基础

Node.js 是单线程的，但它提供了 `child_process` 模块，允许创建子进程来执行外部命令或 Node.js 脚本。

### 1.1 子进程的类型

Node.js 提供了四种创建子进程的方法：

- **spawn()**：适用于需要处理大量数据的场景，返回一个带有流接口的子进程对象。
- **exec()**：适用于执行简单命令并获取输出，返回一个带有回调接口的子进程对象。
- **execFile()**：类似于 `exec()`，但直接执行可执行文件，不通过 shell。
- **fork()**：专门用于创建 Node.js 子进程，内置了 IPC 通信通道。

### 1.2 spawn() 方法

```javascript
import { spawn } from 'node:child_process';

// 执行 ls 命令
const ls = spawn('ls', ['-lh', '/usr']);

// 监听 stdout 事件
ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

// 监听 stderr 事件
ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

// 监听 close 事件
ls.on('close', (code) => {
  console.log(`子进程退出，退出码: ${code}`);
});
```

### 1.3 exec() 方法

```javascript
import { exec } from 'node:child_process';

// 执行 shell 命令
exec('ls -lh /usr', (error, stdout, stderr) => {
  if (error) {
    console.error(`执行错误: ${error}`);
    return;
  }
  console.log(`stdout: ${stdout}`);
  if (stderr) {
    console.error(`stderr: ${stderr}`);
  }
});
```

### 1.4 execFile() 方法

```javascript
import { execFile } from 'node:child_process';

// 直接执行可执行文件
execFile('node', ['--version'], (error, stdout, stderr) => {
  if (error) {
    throw error;
  }
  console.log(`Node 版本: ${stdout}`);
});
```

### 1.5 fork() 方法

```javascript
import { fork } from 'node:child_process';

// 创建 Node.js 子进程
const child = fork('worker.js');

// 监听子进程消息
child.on('message', (msg) => {
  console.log('来自子进程的消息:', msg);
});

// 向子进程发送消息
child.send({ task: 'process', data: [1, 2, 3, 4, 5] });

// 监听子进程退出
child.on('exit', (code) => {
  console.log(`子进程退出，退出码: ${code}`);
});
```

## 2. 子进程通信

### 2.1 IPC 通信

当使用 `fork()` 创建子进程时，父进程和子进程之间会建立一个 IPC（进程间通信）通道，允许它们通过 `send()` 方法和 `message` 事件进行通信。

**父进程 (parent.js)：**

```javascript
import { fork } from 'node:child_process';

const child = fork('child.js');

child.on('message', (msg) => {
  console.log('父进程收到:', msg);
  if (msg.type === 'result') {
    console.log('计算结果:', msg.data);
    child.kill(); // 结束子进程
  }
});

child.send({ type: 'task', data: [1, 2, 3, 4, 5] });
```

**子进程 (child.js)：**

```javascript
// 监听父进程消息
process.on('message', (msg) => {
  if (msg.type === 'task') {
    console.log('子进程收到任务:', msg.data);
    // 执行计算
    const result = msg.data.reduce((sum, num) => sum + num, 0);
    // 向父进程发送结果
    process.send({ type: 'result', data: result });
  }
});

// 监听退出信号
process.on('SIGTERM', () => {
  console.log('子进程收到退出信号');
  process.exit(0);
});
```

### 2.2 流通信

使用 `spawn()` 创建的子进程，可以通过流进行通信：

```javascript
import { spawn } from 'node:child_process';

const child = spawn('node', ['-i']); // 启动 Node.js 交互式解释器

// 向子进程发送数据
child.stdin.write('console.log("Hello from parent process");\n');
child.stdin.write('process.exit();\n');

// 读取子进程输出
child.stdout.on('data', (data) => {
  console.log(`子进程输出: ${data}`);
});

child.on('close', (code) => {
  console.log(`子进程退出，退出码: ${code}`);
});
```

## 3. 子进程管理

### 3.1 子进程选项

创建子进程时，可以传递一些选项来控制子进程的行为：

```javascript
import { spawn } from 'node:child_process';

const child = spawn('node', ['script.js'], {
  cwd: '/path/to/working/dir', // 工作目录
  env: { ...process.env, NODE_ENV: 'production' }, // 环境变量
  stdio: 'inherit', // 共享标准输入输出
  detached: true, // 独立进程
  shell: true // 使用 shell 执行
});
```

### 3.2 子进程同步方法

`child_process` 模块还提供了同步版本的方法：

```javascript
import { spawnSync, execSync, execFileSync } from 'node:child_process';

// 同步执行命令
const result = spawnSync('ls', ['-lh', '/usr']);
console.log(`stdout: ${result.stdout}`);
console.log(`stderr: ${result.stderr}`);
console.log(`退出码: ${result.status}`);

// 同步执行 shell 命令
const output = execSync('ls -lh /usr');
console.log(`输出: ${output}`);

// 同步执行可执行文件
const version = execFileSync('node', ['--version']);
console.log(`Node 版本: ${version}`);
```

### 3.3 子进程信号处理

可以使用 `kill()` 方法向子进程发送信号：

```javascript
import { spawn } from 'node:child_process';

const child = spawn('node', ['long-running-script.js']);

// 5秒后向子进程发送 SIGTERM 信号
setTimeout(() => {
  child.kill('SIGTERM');
}, 5000);

// 或者发送 SIGKILL 信号（强制终止）
// child.kill('SIGKILL');
```

## 4. 集群模块

Node.js 提供了 `cluster` 模块，允许创建多个 Node.js 进程来共享同一个端口，从而充分利用多核 CPU。

### 4.1 集群基础

```javascript
import cluster from 'node:cluster';
import http from 'node:http';
import { availableParallelism } from 'node:os';
import process from 'node:process';

const numCPUs = availableParallelism();

if (cluster.isPrimary) {
  console.log(`主进程 ${process.pid} 正在运行`);

  // 创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // 监听工作进程退出事件
  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 退出`);
    // 重启退出的工作进程
    console.log('重启工作进程...');
    cluster.fork();
  });
} else {
  // 工作进程可以共享任何 TCP 连接
  // 这里是一个 HTTP 服务器
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Hello World from worker ${process.pid}\n`);
  }).listen(8000);

  console.log(`工作进程 ${process.pid} 已启动`);
}
```

### 4.2 集群事件

`cluster` 模块提供了一些事件来监控集群的状态：

- **fork**：当创建一个新的工作进程时触发。
- **online**：当工作进程发送在线消息时触发。
- **listening**：当工作进程调用 `listen()` 方法时触发。
- **disconnect**：当工作进程断开连接时触发。
- **exit**：当工作进程退出时触发。
- **setup**：当调用 `setupPrimary()` 方法时触发。

```javascript
cluster.on('fork', (worker) => {
  console.log(`创建工作进程: ${worker.id}`);
});

cluster.on('online', (worker) => {
  console.log(`工作进程 ${worker.id} 已上线`);
});

cluster.on('listening', (worker, address) => {
  console.log(`工作进程 ${worker.id} 正在监听 ${address.address}:${address.port}`);
});

cluster.on('disconnect', (worker) => {
  console.log(`工作进程 ${worker.id} 已断开连接`);
});
```

### 4.3 工作进程通信

主进程和工作进程之间可以通过 `send()` 方法和 `message` 事件进行通信：

```javascript
if (cluster.isPrimary) {
  const worker = cluster.fork();
  
  worker.send({ type: 'greeting', message: 'Hello from primary' });
  
  worker.on('message', (msg) => {
    console.log(`主进程收到来自工作进程 ${worker.id} 的消息:`, msg);
  });
} else {
  process.on('message', (msg) => {
    console.log(`工作进程 ${process.pid} 收到消息:`, msg);
    process.send({ type: 'response', message: 'Hello from worker' });
  });
}
```

## 5. 集群调度策略

### 5.1 轮询调度

默认情况下，Node.js 使用轮询调度策略来分发连接，主进程负责接受连接，然后将它们分发给工作进程。

### 5.2 共享句柄

在某些平台上，Node.js 会使用共享句柄的方式，让工作进程直接接受连接，而不需要主进程转发。

### 5.3 自定义调度

可以通过设置 `cluster.schedulingPolicy` 来改变调度策略：

```javascript
import cluster from 'node:cluster';

// 设置调度策略为轮询
cluster.schedulingPolicy = cluster.SCHED_RR;

// 或者设置为共享句柄
// cluster.schedulingPolicy = cluster.SCHED_NONE;
```

## 6. 高级集群管理

### 6.1 优雅关闭

实现工作进程的优雅关闭，确保正在处理的请求能够完成：

```javascript
if (cluster.isPrimary) {
  // 主进程代码...
} else {
  const server = http.createServer((req, res) => {
    // 模拟耗时请求
    setTimeout(() => {
      res.writeHead(200);
      res.end(`Hello from worker ${process.pid}\n`);
    }, 1000);
  });

  server.listen(8000);

  // 监听关闭信号
  process.on('SIGTERM', async () => {
    console.log(`工作进程 ${process.pid} 收到关闭信号`);
    
    // 停止接受新连接
    await server.close();
    
    console.log(`工作进程 ${process.pid} 已关闭所有连接`);
    process.exit(0);
  });
}
```

### 6.2 工作进程状态监控

监控工作进程的状态，及时发现并处理异常：

```javascript
if (cluster.isPrimary) {
  const workers = [];
  const numCPUs = availableParallelism();
  
  // 创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    const worker = cluster.fork();
    workers.push({
      id: worker.id,
      process: worker,
      lastHeartbeat: Date.now()
    });
  }
  
  // 监听工作进程消息
  cluster.on('message', (worker, msg) => {
    if (msg.type === 'heartbeat') {
      const workerInfo = workers.find(w => w.id === worker.id);
      if (workerInfo) {
        workerInfo.lastHeartbeat = Date.now();
      }
    }
  });
  
  // 定期检查工作进程心跳
  setInterval(() => {
    const now = Date.now();
    workers.forEach(workerInfo => {
      // 如果超过 5 秒没有收到心跳，认为工作进程异常
      if (now - workerInfo.lastHeartbeat > 5000) {
        console.log(`工作进程 ${workerInfo.id} 心跳超时，重启...`);
        workerInfo.process.kill();
        const newWorker = cluster.fork();
        // 更新工作进程信息
        Object.assign(workerInfo, {
          id: newWorker.id,
          process: newWorker,
          lastHeartbeat: Date.now()
        });
      }
    });
  }, 1000);
} else {
  // 工作进程定期发送心跳
  setInterval(() => {
    process.send({ type: 'heartbeat' });
  }, 1000);
  
  // 其他工作进程代码...
}
```

## 7. 实际应用场景

### 7.1 执行外部命令

```javascript
import { spawn } from 'node:child_process';
import fs from 'node:fs';

// 使用 ffmpeg 转换视频格式
function convertVideo(inputPath, outputPath) {
  return new Promise((resolve, reject) => {
    const ffmpeg = spawn('ffmpeg', ['-i', inputPath, '-c:v', 'libx264', '-c:a', 'aac', outputPath]);
    
    ffmpeg.stdout.on('data', (data) => {
      console.log(`ffmpeg stdout: ${data}`);
    });
    
    ffmpeg.stderr.on('data', (data) => {
      console.error(`ffmpeg stderr: ${data}`);
    });
    
    ffmpeg.on('close', (code) => {
      if (code === 0) {
        resolve(outputPath);
      } else {
        reject(new Error(`ffmpeg 退出码: ${code}`));
      }
    });
  });
}

// 使用示例
convertVideo('input.mp4', 'output.mp4')
  .then((outputPath) => {
    console.log(`视频转换成功: ${outputPath}`);
  })
  .catch((error) => {
    console.error('视频转换失败:', error);
  });
```

### 7.2 并行处理任务

```javascript
import { fork } from 'node:child_process';

// 并行处理多个任务
function parallelProcess(tasks, workerPath) {
  return new Promise((resolve) => {
    const results = [];
    let completed = 0;
    
    tasks.forEach((task, index) => {
      const worker = fork(workerPath);
      
      worker.on('message', (msg) => {
        if (msg.type === 'result') {
          results[index] = msg.data;
          completed++;
          worker.kill();
          
          if (completed === tasks.length) {
            resolve(results);
          }
        }
      });
      
      worker.send({ type: 'task', data: task });
    });
  });
}

// 使用示例
const tasks = [
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10],
  [11, 12, 13, 14, 15]
];

parallelProcess(tasks, 'worker.js')
  .then((results) => {
    console.log('所有任务完成，结果:', results);
  });
```

### 7.3 构建 Web 服务器集群

```javascript
import cluster from 'node:cluster';
import http from 'node:http';
import { availableParallelism } from 'node:os';
import process from 'node:process';

if (cluster.isPrimary) {
  const numCPUs = availableParallelism();
  console.log(`主进程 ${process.pid} 启动，创建 ${numCPUs} 个工作进程`);
  
  // 创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // 监听工作进程退出
  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 退出，退出码: ${code}, 信号: ${signal}`);
    console.log('重启工作进程...');
    cluster.fork();
  });
  
  // 监听 SIGTERM 信号，优雅关闭所有工作进程
  process.on('SIGTERM', () => {
    console.log('主进程收到关闭信号，正在关闭所有工作进程...');
    const workers = Object.values(cluster.workers);
    
    let closedWorkers = 0;
    
    workers.forEach(worker => {
      worker.on('exit', () => {
        closedWorkers++;
        if (closedWorkers === workers.length) {
          console.log('所有工作进程已关闭，主进程退出');
          process.exit(0);
        }
      });
      
      worker.send({ type: 'shutdown' });
    });
  });
} else {
  const server = http.createServer((req, res) => {
    // 模拟耗时请求
    setTimeout(() => {
      res.writeHead(200, { 'Content-Type': 'text/plain' });
      res.end(`Hello from worker ${process.pid}\n`);
    }, 100);
  });
  
  server.listen(8000, () => {
    console.log(`工作进程 ${process.pid} 正在监听端口 8000`);
  });
  
  // 监听关闭信号
  process.on('message', (msg) => {
    if (msg.type === 'shutdown') {
      console.log(`工作进程 ${process.pid} 收到关闭信号`);
      
      // 停止接受新连接
      server.close(() => {
        console.log(`工作进程 ${process.pid} 已关闭所有连接`);
        process.exit(0);
      });
    }
  });
}
```

## 8. 最佳实践

1. **合理使用子进程**：只在必要时使用子进程，避免不必要的资源消耗。
2. **限制子进程数量**：根据系统 CPU 核心数来决定子进程数量，一般不超过核心数的 2 倍。
3. **优雅关闭**：实现子进程的优雅关闭，确保正在处理的任务能够完成。
4. **错误处理**：妥善处理子进程的错误，避免整个应用崩溃。
5. **监控子进程**：监控子进程的状态，及时发现并处理异常情况。
6. **使用 PM2**：考虑使用 PM2 等进程管理工具来管理 Node.js 应用，它提供了自动重启、负载均衡、监控等功能。
7. **避免共享状态**：子进程之间尽量避免共享状态，使用消息传递来通信。
8. **使用 TypeScript**：TypeScript 可以提供更好的类型检查和编辑器支持。

## 9. 总结

子进程和集群是 Node.js 中实现并行处理和负载均衡的重要机制。通过掌握这些高级特性，你可以编写更加高效、可靠的 Node.js 应用程序。

- `child_process` 模块允许创建子进程来执行外部命令或 Node.js 脚本。
- 子进程之间可以通过 IPC 通道或流进行通信。
- `cluster` 模块允许创建多个 Node.js 进程来共享同一个端口，充分利用多核 CPU。
- 集群提供了自动负载均衡和故障恢复功能。
- 合理使用子进程和集群可以提高应用的性能和可靠性。

通过不断实践和学习，你将能够熟练运用子进程和集群技术，构建高性能、可扩展的 Node.js 应用。