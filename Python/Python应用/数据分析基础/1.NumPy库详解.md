# NumPy库详解

## 一、NumPy库简介

NumPy（Numerical Python）是Python科学计算的基础库，提供了高性能的多维数组对象和丰富的数学函数库。它是数据分析、机器学习、科学计算等领域的核心依赖库。

### 1.1 NumPy的核心优势

- **高效的多维数组对象**：`ndarray`是NumPy的核心数据结构，提供了高效的存储和操作多维数据的能力
- **矢量化运算**：支持数组之间的直接运算，无需显式循环，提高了代码的可读性和执行效率
- **丰富的数学函数库**：包含线性代数、傅里叶变换、随机数生成等多种数学运算功能
- **C语言实现**：底层核心代码使用C语言实现，保证了高性能
- **广泛的生态系统**：是Pandas、Matplotlib、SciPy等库的基础

### 1.2 安装NumPy

```bash
pip install numpy
```

### 1.3 导入NumPy

```python
import numpy as np
```

## 二、NumPy数组基础

### 2.1 创建NumPy数组

#### 2.1.1 从Python列表创建

```python
# 创建一维数组
arr1 = np.array([1, 2, 3, 4, 5])
print(arr1)  # 输出: [1 2 3 4 5]

# 创建二维数组
arr2 = np.array([[1, 2, 3], [4, 5, 6]])
print(arr2)  # 输出: [[1 2 3]
             #         [4 5 6]]

# 创建三维数组
arr3 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(arr3)  # 输出: [[[1 2]
             #         [3 4]]
             #        [[5 6]
             #         [7 8]]]
```

#### 2.1.2 使用NumPy内置函数创建

```python
# 创建全零数组
zeros = np.zeros((2, 3))
print(zeros)  # 输出: [[0. 0. 0.]
              #         [0. 0. 0.]]

# 创建全一数组
ones = np.ones((3, 2))
print(ones)  # 输出: [[1. 1.]
             #         [1. 1.]
             #         [1. 1.]]

# 创建单位矩阵
eye = np.eye(3)
print(eye)  # 输出: [[1. 0. 0.]
            #         [0. 1. 0.]
            #         [0. 0. 1.]]

# 创建等差数列
arange = np.arange(0, 10, 2)
print(arange)  # 输出: [0 2 4 6 8]

# 创建等间隔数列
linspace = np.linspace(0, 1, 5)
print(linspace)  # 输出: [0.   0.25 0.5  0.75 1.  ]

# 创建随机数组
random = np.random.rand(2, 3)
print(random)  # 输出: [[0.12345678 0.98765432 0.54321098]
               #         [0.23456789 0.87654321 0.65432109]]
```

### 2.2 数组属性

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

print(arr.ndim)  # 数组维度: 2
print(arr.shape)  # 数组形状: (2, 3)
print(arr.size)  # 数组元素总数: 6
print(arr.dtype)  # 元素数据类型: int64
print(arr.itemsize)  # 每个元素的字节大小: 8
print(arr.nbytes)  # 数组总字节大小: 48
```

### 2.3 数组数据类型

```python
# 指定数据类型创建数组
arr_int = np.array([1, 2, 3], dtype=np.int32)
arr_float = np.array([1, 2, 3], dtype=np.float64)
arr_complex = np.array([1, 2, 3], dtype=np.complex128)

print(arr_int.dtype)  # 输出: int32
print(arr_float.dtype)  # 输出: float64
print(arr_complex.dtype)  # 输出: complex128

# 转换数据类型
arr = np.array([1, 2, 3])
arr_float = arr.astype(np.float64)
print(arr_float.dtype)  # 输出: float64
```

## 三、NumPy数组操作

### 3.1 数组索引与切片

#### 3.1.1 一维数组索引与切片

```python
arr = np.arange(10)

print(arr[0])  # 第一个元素: 0
print(arr[-1])  # 最后一个元素: 9
print(arr[2:5])  # 切片: [2 3 4]
print(arr[:5])  # 前5个元素: [0 1 2 3 4]
print(arr[5:])  # 从第6个元素开始: [5 6 7 8 9]
print(arr[::2])  # 步长为2: [0 2 4 6 8]
print(arr[::-1])  # 反转数组: [9 8 7 6 5 4 3 2 1 0]
```

#### 3.1.2 二维数组索引与切片

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print(arr[0, 0])  # 第一行第一列: 1
print(arr[1, 2])  # 第二行第三列: 6
print(arr[0, :])  # 第一行: [1 2 3]
print(arr[:, 0])  # 第一列: [1 4 7]
print(arr[1:3, 1:3])  # 切片: [[5 6]
                       #         [8 9]]
```

#### 3.1.3 布尔索引

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# 创建布尔掩码
mask = arr > 5
print(mask)  # 输出: [[False False False]
             #         [False False  True]
             #         [ True  True  True]]

# 使用布尔掩码索引
print(arr[mask])  # 输出: [6 7 8 9]

# 直接在索引中使用条件
print(arr[arr > 5])  # 输出: [6 7 8 9]
```

#### 3.1.4 整数数组索引

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# 整数数组索引
print(arr[[0, 1, 2], [0, 1, 2]])  # 输出: [1 5 9]
print(arr[[0, 2], [1, 1]])  # 输出: [2 8]
```

### 3.2 数组形状操作

#### 3.2.1 重塑数组

```python
arr = np.arange(12)
print(arr.shape)  # 输出: (12,)

# 重塑为2行6列
arr_2d = arr.reshape(2, 6)
print(arr_2d.shape)  # 输出: (2, 6)

# 重塑为3行4列
arr_3d = arr.reshape(3, 4)
print(arr_3d.shape)  # 输出: (3, 4)

# 使用-1自动计算维度
arr_auto = arr.reshape(3, -1)
print(arr_auto.shape)  # 输出: (3, 4)
```

#### 3.2.2 转置数组

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.shape)  # 输出: (2, 3)

# 转置数组
arr_transposed = arr.T
print(arr_transposed.shape)  # 输出: (3, 2)
print(arr_transposed)  # 输出: [[1 4]
                        #         [2 5]
                        #         [3 6]]
```

#### 3.2.3 展平数组

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# 展平数组（行优先）
arr_flat = arr.flatten()
print(arr_flat)  # 输出: [1 2 3 4 5 6]

# 展平数组（列优先）
arr_flat_f = arr.flatten('F')
print(arr_flat_f)  # 输出: [1 4 2 5 3 6]

# 使用ravel展平数组（返回视图）
arr_ravel = arr.ravel()
print(arr_ravel)  # 输出: [1 2 3 4 5 6]
```

### 3.3 数组拼接与分割

#### 3.3.1 数组拼接

```python
# 垂直拼接（行方向）
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([[7, 8, 9], [10, 11, 12]])

arr_vstack = np.vstack((arr1, arr2))
print(arr_vstack)  # 输出: [[ 1  2  3]
                   #         [ 4  5  6]
                   #         [ 7  8  9]
                   #         [10 11 12]]

# 水平拼接（列方向）
arr_hstack = np.hstack((arr1, arr2))
print(arr_hstack)  # 输出: [[ 1  2  3  7  8  9]
                   #         [ 4  5  6 10 11 12]]

# 使用concatenate拼接
arr_concat_v = np.concatenate((arr1, arr2), axis=0)  # 垂直拼接
arr_concat_h = np.concatenate((arr1, arr2), axis=1)  # 水平拼接
```

#### 3.3.2 数组分割

```python
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

# 垂直分割（行方向）
arr_vsplit = np.vsplit(arr, 3)
print(arr_vsplit)  # 输出: [array([[1, 2, 3, 4]]), array([[5, 6, 7, 8]]), array([[9, 10, 11, 12]])]

# 水平分割（列方向）
arr_hsplit = np.hsplit(arr, 2)
print(arr_hsplit)  # 输出: [array([[ 1,  2],
                   #         [ 5,  6],
                   #         [ 9, 10]]), array([[ 3,  4],
                   #         [ 7,  8],
                   #         [11, 12]])]

# 使用split分割
arr_split_v = np.split(arr, 3, axis=0)  # 垂直分割
arr_split_h = np.split(arr, 2, axis=1)  # 水平分割
```

### 3.4 数组复制

```python
arr = np.array([1, 2, 3, 4, 5])

# 浅拷贝（视图）
arr_view = arr.view()
arr[0] = 100
print(arr)  # 输出: [100   2   3   4   5]
print(arr_view)  # 输出: [100   2   3   4   5]

# 深拷贝
arr_copy = arr.copy()
arr[1] = 200
print(arr)  # 输出: [100 200   3   4   5]
print(arr_copy)  # 输出: [100   2   3   4   5]
```

## 四、NumPy数学运算

### 4.1 基本数学运算

```python
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([6, 7, 8, 9, 10])

# 加法
print(arr1 + arr2)  # 输出: [ 7  9 11 13 15]
print(np.add(arr1, arr2))  # 输出: [ 7  9 11 13 15]

# 减法
print(arr2 - arr1)  # 输出: [5 5 5 5 5]
print(np.subtract(arr2, arr1))  # 输出: [5 5 5 5 5]

# 乘法
print(arr1 * arr2)  # 输出: [ 6 14 24 36 50]
print(np.multiply(arr1, arr2))  # 输出: [ 6 14 24 36 50]

# 除法
print(arr2 / arr1)  # 输出: [6.         3.5        2.66666667 2.25       2.        ]
print(np.divide(arr2, arr1))  # 输出: [6.         3.5        2.66666667 2.25       2.        ]

# 取余
print(arr2 % arr1)  # 输出: [0 1 2 1 0]
print(np.mod(arr2, arr1))  # 输出: [0 1 2 1 0]

# 幂运算
print(arr1 ** 2)  # 输出: [ 1  4  9 16 25]
print(np.power(arr1, 2))  # 输出: [ 1  4  9 16 25]
```

### 4.2 广播机制

```python
# 标量与数组运算
arr = np.array([1, 2, 3, 4, 5])
print(arr + 5)  # 输出: [ 6  7  8  9 10]
print(arr * 2)  # 输出: [ 2  4  6  8 10]

# 不同形状数组运算
arr1 = np.array([[1, 2, 3], [4, 5, 6]])  # 形状(2, 3)
arr2 = np.array([10, 20, 30])  # 形状(3,)
print(arr1 + arr2)  # 输出: [[11 22 33]
                    #         [14 25 36]]

# 广播规则示例
arr3 = np.array([[1], [2], [3]])  # 形状(3, 1)
arr4 = np.array([10, 20, 30])  # 形状(3,)
print(arr3 + arr4)  # 输出: [[11 21 31]
                    #         [12 22 32]
                    #         [13 23 33]]
```

### 4.3 统计函数

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# 求和
print(np.sum(arr))  # 总和: 45
print(np.sum(arr, axis=0))  # 按列求和: [12 15 18]
print(np.sum(arr, axis=1))  # 按行求和: [ 6 15 24]

# 平均值
print(np.mean(arr))  # 平均值: 5.0
print(np.mean(arr, axis=0))  # 按列求平均值: [4. 5. 6.]
print(np.mean(arr, axis=1))  # 按行求平均值: [2. 5. 8.]

# 中位数
print(np.median(arr))  # 中位数: 5.0
print(np.median(arr, axis=0))  # 按列求中位数: [4. 5. 6.]
print(np.median(arr, axis=1))  # 按行求中位数: [2. 5. 8.]

# 标准差
print(np.std(arr))  # 标准差: 2.581988897471611
print(np.std(arr, axis=0))  # 按列求标准差: [2.44948974 2.44948974 2.44948974]
print(np.std(arr, axis=1))  # 按行求标准差: [0.81649658 0.81649658 0.81649658]

# 方差
print(np.var(arr))  # 方差: 6.666666666666667
print(np.var(arr, axis=0))  # 按列求方差: [6. 6. 6.]
print(np.var(arr, axis=1))  # 按行求方差: [0.66666667 0.66666667 0.66666667]

# 最大值
print(np.max(arr))  # 最大值: 9
print(np.max(arr, axis=0))  # 按列求最大值: [7 8 9]
print(np.max(arr, axis=1))  # 按行求最大值: [3 6 9]

# 最小值
print(np.min(arr))  # 最小值: 1
print(np.min(arr, axis=0))  # 按列求最小值: [1 2 3]
print(np.min(arr, axis=1))  # 按行求最小值: [1 4 7]

# 最大值索引
print(np.argmax(arr))  # 最大值索引: 8
print(np.argmax(arr, axis=0))  # 按列求最大值索引: [2 2 2]
print(np.argmax(arr, axis=1))  # 按行求最大值索引: [2 2 2]

# 最小值索引
print(np.argmin(arr))  # 最小值索引: 0
print(np.argmin(arr, axis=0))  # 按列求最小值索引: [0 0 0]
print(np.argmin(arr, axis=1))  # 按行求最小值索引: [0 0 0]
```

### 4.4 线性代数运算

```python
# 矩阵乘法
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])
print(np.dot(arr1, arr2))  # 输出: [[19 22]
                           #         [43 50]]
print(arr1 @ arr2)  # 输出: [[19 22]
                    #         [43 50]]

# 矩阵转置
print(arr1.T)  # 输出: [[1 3]
               #         [2 4]]

# 矩阵求逆
arr_inv = np.linalg.inv(arr1)
print(arr_inv)  # 输出: [[-2.   1. ]
                #         [ 1.5 -0.5]]

# 行列式
print(np.linalg.det(arr1))  # 输出: -2.0

# 特征值和特征向量
eigenvalues, eigenvectors = np.linalg.eig(arr1)
print(eigenvalues)  # 输出: [-0.37228132  5.37228132]
print(eigenvectors)  # 输出: [[-0.82456484 -0.41597356]
                     #         [ 0.56576746 -0.90937671]]

# 奇异值分解
u, s, vh = np.linalg.svd(arr1)
print(u)  # 输出: [[-0.40455358 -0.9145143 ]
          #         [-0.9145143   0.40455358]]
print(s)  # 输出: [5.4649857  0.36596619]
print(vh)  # 输出: [[-0.57604844 -0.81741556]
           #         [ 0.81741556 -0.57604844]]

# 解线性方程组
A = np.array([[1, 2], [3, 4]])
b = np.array([5, 6])
x = np.linalg.solve(A, b)
print(x)  # 输出: [-4.   4.5]
```

### 4.5 三角函数

```python
# 角度转弧度
degrees = np.array([0, 30, 45, 60, 90])
radians = np.radians(degrees)
print(radians)  # 输出: [0.         0.52359878 0.78539816 1.04719755 1.57079633]

# 正弦函数
print(np.sin(radians))  # 输出: [0.00000000e+00 5.00000000e-01 7.07106781e-01 8.66025404e-01 1.00000000e+00]

# 余弦函数
print(np.cos(radians))  # 输出: [1.00000000e+00 8.66025404e-01 7.07106781e-01 5.00000000e-01 6.12323400e-17]

# 正切函数
print(np.tan(radians))  # 输出: [0.00000000e+00 5.77350269e-01 1.00000000e+00 1.73205081e+00 1.63312394e+16]

# 反三角函数
print(np.arcsin(0.5))  # 输出: 0.5235987755982989
print(np.arccos(0.5))  # 输出: 1.0471975511965976
print(np.arctan(1))  # 输出: 0.7853981633974483
```

### 4.6 指数和对数函数

```python
arr = np.array([1, 2, 3, 4, 5])

# 指数函数
print(np.exp(arr))  # 输出: [  2.71828183   7.3890561   20.08553692  54.59815003 148.4131591 ]

# 自然对数
print(np.log(arr))  # 输出: [0.         0.69314718 1.09861229 1.38629436 1.60943791]

# 以10为底的对数
print(np.log10(arr))  # 输出: [0.         0.30103    0.47712125 0.60205999 0.69897   ]

# 以2为底的对数
print(np.log2(arr))  # 输出: [0.         1.         1.5849625  2.         2.32192809]

# 平方根
print(np.sqrt(arr))  # 输出: [1.         1.41421356 1.73205081 2.         2.23606798]

# 立方根
print(np.cbrt(arr))  # 输出: [1.         1.25992105 1.44224957 1.58740105 1.70997595]
```

## 五、NumPy高级功能

### 5.1 通用函数（ufunc）

```python
# 创建自定义ufunc
def my_func(x, y):
    return x * y + x + y

my_ufunc = np.frompyfunc(my_func, 2, 1)

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
print(my_ufunc(arr1, arr2))  # 输出: [9 17 27]

# 使用np.vectorize创建向量化函数
vectorized_func = np.vectorize(my_func)
print(vectorized_func(arr1, arr2))  # 输出: [9 17 27]
```

### 5.2 广播规则

NumPy的广播规则允许不同形状的数组进行算术运算，遵循以下规则：

1. 如果两个数组的维度数不同，维度较少的数组会在前面补1
2. 如果两个数组在某个维度上的大小不同，且其中一个数组在该维度上的大小为1，则会将其扩展为与另一个数组相同的大小
3. 如果两个数组在某个维度上的大小不同，且都不为1，则会引发错误

```python
# 广播规则示例1
arr1 = np.array([[1, 2, 3], [4, 5, 6]])  # 形状(2, 3)
arr2 = np.array([10, 20, 30])  # 形状(3,)
# arr2广播为形状(2, 3)
result = arr1 + arr2
print(result)  # 输出: [[11 22 33]
               #         [14 25 36]]

# 广播规则示例2
arr3 = np.array([[1], [2], [3]])  # 形状(3, 1)
arr4 = np.array([10, 20, 30])  # 形状(3,)
# arr3广播为形状(3, 3)，arr4广播为形状(3, 3)
result = arr3 + arr4
print(result)  # 输出: [[11 21 31]
               #         [12 22 32]
               #         [13 23 33]]
```

### 5.3 内存映射数组

内存映射数组允许将大文件映射到内存中，以便可以像访问常规NumPy数组一样访问文件内容，而无需将整个文件加载到内存中。

```python
# 创建内存映射数组
mmap = np.memmap('large_array.dat', dtype='float64', mode='w+', shape=(10000, 10000))

# 写入数据
mmap[:100, :100] = np.random.rand(100, 100)

# 读取数据
print(mmap[:5, :5])

# 关闭内存映射
mmap.flush()
del mmap

# 重新打开内存映射数组
mmap_read = np.memmap('large_array.dat', dtype='float64', mode='r', shape=(10000, 10000))
print(mmap_read[:5, :5])
del mmap_read
```

### 5.4 结构化数组

结构化数组允许在NumPy数组中存储不同类型的数据，类似于C语言中的结构体。

```python
# 定义结构化数据类型
dt = np.dtype([('name', 'U10'), ('age', 'i4'), ('height', 'f8')])

# 创建结构化数组
people = np.array([('Alice', 25, 1.65), ('Bob', 30, 1.80), ('Charlie', 35, 1.75)], dtype=dt)

# 访问结构化数组
print(people['name'])  # 输出: ['Alice' 'Bob' 'Charlie']
print(people['age'])  # 输出: [25 30 35]
print(people['height'])  # 输出: [1.65 1.8  1.75]

# 访问单个元素
print(people[0])  # 输出: ('Alice', 25, 1.65)
print(people[0]['name'])  # 输出: Alice

# 修改数据
people['age'][1] = 31
print(people['age'])  # 输出: [25 31 35]
```

## 六、NumPy性能优化

### 6.1 使用向量化操作

向量化操作避免了显式的Python循环，利用NumPy的C语言实现提高性能。

```python
import time

# 使用Python循环
start = time.time()
arr = np.arange(1000000)
result = np.zeros_like(arr)
for i in range(len(arr)):
    result[i] = arr[i] * 2 + 1
end = time.time()
print(f"Python循环耗时: {end - start:.6f}秒")

# 使用向量化操作
start = time.time()
result_vectorized = arr * 2 + 1
end = time.time()
print(f"向量化操作耗时: {end - start:.6f}秒")
```

### 6.2 使用NumPy内置函数

NumPy内置函数通常比等效的Python实现更快，因为它们是用C语言编写的。

```python
# 使用Python内置sum
start = time.time()
arr = np.random.rand(1000000)
sum_python = sum(arr)
end = time.time()
print(f"Python内置sum耗时: {end - start:.6f}秒")

# 使用NumPy sum
start = time.time()
sum_numpy = np.sum(arr)
end = time.time()
print(f"NumPy sum耗时: {end - start:.6f}秒")
```

### 6.3 使用视图而非副本

视图共享底层数据，而副本创建新的数据副本，因此视图操作通常更快。

```python
# 创建副本
start = time.time()
arr = np.random.rand(1000000)
arr_copy = arr.copy()
end = time.time()
print(f"创建副本耗时: {end - start:.6f}秒")

# 创建视图
start = time.time()
arr_view = arr.view()
end = time.time()
print(f"创建视图耗时: {end - start:.6f}秒")
```

### 6.4 使用inplace操作

inplace操作直接修改数组，避免创建新的数组，从而节省内存和时间。

```python
# 非inplace操作
start = time.time()
arr = np.random.rand(1000000)
arr = arr * 2 + 1
end = time.time()
print(f"非inplace操作耗时: {end - start:.6f}秒")

# inplace操作
start = time.time()
arr = np.random.rand(1000000)
arr *= 2
arr += 1
end = time.time()
print(f"inplace操作耗时: {end - start:.6f}秒")
```

## 七、NumPy最佳实践

1. **优先使用向量化操作**：避免显式的Python循环，利用NumPy的矢量化运算提高性能
2. **使用NumPy内置函数**：NumPy内置函数通常比等效的Python实现更快
3. **注意数组形状和广播规则**：合理利用广播机制可以简化代码并提高性能
4. **避免不必要的副本**：使用视图而非副本，减少内存占用和提高性能
5. **使用适当的数据类型**：选择合适的数据类型可以减少内存占用和提高性能
6. **利用内存映射处理大文件**：对于大型数据集，使用内存映射数组可以避免将整个文件加载到内存中
7. **使用结构化数组存储混合类型数据**：结构化数组允许在单个数组中存储不同类型的数据
8. **合理使用ufunc**：自定义ufunc可以扩展NumPy的功能，同时保持高性能
9. **注意内存布局**：对于大型数组，考虑使用Fortran顺序（列优先）或C顺序（行优先）来优化内存访问模式
10. **使用NumPy的并行计算功能**：NumPy支持多线程计算，可以通过设置环境变量`OMP_NUM_THREADS`来控制线程数

## 八、NumPy应用实例

### 8.1 图像处理

```python
import matplotlib.pyplot as plt
from matplotlib.image import imread

# 读取图像
img = imread('example.jpg')
print(img.shape)  # 输出: (height, width, channels)

# 显示图像
plt.imshow(img)
plt.axis('off')
plt.show()

# 转换为灰度图像
gray_img = np.mean(img, axis=2)
plt.imshow(gray_img, cmap='gray')
plt.axis('off')
plt.show()

# 图像反转
inverted_img = 255 - img
plt.imshow(inverted_img)
plt.axis('off')
plt.show()

# 图像缩放
scaled_img = img[::2, ::2, :]  # 缩小为原来的1/4
plt.imshow(scaled_img)
plt.axis('off')
plt.show()
```

### 8.2 数据分析

```python
# 生成随机数据
np.random.seed(42)
data = np.random.randn(1000, 3)  # 1000个样本，3个特征

# 计算基本统计信息
print(f"数据形状: {data.shape}")
print(f"均值: {np.mean(data, axis=0)}")
print(f"标准差: {np.std(data, axis=0)}")
print(f"最小值: {np.min(data, axis=0)}")
print(f"最大值: {np.max(data, axis=0)}")

# 数据标准化
mean = np.mean(data, axis=0)
std = np.std(data, axis=0)
normalized_data = (data - mean) / std
print(f"标准化后均值: {np.mean(normalized_data, axis=0)}")
print(f"标准化后标准差: {np.std(normalized_data, axis=0)}")

# 数据降维（主成分分析）
from sklearn.decomposition import PCA
pca = PCA(n_components=2)
reduced_data = pca.fit_transform(normalized_data)
print(f"降维后形状: {reduced_data.shape}")

# 可视化降维后的数据
plt.scatter(reduced_data[:, 0], reduced_data[:, 1], alpha=0.5)
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.title('PCA Reduction')
plt.show()
```

### 8.3 数值计算

```python
# 求解微分方程（欧拉方法）
def euler_method(f, y0, t0, t_end, h):
    t = np.arange(t0, t_end + h, h)
    y = np.zeros(len(t))
    y[0] = y0
    for i in range(len(t) - 1):
        y[i+1] = y[i] + h * f(t[i], y[i])
    return t, y

# 定义微分方程: dy/dt = -y
def f(t, y):
    return -y

# 求解
t, y = euler_method(f, y0=1, t0=0, t_end=5, h=0.1)

# 精确解
y_exact = np.exp(-t)

# 可视化结果
plt.plot(t, y, label='Euler Method')
plt.plot(t, y_exact, label='Exact Solution')
plt.xlabel('t')
plt.ylabel('y')
plt.legend()
plt.title('Euler Method for dy/dt = -y')
plt.show()
```

## 九、总结

NumPy是Python科学计算的基础库，提供了高效的多维数组对象和丰富的数学函数库。通过学习NumPy，你可以掌握：

1. **高效的数组操作**：创建、索引、切片、重塑、拼接等
2. **强大的数学运算**：基本运算、广播机制、统计函数、线性代数等
3. **高级功能**：通用函数、内存映射、结构化数组等
4. **性能优化技巧**：向量化操作、避免不必要的副本、inplace操作等
5. **最佳实践**：合理使用NumPy的各种功能，提高代码的可读性和性能

NumPy是数据分析、机器学习、科学计算等领域的核心依赖库，掌握NumPy将为你进一步学习这些领域打下坚实的基础。

## 十、推荐学习资源

1. **NumPy官方文档**：https://numpy.org/doc/stable/
2. **NumPy官方教程**：https://numpy.org/doc/stable/user/absolute_beginners.html
3. **NumPy for MATLAB Users**：https://numpy.org/doc/stable/user/numpy-for-matlab-users.html
4. **《Python科学计算》**（Travis E. Oliphant）
5. **《利用Python进行数据分析》**（Wes McKinney）
6. **NumPy GitHub仓库**：https://github.com/numpy/numpy
7. **NumPy YouTube教程**：https://www.youtube.com/c/NumPyOfficial

通过结合官方文档、教程和实践项目，你将能够深入掌握NumPy库的使用，为你的Python科学计算之旅打下坚实的基础。