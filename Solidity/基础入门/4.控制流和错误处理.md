# 控制流和错误处理

## 一、控制流语句

### 1.1 条件语句

#### 1.1.1 if-else 语句
- 用于根据条件执行不同的代码块
- 语法：
  ```solidity
  if (condition) {
      // 条件为真时执行
  } else if (anotherCondition) {
      // 另一个条件为真时执行
  } else {
      // 所有条件都为假时执行
  }
  ```
- 示例：
  ```solidity
  function getDiscount(uint256 amount) public pure returns (uint256) {
      if (amount >= 1000) {
          return 20;
      } else if (amount >= 500) {
          return 10;
      } else if (amount >= 100) {
          return 5;
      } else {
          return 0;
      }
  }
  ```

#### 1.1.2 三元运算符
- 用于简洁的条件判断
- 语法：`condition ? valueIfTrue : valueIfFalse`
- 示例：
  ```solidity
  function isEven(uint256 number) public pure returns (bool) {
      return number % 2 == 0 ? true : false;
  }
  ```

### 1.2 循环语句

#### 1.2.1 for 循环
- 用于重复执行固定次数的代码块
- 语法：
  ```solidity
  for (initialization; condition; increment/decrement) {
      // 循环体
  }
  ```
- 示例：
  ```solidity
  function sumArray(uint[] memory array) public pure returns (uint256) {
      uint256 sum = 0;
      for (uint256 i = 0; i < array.length; i++) {
          sum += array[i];
      }
      return sum;
  }
  ```

#### 1.2.2 while 循环
- 用于在条件为真时重复执行代码块
- 语法：
  ```solidity
  while (condition) {
      // 循环体
  }
  ```
- 示例：
  ```solidity
  function factorial(uint256 n) public pure returns (uint256) {
      require(n >= 0, "n must be non-negative");
      
      uint256 result = 1;
      uint256 i = 1;
      
      while (i <= n) {
          result *= i;
          i++;
      }
      
      return result;
  }
  ```

#### 1.2.3 do-while 循环
- 至少执行一次循环体，然后在条件为真时继续执行
- 语法：
  ```solidity
  do {
      // 循环体
  } while (condition);
  ```
- 示例：
  ```solidity
  function findFirstEven(uint[] memory array) public pure returns (uint256) {
      uint256 i = 0;
      do {
          if (array[i] % 2 == 0) {
              return i;
          }
          i++;
      } while (i < array.length);
      
      revert("No even number found");
  }
  ```

### 1.3 循环控制语句

#### 1.3.1 break 语句
- 用于提前退出循环
- 示例：
  ```solidity
  function findValue(uint[] memory array, uint256 target) public pure returns (uint256) {
      for (uint256 i = 0; i < array.length; i++) {
          if (array[i] == target) {
              return i;
          }
      }
      revert("Value not found");
  }
  ```

#### 1.3.2 continue 语句
- 用于跳过当前循环的剩余部分，继续下一次循环
- 示例：
  ```solidity
  function sumEvenNumbers(uint[] memory array) public pure returns (uint256) {
      uint256 sum = 0;
      for (uint256 i = 0; i < array.length; i++) {
          if (array[i] % 2 != 0) {
              continue; // 跳过奇数
          }
          sum += array[i];
      }
      return sum;
  }
  ```

## 二、错误处理

### 2.1 错误处理机制
- Solidity使用状态回滚机制处理错误
- 当发生错误时，所有状态更改都会被回滚
- 错误信息会返回给调用者

### 2.2 错误处理函数

#### 2.2.1 require 函数
- 用于验证条件，如果不满足则回滚交易
- 常用于输入验证和权限检查
- 语法：`require(condition, errorMessage)`
- 示例：
  ```solidity
  function transfer(address to, uint256 amount) public returns (bool) {
      require(to != address(0), "Transfer to zero address");
      require(amount > 0, "Amount must be greater than zero");
      require(balances[msg.sender] >= amount, "Insufficient balance");
      
      balances[msg.sender] -= amount;
      balances[to] += amount;
      
      emit Transfer(msg.sender, to, amount);
      return true;
  }
  ```

#### 2.2.2 revert 函数
- 用于显式回滚交易
- 可以提供自定义错误信息
- 语法：`revert(errorMessage)`
- 示例：
  ```solidity
  function withdraw(uint256 amount) public {
      if (amount > balances[msg.sender]) {
          revert("Insufficient balance for withdrawal");
      }
      
      balances[msg.sender] -= amount;
      payable(msg.sender).transfer(amount);
  }
  ```

#### 2.2.3 assert 函数
- 用于内部错误检查
- 假设条件总是为真，如果为假则回滚
- 语法：`assert(condition)`
- 示例：
  ```solidity
  function updateBalance(address user, uint256 amount) internal {
      balances[user] += amount;
      // 确保余额不会溢出（在Solidity 0.8+中会自动检查）
      assert(balances[user] >= amount);
  }
  ```

### 2.3 自定义错误
- Solidity 0.8.4引入了自定义错误类型
- 更节省gas，支持参数
- 示例：
  ```solidity
  // 定义自定义错误
  error InsufficientBalance(address user, uint256 requested, uint256 available);
  error InvalidAddress(address invalidAddress);
  
  function transfer(address to, uint256 amount) public returns (bool) {
      if (to == address(0)) {
          revert InvalidAddress(to);
      }
      
      if (balances[msg.sender] < amount) {
          revert InsufficientBalance(msg.sender, amount, balances[msg.sender]);
      }
      
      balances[msg.sender] -= amount;
      balances[to] += amount;
      
      emit Transfer(msg.sender, to, amount);
      return true;
  }
  ```

## 三、异常处理最佳实践

### 3.1 何时使用哪种错误处理函数
- **require**：用于输入验证、权限检查、外部调用返回值检查
- **revert**：用于复杂条件检查、显式错误回滚
- **assert**：用于内部不变量检查、防止溢出（在0.8+中已自动处理）
- **自定义错误**：用于需要传递详细错误信息的场景，更节省gas

### 3.2 错误信息的最佳实践
- 错误信息应清晰、简洁
- 包含足够的信息以便调试
- 遵循一致的命名和格式
- 避免在错误信息中包含敏感数据

### 3.3 错误处理的gas优化
- 使用自定义错误比字符串错误信息更节省gas
- 错误处理应放在函数开头，尽早失败
- 避免在循环中进行复杂的错误检查

## 四、实践项目：安全的银行合约

### 4.1 项目概述
- 实现一个安全的银行合约
- 支持存款、取款和转账功能
- 包含全面的错误处理

### 4.2 合约代码
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeBank {
    // 自定义错误
    error InsufficientBalance(address user, uint256 requested, uint256 available);
    error InvalidAddress(address invalidAddress);
    error TransferFailed(address to, uint256 amount);
    
    // 状态变量
    mapping(address => uint256) public balances;
    
    // 事件
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);
    
    // 存款函数
    function deposit() public payable {
        require(msg.value > 0, "Deposit amount must be greater than 0");
        
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // 取款函数
    function withdraw(uint256 amount) public {
        // 检查金额是否大于0
        require(amount > 0, "Withdrawal amount must be greater than 0");
        
        // 检查余额是否充足
        if (balances[msg.sender] < amount) {
            revert InsufficientBalance(msg.sender, amount, balances[msg.sender]);
        }
        
        // 更新余额
        balances[msg.sender] -= amount;
        
        // 执行转账
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        if (!success) {
            revert TransferFailed(msg.sender, amount);
        }
        
        emit Withdrawal(msg.sender, amount);
    }
    
    // 转账函数
    function transfer(address to, uint256 amount) public returns (bool) {
        // 检查目标地址是否有效
        if (to == address(0)) {
            revert InvalidAddress(to);
        }
        
        // 检查金额是否大于0
        require(amount > 0, "Transfer amount must be greater than 0");
        
        // 检查余额是否充足
        if (balances[msg.sender] < amount) {
            revert InsufficientBalance(msg.sender, amount, balances[msg.sender]);
        }
        
        // 更新余额
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    // 获取余额
    function getBalance(address user) public view returns (uint256) {
        return balances[user];
    }
}
```

### 4.3 部署和测试
1. 在Remix中编译合约
2. 部署合约
3. 测试存款功能：
   - 调用`deposit`函数，发送一定数量的以太币
   - 调用`getBalance`函数检查余额
4. 测试转账功能：
   - 调用`transfer`函数向另一个地址转账
   - 检查两个地址的余额
5. 测试错误处理：
   - 尝试向零地址转账
   - 尝试转账超过余额的金额
   - 尝试取款超过余额的金额

## 五、练习

1. 实现一个带有年龄验证的投票合约
2. 编写一个函数，使用循环和条件语句查找数组中的最大值
3. 实现一个安全的代币合约，使用自定义错误
4. 编写一个函数，使用三元运算符判断一个数是否为质数
5. 实现一个带有时间锁的合约，使用条件语句检查时间

## 六、总结

通过本章的学习，你已经掌握了Solidity中的控制流语句和错误处理机制，包括：

- 条件语句（if-else、三元运算符）
- 循环语句（for、while、do-while）
- 循环控制语句（break、continue）
- 错误处理函数（require、revert、assert）
- 自定义错误类型
- 错误处理的最佳实践

这些知识对于编写安全、可靠的智能合约至关重要。在下一章中，我们将学习合约交互的深入知识，包括合约之间的调用、以太币的处理等。