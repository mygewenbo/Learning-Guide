# RESTful API设计

## 一、RESTful API概述

### 1.1 什么是RESTful API

RESTful API（Representational State Transfer）是一种基于REST架构风格的API设计方法。REST是一种软件架构风格，它定义了一组约束条件，用于创建Web服务。

RESTful API使用HTTP协议作为通信协议，利用HTTP方法（GET、POST、PUT、DELETE等）来操作资源，并通过URL来标识资源。

### 1.2 REST的核心原则

1. **资源（Resources）**：一切皆资源，每个资源都有唯一的标识符（URI）
2. **表现层（Representation）**：资源可以有多种表现形式，如JSON、XML等
3. **状态转移（State Transfer）**：通过HTTP方法实现资源状态的转移
4. **无状态（Stateless）**：服务器不保存客户端状态，每个请求都包含完整信息
5. **客户端-服务器架构**：客户端和服务器分离，提高系统的可伸缩性
6. **缓存（Cacheable）**：响应可以被缓存，提高性能
7. **统一接口（Uniform Interface）**：使用统一的接口设计，简化系统架构

### 1.3 RESTful API的优势

1. **简单易用**：使用HTTP协议，无需额外的协议或工具
2. **跨平台兼容**：可以被各种客户端（浏览器、移动应用、桌面应用）访问
3. **可伸缩性**：无状态设计，便于服务器扩展
4. **松耦合**：客户端和服务器分离，便于独立开发和部署
5. **良好的缓存支持**：提高系统性能
6. **易于测试**：可以使用浏览器或简单的HTTP工具进行测试

## 二、RESTful API设计原则

### 2.1 资源命名

资源是RESTful API的核心，资源命名应遵循以下原则：

1. **使用名词，不使用动词**：资源是实体，应该使用名词表示
   - 正确：`/users`、`/products`
   - 错误：`/getUsers`、`/createProduct`

2. **使用复数形式**：资源通常是集合，使用复数形式更符合直觉
   - 正确：`/users`、`/products`
   - 错误：`/user`、`/product`

3. **使用清晰、简洁的名称**：名称应准确描述资源，避免歧义
   - 正确：`/orders`、`/customers`
   - 错误：`/data`、`/items`

4. **使用连字符`-`分隔单词**：提高URL的可读性
   - 正确：`/user-profiles`、`/order-items`
   - 错误：`/userProfiles`、`/orderItems`

5. **避免嵌套过深**：嵌套深度不应超过2层，过深的嵌套会导致URL复杂且难以维护
   - 正确：`/users/123/orders`
   - 错误：`/users/123/orders/456/items/789`

### 2.2 HTTP方法的使用

RESTful API使用HTTP方法来操作资源，常用的HTTP方法及其用途：

| HTTP方法 | 用途 | 示例 |
|---------|------|------|
| GET | 获取资源 | `GET /users` 获取所有用户<br>`GET /users/123` 获取指定用户 |
| POST | 创建资源 | `POST /users` 创建新用户 |
| PUT | 更新资源（全部） | `PUT /users/123` 更新指定用户的全部信息 |
| PATCH | 更新资源（部分） | `PATCH /users/123` 更新指定用户的部分信息 |
| DELETE | 删除资源 | `DELETE /users/123` 删除指定用户 |
| HEAD | 获取资源头信息 | `HEAD /users` 获取用户列表的头信息 |
| OPTIONS | 获取资源支持的方法 | `OPTIONS /users` 获取用户资源支持的HTTP方法 |

### 2.3 状态码

RESTful API应使用适当的HTTP状态码来表示请求的结果：

#### 2.3.1 1xx（信息性状态码）
- `100 Continue`：服务器已收到请求头，客户端应继续发送请求体
- `101 Switching Protocols`：服务器同意切换协议

#### 2.3.2 2xx（成功状态码）
- `200 OK`：请求成功
- `201 Created`：资源创建成功
- `202 Accepted`：请求已接受，但尚未处理
- `204 No Content`：请求成功，但没有响应体

#### 2.3.3 3xx（重定向状态码）
- `301 Moved Permanently`：资源已永久移动到新位置
- `302 Found`：资源临时移动到新位置
- `304 Not Modified`：资源未修改，可使用缓存

#### 2.3.4 4xx（客户端错误状态码）
- `400 Bad Request`：请求无效，服务器无法理解
- `401 Unauthorized`：请求需要认证
- `403 Forbidden`：服务器拒绝请求
- `404 Not Found`：资源不存在
- `405 Method Not Allowed`：请求方法不被允许
- `406 Not Acceptable`：服务器无法生成客户端可接受的响应
- `409 Conflict`：请求与资源的当前状态冲突
- `429 Too Many Requests`：客户端发送请求过于频繁

#### 2.3.5 5xx（服务器错误状态码）
- `500 Internal Server Error`：服务器内部错误
- `501 Not Implemented`：服务器不支持请求的功能
- `502 Bad Gateway`：网关错误
- `503 Service Unavailable`：服务器暂时不可用
- `504 Gateway Timeout`：网关超时

### 2.4 版本控制

API版本控制是RESTful API设计的重要组成部分，常用的版本控制方法：

1. **URL路径版本控制**：将版本号放在URL路径中
   - 示例：`/v1/users`、`/v2/users`
   - 优点：简单直观，易于理解和测试
   - 缺点：URL不够简洁，违反了REST的资源标识原则

2. **查询参数版本控制**：将版本号作为查询参数
   - 示例：`/users?version=1`、`/users?version=2`
   - 优点：URL简洁
   - 缺点：容易被忽略，不符合REST的设计原则

3. **HTTP头版本控制**：将版本号放在HTTP头中
   - 示例：`Accept: application/vnd.example.v1+json`
   - 优点：符合REST的设计原则，URL简洁
   - 缺点：测试和使用不够直观

4. **媒体类型版本控制**：将版本号放在媒体类型中
   - 示例：`Content-Type: application/vnd.example.v1+json`
   - 优点：符合REST的设计原则
   - 缺点：实现复杂，测试和使用不够直观

推荐使用URL路径版本控制，因为它简单直观，易于测试和使用。

### 2.5 认证和授权

RESTful API应实现适当的认证和授权机制，常用的认证方式：

1. **API密钥**：客户端使用API密钥进行认证
   - 优点：简单易用
   - 缺点：安全性较低，密钥容易泄露

2. **Basic认证**：客户端使用用户名和密码进行认证
   - 优点：简单易用
   - 缺点：密码明文传输，安全性较低

3. **Bearer令牌**：客户端使用令牌进行认证，如JWT（JSON Web Token）
   - 优点：安全性高，无状态，易于扩展
   - 缺点：实现复杂，令牌过期处理

4. **OAuth 2.0**：授权框架，允许第三方应用访问用户资源
   - 优点：安全性高，支持多种授权模式
   - 缺点：实现复杂

推荐使用JWT或OAuth 2.0进行认证，它们提供了较高的安全性和灵活性。

### 2.6 错误处理

RESTful API应提供清晰、一致的错误响应格式，包含以下信息：

- **状态码**：HTTP状态码
- **错误码**：应用特定的错误码
- **错误信息**：人类可读的错误描述
- **详细信息**：可选，更详细的错误信息
- **请求ID**：可选，用于跟踪请求

示例错误响应：

```json
{
  "status": 400,
  "error": {
    "code": "INVALID_REQUEST",
    "message": "Invalid request parameters",
    "details": [
      {
        "field": "email",
        "message": "Email is required"
      }
    ],
    "request_id": "1234567890"
  }
}
```

### 2.7 分页和过滤

对于大量数据的资源，应实现分页、排序和过滤功能：

1. **分页**：使用`page`和`limit`参数
   - 示例：`/users?page=1&limit=10`
   - 响应应包含分页信息：
     ```json
     {
       "data": [...],
       "pagination": {
         "page": 1,
         "limit": 10,
         "total": 100,
         "pages": 10
       }
     }
     ```

2. **排序**：使用`sort`参数，指定排序字段和方向
   - 示例：`/users?sort=name:asc`、`/users?sort=created_at:desc`

3. **过滤**：使用查询参数过滤资源
   - 示例：`/users?name=alice&age=30`
   - 示例：`/products?category=electronics&price_lte=1000`

### 2.8 HATEOAS（可选）

HATEOAS（Hypermedia as the Engine of Application State）是REST的一个约束条件，它要求API响应中包含链接，引导客户端进行下一步操作。

示例HATEOAS响应：

```json
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com",
  "links": [
    {
      "rel": "self",
      "href": "https://api.example.com/users/1"
    },
    {
      "rel": "orders",
      "href": "https://api.example.com/users/1/orders"
    },
    {
      "rel": "profile",
      "href": "https://api.example.com/users/1/profile"
    }
  ]
}
```

HATEOAS可以提高API的自描述性和可发现性，但实现复杂，对于简单API可以选择性实现。

## 三、使用Express实现RESTful API

### 3.1 项目结构

合理的项目结构有助于提高代码的可维护性和可扩展性：

```
rest-api/
├── app.js                  # 应用入口
├── package.json            # 项目配置
├── routes/                 # 路由定义
│   ├── users.js            # 用户路由
│   ├── products.js         # 产品路由
│   └── index.js            # 路由入口
├── controllers/            # 控制器
│   ├── userController.js   # 用户控制器
│   └── productController.js # 产品控制器
├── models/                 # 数据模型
│   ├── userModel.js        # 用户模型
│   └── productModel.js     # 产品模型
├── middleware/             # 中间件
│   ├── auth.js             # 认证中间件
│   ├── errorHandler.js     # 错误处理中间件
│   └── validation.js       # 数据验证中间件
├── utils/                  # 工具函数
│   ├── response.js         # 响应格式化工具
│   └── validation.js       # 验证工具
└── config/                 # 配置文件
    ├── database.js         # 数据库配置
    └── server.js           # 服务器配置
```

### 3.2 路由设计

使用Express Router设计RESTful路由：

**routes/users.js**
```javascript
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const authMiddleware = require('../middleware/auth');

// 用户路由
router.get('/', authMiddleware, userController.getAllUsers);
router.get('/:id', authMiddleware, userController.getUserById);
router.post('/', userController.createUser);
router.put('/:id', authMiddleware, userController.updateUser);
router.patch('/:id', authMiddleware, userController.partialUpdateUser);
router.delete('/:id', authMiddleware, userController.deleteUser);

module.exports = router;
```

**routes/index.js**
```javascript
const express = require('express');
const router = express.Router();
const usersRouter = require('./users');
const productsRouter = require('./products');

// 挂载路由
router.use('/users', usersRouter);
router.use('/products', productsRouter);

module.exports = router;
```

**app.js**
```javascript
const express = require('express');
const app = express();
const routes = require('./routes');
const errorHandler = require('./middleware/errorHandler');

// 中间件
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 路由
app.use('/v1', routes);

// 错误处理中间件
app.use(errorHandler);

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### 3.3 控制器实现

控制器负责处理请求，调用模型层获取数据，并返回响应：

**controllers/userController.js**
```javascript
const User = require('../models/userModel');
const { formatResponse } = require('../utils/response');

// 获取所有用户
exports.getAllUsers = async (req, res, next) => {
  try {
    const { page = 1, limit = 10 } = req.query;
    const users = await User.find()
      .skip((page - 1) * limit)
      .limit(parseInt(limit));
    const total = await User.countDocuments();
    
    res.status(200).json(formatResponse(200, users, {
      page: parseInt(page),
      limit: parseInt(limit),
      total,
      pages: Math.ceil(total / limit)
    }));
  } catch (error) {
    next(error);
  }
};

// 获取单个用户
exports.getUserById = async (req, res, next) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json(formatResponse(404, null, { message: 'User not found' }));
    }
    res.status(200).json(formatResponse(200, user));
  } catch (error) {
    next(error);
  }
};

// 创建用户
exports.createUser = async (req, res, next) => {
  try {
    const user = new User(req.body);
    await user.save();
    res.status(201).json(formatResponse(201, user));
  } catch (error) {
    next(error);
  }
};

// 更新用户
exports.updateUser = async (req, res, next) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!user) {
      return res.status(404).json(formatResponse(404, null, { message: 'User not found' }));
    }
    res.status(200).json(formatResponse(200, user));
  } catch (error) {
    next(error);
  }
};

// 部分更新用户
exports.partialUpdateUser = async (req, res, next) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!user) {
      return res.status(404).json(formatResponse(404, null, { message: 'User not found' }));
    }
    res.status(200).json(formatResponse(200, user));
  } catch (error) {
    next(error);
  }
};

// 删除用户
exports.deleteUser = async (req, res, next) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res.status(404).json(formatResponse(404, null, { message: 'User not found' }));
    }
    res.status(204).json(formatResponse(204, null));
  } catch (error) {
    next(error);
  }
};
```

### 3.4 响应格式化

使用工具函数格式化响应，确保响应格式一致：

**utils/response.js**
```javascript
/**
 * 格式化响应
 * @param {number} status - HTTP状态码
 * @param {any} data - 响应数据
 * @param {object} meta - 元数据，如分页信息、错误信息等
 * @returns {object} 格式化后的响应
 */
exports.formatResponse = (status, data, meta = {}) => {
  const response = {
    status,
    data
  };
  
  if (Object.keys(meta).length > 0) {
    response.meta = meta;
  }
  
  return response;
};
```

### 3.5 错误处理

实现全局错误处理中间件，统一处理错误：

**middleware/errorHandler.js**
```javascript
const { formatResponse } = require('../utils/response');

// 错误处理中间件
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  
  // 默认错误
  let status = 500;
  let error = {
    code: 'INTERNAL_SERVER_ERROR',
    message: 'Internal server error'
  };
  
  // Mongoose验证错误
  if (err.name === 'ValidationError') {
    status = 400;
    error.code = 'VALIDATION_ERROR';
    error.message = 'Validation error';
    error.details = Object.values(err.errors).map(err => ({
      field: err.path,
      message: err.message
    }));
  }
  
  // Mongoose Cast错误（如无效的ObjectId）
  if (err.name === 'CastError') {
    status = 400;
    error.code = 'INVALID_ID';
    error.message = 'Invalid ID format';
  }
  
  // 自定义错误
  if (err.status && err.error) {
    status = err.status;
    error = err.error;
  }
  
  res.status(status).json(formatResponse(status, null, { error }));
};

module.exports = errorHandler;
```

## 四、实践示例：创建RESTful API

### 4.1 项目初始化

```bash
# 创建项目目录
mkdir rest-api
cd rest-api

# 初始化项目
npm init -y

# 安装依赖
npm install express mongoose joi bcryptjs jsonwebtoken cors helmet morgan
npm install --save-dev nodemon
```

### 4.2 配置文件

**config/database.js**
```javascript
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect('mongodb://localhost:27017/rest-api', {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = connectDB;
```

**config/server.js**
```javascript
module.exports = {
  port: process.env.PORT || 3000,
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || '1d'
};
```

### 4.3 数据模型

**models/userModel.js**
```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Name is required'],
    trim: true
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [6, 'Password must be at least 6 characters']
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// 密码加密
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

// 密码验证
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model('User', userSchema);

module.exports = User;
```

**models/productModel.js**
```javascript
const mongoose = require('mongoose');

const productSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Name is required'],
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  price: {
    type: Number,
    required: [true, 'Price is required'],
    min: [0, 'Price must be positive']
  },
  category: {
    type: String,
    required: [true, 'Category is required'],
    trim: true
  },
  stock: {
    type: Number,
    required: [true, 'Stock is required'],
    min: [0, 'Stock must be non-negative']
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

const Product = mongoose.model('Product', productSchema);

module.exports = Product;
```

### 4.4 认证中间件

**middleware/auth.js**
```javascript
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');
const config = require('../config/server');

// 认证中间件
const auth = async (req, res, next) => {
  try {
    // 获取令牌
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      throw new Error('Authentication required');
    }
    
    // 验证令牌
    const decoded = jwt.verify(token, config.jwtSecret);
    
    // 获取用户
    const user = await User.findById(decoded.id);
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // 将用户和令牌添加到请求对象
    req.user = user;
    req.token = token;
    
    next();
  } catch (error) {
    res.status(401).json({
      status: 401,
      meta: {
        error: {
          code: 'UNAUTHORIZED',
          message: error.message
        }
      }
    });
  }
};

module.exports = auth;
```

### 4.5 认证控制器

**controllers/authController.js**
```javascript
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');
const config = require('../config/server');
const { formatResponse } = require('../utils/response');

// 注册用户
exports.register = async (req, res, next) => {
  try {
    const { name, email, password } = req.body;
    
    // 检查用户是否已存在
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json(formatResponse(400, null, {
        error: {
          code: 'USER_EXISTS',
          message: 'User already exists'
        }
      }));
    }
    
    // 创建用户
    const user = await User.create({ name, email, password });
    
    // 生成令牌
    const token = jwt.sign({ id: user._id }, config.jwtSecret, {
      expiresIn: config.jwtExpiresIn
    });
    
    res.status(201).json(formatResponse(201, {
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      },
      token
    }));
  } catch (error) {
    next(error);
  }
};

// 登录用户
exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    
    // 检查用户是否存在
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json(formatResponse(401, null, {
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password'
        }
      }));
    }
    
    // 验证密码
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json(formatResponse(401, null, {
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password'
        }
      }));
    }
    
    // 生成令牌
    const token = jwt.sign({ id: user._id }, config.jwtSecret, {
      expiresIn: config.jwtExpiresIn
    });
    
    res.status(200).json(formatResponse(200, {
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      },
      token
    }));
  } catch (error) {
    next(error);
  }
};
```

### 4.6 产品控制器

**controllers/productController.js**
```javascript
const Product = require('../models/productModel');
const { formatResponse } = require('../utils/response');

// 获取所有产品
exports.getAllProducts = async (req, res, next) => {
  try {
    const { page = 1, limit = 10, category, minPrice, maxPrice, sort } = req.query;
    
    // 构建查询条件
    const query = {};
    if (category) query.category = category;
    if (minPrice) query.price = { ...query.price, $gte: parseFloat(minPrice) };
    if (maxPrice) query.price = { ...query.price, $lte: parseFloat(maxPrice) };
    
    // 构建排序选项
    const sortOptions = {};
    if (sort) {
      const [field, direction] = sort.split(':');
      sortOptions[field] = direction === 'desc' ? -1 : 1;
    }
    
    // 查询产品
    const products = await Product.find(query)
      .sort(sortOptions)
      .skip((page - 1) * limit)
      .limit(parseInt(limit));
    
    const total = await Product.countDocuments(query);
    
    res.status(200).json(formatResponse(200, products, {
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (error) {
    next(error);
  }
};

// 获取单个产品
exports.getProductById = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    
    if (!product) {
      return res.status(404).json(formatResponse(404, null, {
        error: {
          code: 'PRODUCT_NOT_FOUND',
          message: 'Product not found'
        }
      }));
    }
    
    res.status(200).json(formatResponse(200, product));
  } catch (error) {
    next(error);
  }
};

// 创建产品
exports.createProduct = async (req, res, next) => {
  try {
    const product = await Product.create(req.body);
    res.status(201).json(formatResponse(201, product));
  } catch (error) {
    next(error);
  }
};

// 更新产品
exports.updateProduct = async (req, res, next) => {
  try {
    const product = await Product.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true
    });
    
    if (!product) {
      return res.status(404).json(formatResponse(404, null, {
        error: {
          code: 'PRODUCT_NOT_FOUND',
          message: 'Product not found'
        }
      }));
    }
    
    res.status(200).json(formatResponse(200, product));
  } catch (error) {
    next(error);
  }
};

// 删除产品
exports.deleteProduct = async (req, res, next) => {
  try {
    const product = await Product.findByIdAndDelete(req.params.id);
    
    if (!product) {
      return res.status(404).json(formatResponse(404, null, {
        error: {
          code: 'PRODUCT_NOT_FOUND',
          message: 'Product not found'
        }
      }));
    }
    
    res.status(204).json(formatResponse(204, null));
  } catch (error) {
    next(error);
  }
};
```

### 4.7 路由配置

**routes/auth.js**
```javascript
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

// 认证路由
router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;
```

**routes/products.js**
```javascript
const express = require('express');
const router = express.Router();
const productController = require('../controllers/productController');
const authMiddleware = require('../middleware/auth');

// 产品路由
router.get('/', productController.getAllProducts);
router.get('/:id', productController.getProductById);
router.post('/', authMiddleware, productController.createProduct);
router.put('/:id', authMiddleware, productController.updateProduct);
router.delete('/:id', authMiddleware, productController.deleteProduct);

module.exports = router;
```

**routes/index.js**
```javascript
const express = require('express');
const router = express.Router();
const authRouter = require('./auth');
const productsRouter = require('./products');

// 挂载路由
router.use('/auth', authRouter);
router.use('/products', productsRouter);

module.exports = router;
```

### 4.8 主应用文件

**app.js**
```javascript
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const connectDB = require('./config/database');
const routes = require('./routes');
const errorHandler = require('./middleware/errorHandler');

const app = express();
const PORT = process.env.PORT || 3000;

// 连接数据库
connectDB();

// 中间件
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 路由
app.use('/v1', routes);

// 错误处理中间件
app.use(errorHandler);

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 4.9 启动脚本

**package.json**
```json
{
  "name": "rest-api",
  "version": "1.0.0",
  "description": "RESTful API example",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js"
  },
  "keywords": ["rest", "api", "express", "mongoose"],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "helmet": "^7.1.0",
    "joi": "^17.12.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.1.0",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.3"
  }
}
```

### 4.10 启动应用

```bash
# 开发模式
npm run dev

# 生产模式
npm start
```

### 4.11 测试API

使用Postman或curl测试API：

1. **注册用户**
   ```bash
   curl -X POST http://localhost:3000/v1/auth/register \
   -H "Content-Type: application/json" \
   -d '{"name":"Alice","email":"alice@example.com","password":"password123"}'
   ```

2. **登录用户**
   ```bash
   curl -X POST http://localhost:3000/v1/auth/login \
   -H "Content-Type: application/json" \
   -d '{"email":"alice@example.com","password":"password123"}'
   ```

3. **创建产品**
   ```bash
   curl -X POST http://localhost:3000/v1/products \
   -H "Content-Type: application/json" \
   -H "Authorization: Bearer YOUR_TOKEN" \
   -d '{"name":"Laptop","description":"A powerful laptop","price":999.99,"category":"Electronics","stock":10}'
   ```

4. **获取所有产品**
   ```bash
   curl -X GET http://localhost:3000/v1/products
   ```

5. **获取单个产品**
   ```bash
   curl -X GET http://localhost:3000/v1/products/PRODUCT_ID
   ```

6. **更新产品**
   ```bash
   curl -X PUT http://localhost:3000/v1/products/PRODUCT_ID \
   -H "Content-Type: application/json" \
   -H "Authorization: Bearer YOUR_TOKEN" \
   -d '{"price":1099.99,"stock":15}'
   ```

7. **删除产品**
   ```bash
   curl -X DELETE http://localhost:3000/v1/products/PRODUCT_ID \
   -H "Authorization: Bearer YOUR_TOKEN"
   ```

## 五、最佳实践和学习建议

### 5.1 设计建议

1. **保持API简洁**：API设计应简洁明了，易于理解和使用
2. **使用一致的命名约定**：资源名称、参数名称应使用一致的命名约定
3. **提供完整的文档**：使用Swagger或Postman等工具生成API文档
4. **实现版本控制**：从API设计初期就考虑版本控制
5. **使用适当的状态码**：根据请求结果返回适当的HTTP状态码
6. **提供清晰的错误信息**：错误响应应包含足够的信息，便于客户端调试
7. **实现分页和过滤**：对于大量数据的资源，应实现分页和过滤功能
8. **考虑安全性**：实现适当的认证和授权机制，保护API安全

### 5.2 性能优化

1. **使用索引**：在数据库中为常用查询字段创建索引
2. **缓存频繁访问的数据**：使用Redis等缓存工具缓存频繁访问的数据
3. **限制响应数据**：只返回客户端需要的数据，避免返回不必要的字段
4. **使用异步操作**：使用异步/await或Promise处理IO操作，提高并发性能
5. **实现限流**：防止客户端发送过多请求，保护服务器

### 5.3 安全性考虑

1. **使用HTTPS**：在生产环境中使用HTTPS，保护数据传输安全
2. **实现认证和授权**：使用JWT或OAuth 2.0进行认证和授权
3. **验证输入数据**：对所有输入数据进行验证，防止注入攻击
4. **使用参数化查询**：防止SQL注入攻击
5. **设置适当的CORS策略**：限制跨域请求，保护API安全
6. **使用头盔中间件**：使用helmet等中间件设置安全相关的HTTP头
7. **定期更新依赖**：定期更新依赖包，修复安全漏洞

### 5.4 学习资源

1. **官方文档**：
   - [Express官方文档](https://expressjs.com/)
   - [Mongoose官方文档](https://mongoosejs.com/)
   - [REST API Tutorial](https://restfulapi.net/)

2. **书籍**：
   - 《RESTful Web APIs》 by Leonard Richardson and Sam Ruby
   - 《Building RESTful Web Services with Node.js and Express》 by Ethan Brown

3. **在线课程**：
   - [Node.js API Masterclass with Express, MongoDB, and JWT](https://www.udemy.com/course/nodejs-api-masterclass/)
   - [REST APIs with Node.js and Express](https://www.coursera.org/learn/rest-apis)

## 六、小结

RESTful API设计是Web开发中的重要组成部分，它遵循REST架构风格，使用HTTP协议进行通信。本章介绍了RESTful API的设计原则、最佳实践以及如何使用Express实现RESTful API。

通过学习本章内容，你应该掌握：

1. RESTful API的核心原则和设计规范
2. HTTP方法、状态码的正确使用
3. 资源命名、版本控制、认证授权等设计要点
4. 使用Express实现RESTful API的方法
5. 错误处理、响应格式化、中间件使用等技巧
6. 如何创建一个完整的RESTful API项目

RESTful API设计是一个不断演进的过程，需要根据项目需求和用户反馈不断优化。希望本章内容对你有所帮助，祝你在RESTful API设计的道路上越走越远！