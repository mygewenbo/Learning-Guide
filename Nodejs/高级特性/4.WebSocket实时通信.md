# WebSocket实时通信

## 1. WebSocket 基础

WebSocket 是一种网络通信协议，提供了全双工通信通道，允许服务器和客户端之间进行实时数据传输。与 HTTP 不同，WebSocket 连接一旦建立，就可以持续保持开放状态，双方可以随时发送数据。

### 1.1 WebSocket 与 HTTP 的区别

| 特性 | HTTP | WebSocket |
|------|------|-----------|
| 连接类型 | 半双工，请求-响应模式 | 全双工，双向通信 |
| 连接状态 | 无状态，每次请求都需要重新建立连接 | 有状态，连接持续保持 |
| 通信方向 | 客户端发起，服务器响应 | 客户端和服务器都可以主动发送数据 |
| 协议标识符 | http:// 或 https:// | ws:// 或 wss:// |
| 头部开销 | 每次请求都有完整的 HTTP 头部 | 只有初始握手时有 HTTP 头部，后续通信头部开销小 |
| 实时性 | 较差，需要轮询或长轮询 | 优秀，实时双向通信 |

### 1.2 WebSocket 握手过程

1. 客户端发送 HTTP 请求，包含 Upgrade 头部，请求升级到 WebSocket 协议。
2. 服务器响应 101 Switching Protocols，表示同意升级。
3. 连接建立，双方可以通过这个 TCP 连接进行全双工通信。

**客户端请求示例：**

```
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

**服务器响应示例：**

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

## 2. Node.js 中的 WebSocket 实现

Node.js 提供了多种实现 WebSocket 的方式，包括：

- **ws**：最流行的 WebSocket 库，提供了服务器和客户端的实现。
- **socket.io**：基于 WebSocket 的实时通信库，提供了更多高级特性，如房间、命名空间等。
- **undici**：Node.js 内置的 HTTP 客户端，也支持 WebSocket。

### 2.1 使用 ws 库创建 WebSocket 服务器

首先安装 ws 库：

```bash
npm install ws
```

**创建 WebSocket 服务器：**

```javascript
import { WebSocketServer } from 'ws';

// 创建 WebSocket 服务器，监听端口 8080
const wss = new WebSocketServer({ port: 8080 });

// 监听连接事件
wss.on('connection', (ws) => {
  console.log('客户端已连接');

  // 监听消息事件
  ws.on('message', (message) => {
    console.log(`收到消息: ${message}`);
    // 向客户端发送消息
    ws.send(`服务器收到: ${message}`);
  });

  // 监听关闭事件
  ws.on('close', () => {
    console.log('客户端已断开连接');
  });

  // 监听错误事件
  ws.on('error', (error) => {
    console.error('WebSocket 错误:', error);
  });

  // 向客户端发送欢迎消息
  ws.send('欢迎连接到 WebSocket 服务器！');
});

console.log('WebSocket 服务器运行在 ws://localhost:8080');
```

### 2.2 创建 WebSocket 客户端

**使用 ws 库创建客户端：**

```javascript
import { WebSocket } from 'ws';

// 创建 WebSocket 客户端连接
const ws = new WebSocket('ws://localhost:8080');

// 监听连接打开事件
ws.on('open', () => {
  console.log('已连接到服务器');
  // 向服务器发送消息
  ws.send('Hello, Server!');
});

// 监听消息事件
ws.on('message', (message) => {
  console.log(`收到服务器消息: ${message}`);
});

// 监听关闭事件
ws.on('close', () => {
  console.log('与服务器的连接已关闭');
});

// 监听错误事件
ws.on('error', (error) => {
  console.error('WebSocket 错误:', error);
});
```

**使用浏览器原生 WebSocket API：**

```html
<!DOCTYPE html>
<html>
<head>
  <title>WebSocket 客户端</title>
</head>
<body>
  <h1>WebSocket 客户端</h1>
  <div id="messages"></div>
  <input type="text" id="messageInput" placeholder="输入消息">
  <button id="sendButton">发送</button>

  <script>
    const ws = new WebSocket('ws://localhost:8080');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');

    ws.onopen = () => {
      addMessage('已连接到服务器');
    };

    ws.onmessage = (event) => {
      addMessage(`服务器: ${event.data}`);
    };

    ws.onclose = () => {
      addMessage('与服务器的连接已关闭');
    };

    ws.onerror = (error) => {
      addMessage(`错误: ${error}`);
    };

    sendButton.addEventListener('click', () => {
      const message = messageInput.value;
      if (message) {
        ws.send(message);
        addMessage(`客户端: ${message}`);
        messageInput.value = '';
      }
    });

    messageInput.addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
        sendButton.click();
      }
    });

    function addMessage(message) {
      const div = document.createElement('div');
      div.textContent = message;
      messagesDiv.appendChild(div);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  </script>
</body>
</html>
```

## 3. WebSocket 高级特性

### 3.1 广播消息

向所有连接的客户端发送消息：

```javascript
// 向所有客户端广播消息
wss.on('connection', (ws) => {
  // ...
  
  ws.on('message', (message) => {
    console.log(`收到消息: ${message}`);
    
    // 向所有客户端广播消息
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(`广播消息: ${message}`);
      }
    });
  });
  
  // ...
});
```

### 3.2 房间管理

实现房间功能，允许客户端加入和离开房间，向特定房间的客户端发送消息：

```javascript
import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 8080 });

// 房间映射，key 是房间名称，value 是该房间的客户端集合
const rooms = new Map();

wss.on('connection', (ws) => {
  console.log('客户端已连接');
  
  // 客户端当前所在的房间
  let currentRoom = null;
  
  ws.on('message', (message) => {
    try {
      // 解析消息
      const data = JSON.parse(message);
      
      switch (data.type) {
        case 'join':
          // 加入房间
          if (currentRoom) {
            // 先离开当前房间
            leaveRoom(currentRoom, ws);
          }
          joinRoom(data.room, ws);
          currentRoom = data.room;
          ws.send(JSON.stringify({ type: 'success', message: `已加入房间: ${data.room}` }));
          break;
          
        case 'leave':
          // 离开房间
          if (currentRoom) {
            leaveRoom(currentRoom, ws);
            ws.send(JSON.stringify({ type: 'success', message: `已离开房间: ${currentRoom}` }));
            currentRoom = null;
          }
          break;
          
        case 'message':
          // 发送消息到当前房间
          if (currentRoom) {
            broadcastToRoom(currentRoom, JSON.stringify({
              type: 'message',
              user: data.user,
              content: data.content
            }));
          }
          break;
          
        default:
          ws.send(JSON.stringify({ type: 'error', message: '未知消息类型' }));
      }
    } catch (error) {
      ws.send(JSON.stringify({ type: 'error', message: '无效的消息格式' }));
    }
  });
  
  ws.on('close', () => {
    console.log('客户端已断开连接');
    // 离开当前房间
    if (currentRoom) {
      leaveRoom(currentRoom, ws);
    }
  });
});

// 加入房间
function joinRoom(roomName, ws) {
  if (!rooms.has(roomName)) {
    rooms.set(roomName, new Set());
  }
  rooms.get(roomName).add(ws);
  console.log(`客户端加入房间: ${roomName}`);
}

// 离开房间
function leaveRoom(roomName, ws) {
  if (rooms.has(roomName)) {
    const room = rooms.get(roomName);
    room.delete(ws);
    console.log(`客户端离开房间: ${roomName}`);
    // 如果房间为空，删除房间
    if (room.size === 0) {
      rooms.delete(roomName);
      console.log(`删除空房间: ${roomName}`);
    }
  }
}

// 向房间广播消息
function broadcastToRoom(roomName, message) {
  if (rooms.has(roomName)) {
    rooms.get(roomName).forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  }
}

console.log('WebSocket 服务器运行在 ws://localhost:8080');
```

### 3.3 心跳检测

实现心跳检测，检测客户端是否在线：

```javascript
import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 8080 });

// 心跳间隔，单位：毫秒
const HEARTBEAT_INTERVAL = 30000;
// 心跳超时时间，单位：毫秒
const HEARTBEAT_TIMEOUT = 60000;

wss.on('connection', (ws) => {
  console.log('客户端已连接');
  
  // 心跳定时器
  let heartbeatTimer = null;
  // 心跳超时定时器
  let heartbeatTimeoutTimer = null;
  
  // 发送心跳
  function sendHeartbeat() {
    ws.send(JSON.stringify({ type: 'ping' }));
    // 设置超时定时器
    heartbeatTimeoutTimer = setTimeout(() => {
      console.log('心跳超时，断开连接');
      ws.terminate();
    }, HEARTBEAT_TIMEOUT);
  }
  
  // 重置心跳超时定时器
  function resetHeartbeatTimeout() {
    if (heartbeatTimeoutTimer) {
      clearTimeout(heartbeatTimeoutTimer);
      heartbeatTimeoutTimer = null;
    }
  }
  
  // 开始心跳
  function startHeartbeat() {
    heartbeatTimer = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);
    sendHeartbeat();
  }
  
  // 停止心跳
  function stopHeartbeat() {
    if (heartbeatTimer) {
      clearInterval(heartbeatTimer);
      heartbeatTimer = null;
    }
    resetHeartbeatTimeout();
  }
  
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      
      if (data.type === 'pong') {
        // 收到心跳响应，重置超时定时器
        resetHeartbeatTimeout();
      } else {
        // 处理其他消息
        console.log(`收到消息: ${message}`);
        ws.send(`服务器收到: ${message}`);
      }
    } catch (error) {
      console.error('消息解析错误:', error);
    }
  });
  
  ws.on('close', () => {
    console.log('客户端已断开连接');
    // 停止心跳
    stopHeartbeat();
  });
  
  ws.on('error', (error) => {
    console.error('WebSocket 错误:', error);
    // 停止心跳
    stopHeartbeat();
  });
  
  // 开始心跳
  startHeartbeat();
});

console.log('WebSocket 服务器运行在 ws://localhost:8080');
```

**客户端心跳处理：**

```javascript
import { WebSocket } from 'ws';

const ws = new WebSocket('ws://localhost:8080');

ws.on('open', () => {
  console.log('已连接到服务器');
});

ws.on('message', (message) => {
  try {
    const data = JSON.parse(message);
    
    if (data.type === 'ping') {
      // 收到服务器心跳，发送响应
      ws.send(JSON.stringify({ type: 'pong' }));
    } else {
      // 处理其他消息
      console.log(`收到服务器消息: ${message}`);
    }
  } catch (error) {
    console.error('消息解析错误:', error);
  }
});

// ... 其他事件处理
```

## 4. 使用 Socket.io

Socket.io 是一个基于 WebSocket 的实时通信库，提供了更多高级特性，如自动重连、房间、命名空间等。

### 4.1 安装 Socket.io

```bash
npm install socket.io
```

### 4.2 创建 Socket.io 服务器

```javascript
import { createServer } from 'http';
import { Server } from 'socket.io';

// 创建 HTTP 服务器
const httpServer = createServer();
// 创建 Socket.io 服务器
const io = new Server(httpServer, {
  // 配置选项
  cors: {
    origin: '*', // 允许所有来源，生产环境中应该设置具体的来源
    methods: ['GET', 'POST']
  }
});

// 监听连接事件
io.on('connection', (socket) => {
  console.log('客户端已连接:', socket.id);
  
  // 监听消息事件
  socket.on('chat message', (msg) => {
    console.log(`收到消息: ${msg}`);
    // 向所有客户端广播消息
    io.emit('chat message', msg);
  });
  
  // 监听加入房间事件
  socket.on('join room', (room) => {
    socket.join(room);
    console.log(`客户端 ${socket.id} 加入房间: ${room}`);
    // 向房间内的其他客户端发送通知
    socket.to(room).emit('user joined', {
      userId: socket.id,
      room: room
    });
  });
  
  // 监听离开房间事件
  socket.on('leave room', (room) => {
    socket.leave(room);
    console.log(`客户端 ${socket.id} 离开房间: ${room}`);
    // 向房间内的其他客户端发送通知
    socket.to(room).emit('user left', {
      userId: socket.id,
      room: room
    });
  });
  
  // 监听断开连接事件
  socket.on('disconnect', () => {
    console.log('客户端已断开连接:', socket.id);
  });
});

// 启动 HTTP 服务器，监听端口 3000
httpServer.listen(3000, () => {
  console.log('Socket.io 服务器运行在 http://localhost:3000');
});
```

### 4.3 创建 Socket.io 客户端

**使用 Socket.io 客户端库：**

首先安装客户端库：

```bash
npm install socket.io-client
```

**客户端代码：**

```javascript
import { io } from 'socket.io-client';

// 创建 Socket.io 客户端连接
const socket = io('http://localhost:3000');

// 监听连接事件
socket.on('connect', () => {
  console.log('已连接到服务器，ID:', socket.id);
  
  // 发送消息
  socket.emit('chat message', 'Hello, Socket.io!');
  
  // 加入房间
  socket.emit('join room', 'room1');
});

// 监听消息事件
socket.on('chat message', (msg) => {
  console.log(`收到消息: ${msg}`);
});

// 监听用户加入事件
socket.on('user joined', (data) => {
  console.log(`用户 ${data.userId} 加入了房间 ${data.room}`);
});

// 监听用户离开事件
socket.on('user left', (data) => {
  console.log(`用户 ${data.userId} 离开了房间 ${data.room}`);
});

// 监听断开连接事件
socket.on('disconnect', () => {
  console.log('与服务器的连接已关闭');
});
```

**使用浏览器端 Socket.io：**

```html
<!DOCTYPE html>
<html>
<head>
  <title>Socket.io 客户端</title>
  <!-- 引入 Socket.io 客户端库 -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
  <h1>Socket.io 客户端</h1>
  <div id="messages"></div>
  <input type="text" id="messageInput" placeholder="输入消息">
  <button id="sendButton">发送</button>

  <script>
    // 创建 Socket.io 客户端连接
    const socket = io('http://localhost:3000');
    
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    
    // 监听连接事件
    socket.on('connect', () => {
      addMessage(`已连接到服务器，ID: ${socket.id}`);
      // 加入房间
      socket.emit('join room', 'room1');
    });
    
    // 监听消息事件
    socket.on('chat message', (msg) => {
      addMessage(`收到消息: ${msg}`);
    });
    
    // 监听用户加入事件
    socket.on('user joined', (data) => {
      addMessage(`用户 ${data.userId} 加入了房间 ${data.room}`);
    });
    
    // 监听用户离开事件
    socket.on('user left', (data) => {
      addMessage(`用户 ${data.userId} 离开了房间 ${data.room}`);
    });
    
    // 监听断开连接事件
    socket.on('disconnect', () => {
      addMessage('与服务器的连接已关闭');
    });
    
    // 发送消息
    sendButton.addEventListener('click', () => {
      const message = messageInput.value;
      if (message) {
        socket.emit('chat message', message);
        addMessage(`发送消息: ${message}`);
        messageInput.value = '';
      }
    });
    
    // 回车发送消息
    messageInput.addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
        sendButton.click();
      }
    });
    
    // 添加消息到页面
    function addMessage(message) {
      const div = document.createElement('div');
      div.textContent = message;
      messagesDiv.appendChild(div);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  </script>
</body>
</html>
```

## 5. WebSocket 安全

### 5.1 使用 WSS

在生产环境中，应该使用 WSS（WebSocket Secure）协议，它基于 TLS/SSL 加密，提供了安全的通信通道。

**创建 WSS 服务器：**

```javascript
import { WebSocketServer } from 'ws';
import { createServer } from 'https';
import { readFileSync } from 'fs';

// 读取 SSL 证书和密钥
const server = createServer({
  cert: readFileSync('server.crt'),
  key: readFileSync('server.key')
});

// 创建 WebSocket 服务器，使用 HTTPS 服务器
const wss = new WebSocketServer({ server });

wss.on('connection', (ws) => {
  console.log('客户端已连接');
  // ...
});

// 启动服务器，监听端口 443
server.listen(443, () => {
  console.log('WSS 服务器运行在 wss://localhost');
});
```

### 5.2 认证和授权

实现客户端认证和授权，确保只有合法的客户端才能连接到 WebSocket 服务器：

```javascript
import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 8080 });

// 模拟用户数据库
const users = new Map([
  ['user1', 'password1'],
  ['user2', 'password2']
]);

wss.on('connection', (ws, request) => {
  console.log('客户端已连接');
  
  // 客户端是否已认证
  let isAuthenticated = false;
  let username = null;
  
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      
      if (!isAuthenticated) {
        // 处理认证请求
        if (data.type === 'authenticate') {
          // 验证用户名和密码
          if (users.has(data.username) && users.get(data.username) === data.password) {
            isAuthenticated = true;
            username = data.username;
            ws.send(JSON.stringify({ type: 'authenticate', success: true, message: '认证成功' }));
            console.log(`用户 ${username} 认证成功`);
          } else {
            ws.send(JSON.stringify({ type: 'authenticate', success: false, message: '用户名或密码错误' }));
          }
        } else {
          ws.send(JSON.stringify({ type: 'error', message: '请先认证' }));
        }
      } else {
        // 处理已认证客户端的消息
        console.log(`收到用户 ${username} 的消息: ${JSON.stringify(data)}`);
        // ... 处理消息
      }
    } catch (error) {
      console.error('消息解析错误:', error);
      ws.send(JSON.stringify({ type: 'error', message: '无效的消息格式' }));
    }
  });
  
  ws.on('close', () => {
    if (isAuthenticated) {
      console.log(`用户 ${username} 已断开连接`);
    } else {
      console.log('未认证的客户端已断开连接');
    }
  });
});

console.log('WebSocket 服务器运行在 ws://localhost:8080');
```

## 6. 实际应用场景

### 6.1 实时聊天应用

```javascript
// 服务器端
io.on('connection', (socket) => {
  // 监听新消息
  socket.on('new message', (data) => {
    // 保存消息到数据库
    saveMessageToDatabase(data)
      .then((message) => {
        // 向所有客户端广播消息
        io.emit('new message', message);
      })
      .catch((error) => {
        console.error('保存消息失败:', error);
      });
  });
  
  // 监听获取历史消息
  socket.on('get history', (room) => {
    // 从数据库获取历史消息
    getHistoryMessages(room)
      .then((messages) => {
        // 向客户端发送历史消息
        socket.emit('history messages', messages);
      })
      .catch((error) => {
        console.error('获取历史消息失败:', error);
      });
  });
});
```

### 6.2 实时协作编辑

```javascript
// 服务器端
io.on('connection', (socket) => {
  // 监听加入文档
  socket.on('join document', (documentId) => {
    socket.join(documentId);
    console.log(`客户端 ${socket.id} 加入文档: ${documentId}`);
  });
  
  // 监听文档变更
  socket.on('document change', (data) => {
    // 保存变更到数据库
    saveDocumentChange(data)
      .then(() => {
        // 向文档房间内的其他客户端广播变更
        socket.to(data.documentId).emit('document change', data);
      })
      .catch((error) => {
        console.error('保存文档变更失败:', error);
      });
  });
});
```

### 6.3 实时数据可视化

```javascript
// 服务器端
// 模拟实时数据生成
setInterval(() => {
  const data = {
    timestamp: new Date().toISOString(),
    value: Math.random() * 100
  };
  // 向所有客户端广播实时数据
  io.emit('real-time data', data);
}, 1000);
```

## 7. 最佳实践

1. **使用 WSS**：在生产环境中，始终使用 WSS 协议，确保通信安全。
2. **实现认证和授权**：确保只有合法的客户端才能连接到 WebSocket 服务器。
3. **使用心跳检测**：实现心跳检测，及时发现并处理断开的连接。
4. **限制连接数**：根据服务器资源，限制同时连接的客户端数量。
5. **使用房间管理**：对于多用户应用，使用房间功能来组织客户端，提高消息发送效率。
6. **处理异常情况**：妥善处理连接断开、消息解析错误等异常情况。
7. **监控和日志**：实现监控和日志功能，及时发现和排查问题。
8. **考虑性能**：对于高并发应用，考虑使用集群来提高性能和可靠性。
9. **使用成熟的库**：优先使用成熟的 WebSocket 库，如 ws 或 Socket.io，它们提供了更多高级特性和更好的性能。
10. **测试**：充分测试 WebSocket 应用，包括正常情况和异常情况。

## 8. 总结

WebSocket 是一种强大的实时通信协议，允许服务器和客户端之间进行全双工通信。在 Node.js 中，可以使用 ws 库或 Socket.io 来实现 WebSocket 应用。

- WebSocket 提供了比 HTTP 更好的实时性，适用于需要实时通信的应用，如聊天、实时协作、实时数据可视化等。
- ws 库是一个轻量级的 WebSocket 实现，提供了基本的 WebSocket 功能。
- Socket.io 是一个基于 WebSocket 的实时通信库，提供了更多高级特性，如自动重连、房间、命名空间等。
- 在生产环境中，应该使用 WSS 协议，实现认证和授权，确保通信安全。
- 实现心跳检测，及时发现并处理断开的连接。
- 对于高并发应用，考虑使用集群来提高性能和可靠性。

通过掌握 WebSocket 技术，你可以构建各种实时通信应用，提供更好的用户体验。