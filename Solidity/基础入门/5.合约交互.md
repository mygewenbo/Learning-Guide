# 合约交互

## 一、合约交互概述

### 1.1 什么是合约交互
- 合约交互是指通过交易与智能合约进行通信
- 可以是外部账户调用合约，也可以是合约调用其他合约
- 交互方式包括：调用函数、发送以太币、触发事件

### 1.2 合约交互的基本流程
1. **构建交易**：指定合约地址、函数签名、参数和gas限制
2. **签名交易**：使用私钥对交易进行签名
3. **广播交易**：将交易发送到区块链网络
4. **矿工确认**：矿工将交易打包到区块中
5. **执行合约**：EVM执行合约代码
6. **返回结果**：返回函数调用结果或交易收据

## 二、合约之间的调用

### 2.1 直接调用
- 最常见的合约间调用方式
- 通过合约地址和接口调用
- 示例：
  ```solidity
  // 定义接口
  interface IToken {
      function transfer(address to, uint256 value) external returns (bool);
      function balanceOf(address account) external view returns (uint256);
  }
  
  contract TokenHolder {
      IToken public token;
      
      // 构造函数中初始化合约地址
      constructor(address _tokenAddress) {
          token = IToken(_tokenAddress);
      }
      
      // 调用代币合约的transfer函数
      function transferToken(address to, uint256 amount) public returns (bool) {
          return token.transfer(to, amount);
      }
      
      // 调用代币合约的balanceOf函数
      function getTokenBalance(address account) public view returns (uint256) {
          return token.balanceOf(account);
      }
  }
  ```

### 2.2 接口和抽象合约

#### 2.2.1 接口
- 只包含函数声明，不包含实现
- 所有函数默认为`external`
- 不能包含状态变量
- 不能包含构造函数
- 示例：
  ```solidity
  interface IERC20 {
      function totalSupply() external view returns (uint256);
      function balanceOf(address account) external view returns (uint256);
      function transfer(address to, uint256 amount) external returns (bool);
      function allowance(address owner, address spender) external view returns (uint256);
      function approve(address spender, uint256 amount) external returns (bool);
      function transferFrom(address from, address to, uint256 amount) external returns (bool);
      
      event Transfer(address indexed from, address indexed to, uint256 value);
      event Approval(address indexed owner, address indexed spender, uint256 value);
  }
  ```

#### 2.2.2 抽象合约
- 可以包含函数声明和实现
- 包含未实现函数的合约必须声明为抽象合约
- 使用`abstract`关键字
- 示例：
  ```solidity
  abstract contract AbstractContract {
      // 状态变量
      uint256 public value;
      
      // 已实现的函数
      function setValue(uint256 _value) public {
          value = _value;
      }
      
      // 未实现的函数，必须在继承合约中实现
      function calculate() public virtual view returns (uint256);
      
      // 带有修饰符的未实现函数
      function withdraw() public virtual onlyOwner;
      
      // 修饰符
      modifier onlyOwner() {
          require(msg.sender == owner, "Not owner");
          _;
      }
  }
  ```

### 2.3 委托调用（Delegatecall）
- 允许一个合约调用另一个合约的函数，但使用调用合约的上下文
- 存储和余额使用调用合约的
- 用于实现代理合约和升级机制
- 示例：
  ```solidity
  contract Delegate {
      uint256 public num;
      address public sender;
      address public owner;
      
      function setVars(uint256 _num) public {
          num = _num;
          sender = msg.sender;
          owner = tx.origin;
      }
  }
  
  contract Delegator {
      uint256 public num;
      address public sender;
      address public owner;
      
      function delegateCall(address _delegate, uint256 _num) public {
          // 使用delegatecall调用Delegate合约的setVars函数
          (bool success, ) = _delegate.delegatecall(abi.encodeWithSignature("setVars(uint256)", _num));
          require(success, "Delegate call failed");
      }
  }
  ```

### 2.4 静态调用（Staticcall）
- 用于调用视图函数或纯函数
- 不修改状态
- 类似于`view`或`pure`修饰符
- 示例：
  ```solidity
  function staticCallExample(address _contract, bytes4 _selector) public view returns (bytes memory) {
      (bool success, bytes memory result) = _contract.staticcall(abi.encodeWithSelector(_selector));
      require(success, "Static call failed");
      return result;
  }
  ```

## 三、以太币的处理

### 3.1 接收以太币
- 使用`payable`修饰符允许函数接收以太币
- 使用`receive`函数处理直接转账
- 示例：
  ```solidity
  contract EtherReceiver {
      mapping(address => uint256) public balances;
      
      // 接收函数，处理直接转账
      receive() external payable {
          balances[msg.sender] += msg.value;
      }
      
      // payable函数，处理带数据的转账
      function deposit() external payable {
          balances[msg.sender] += msg.value;
      }
      
      // 获取合约余额
      function getContractBalance() public view returns (uint256) {
          return address(this).balance;
      }
  }
  ```

### 3.2 发送以太币

#### 3.2.1 transfer方法
- 发送以太币，失败时抛出异常
- gas限制为2300
- 示例：
  ```solidity
  function sendEther(address payable _to, uint256 _amount) public {
      _to.transfer(_amount);
  }
  ```

#### 3.2.2 send方法
- 发送以太币，失败时返回false
- gas限制为2300
- 示例：
  ```solidity
  function sendEther(address payable _to, uint256 _amount) public returns (bool) {
      return _to.send(_amount);
  }
  ```

#### 3.2.3 call方法
- 推荐的发送以太币方式
- 可以设置gas限制
- 失败时返回false
- 示例：
  ```solidity
  function sendEther(address payable _to, uint256 _amount) public returns (bool) {
      (bool success, ) = _to.call{value: _amount}("");
      return success;
  }
  ```

### 3.3 处理msg.value
- `msg.value`是当前调用发送的以太币数量
- 以wei为单位
- 示例：
  ```solidity
  function buyTokens() public payable {
      // 1 ether = 1000 tokens
      uint256 tokens = msg.value * 1000;
      balances[msg.sender] += tokens;
      totalSupply += tokens;
  }
  ```

## 四、ABI编码和解码

### 4.1 ABI简介
- ABI（Application Binary Interface）是合约与外部世界交互的标准
- 定义了函数签名、参数编码、返回值编码
- 用于将高级语言转换为EVM可执行的字节码

### 4.2 编码函数

#### 4.2.1 abi.encode
- 对参数进行编码
- 用于合约间调用
- 示例：
  ```solidity
  function encodeExample() public pure returns (bytes memory) {
      uint256 a = 10;
      address b = 0x1234567890123456789012345678901234567890;
      string memory c = "test";
      
      return abi.encode(a, b, c);
  }
  ```

#### 4.2.2 abi.encodePacked
- 对参数进行紧密编码
- 更节省空间，但可能导致哈希碰撞
- 示例：
  ```solidity
  function encodePackedExample() public pure returns (bytes memory) {
      uint256 a = 10;
      address b = 0x1234567890123456789012345678901234567890;
      string memory c = "test";
      
      return abi.encodePacked(a, b, c);
  }
  ```

#### 4.2.3 abi.encodeWithSignature
- 包含函数签名的编码
- 用于动态调用
- 示例：
  ```solidity
  function encodeWithSignatureExample() public pure returns (bytes memory) {
      uint256 value = 100;
      
      return abi.encodeWithSignature("transfer(address,uint256)", 0x1234567890123456789012345678901234567890, value);
  }
  ```

#### 4.2.4 abi.encodeWithSelector
- 包含函数选择器的编码
- 更高效，因为选择器是预计算的
- 示例：
  ```solidity
  function encodeWithSelectorExample() public pure returns (bytes memory) {
      uint256 value = 100;
      bytes4 selector = bytes4(keccak256("transfer(address,uint256)"));
      
      return abi.encodeWithSelector(selector, 0x1234567890123456789012345678901234567890, value);
  }
  ```

### 4.3 解码函数

#### 4.3.1 abi.decode
- 对编码数据进行解码
- 用于解析返回值
- 示例：
  ```solidity
  function decodeExample(bytes memory data) public pure returns (uint256, address, string memory) {
      return abi.decode(data, (uint256, address, string));
  }
  ```

## 五、实践项目：去中心化交易所（DEX）基础

### 5.1 项目概述
- 实现一个简单的去中心化交易所
- 支持两种代币之间的兑换
- 包含流动性池和兑换功能

### 5.2 合约代码
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

contract SimpleDEX {
    // 状态变量
    IERC20 public tokenA;
    IERC20 public tokenB;
    
    uint256 public reserveA;
    uint256 public reserveB;
    
    // 事件
    event Swap(address indexed user, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);
    event AddLiquidity(address indexed user, uint256 amountA, uint256 amountB);
    event RemoveLiquidity(address indexed user, uint256 amountA, uint256 amountB);
    
    // 构造函数
    constructor(address _tokenA, address _tokenB) {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
    }
    
    // 添加流动性
    function addLiquidity(uint256 _amountA, uint256 _amountB) public {
        // 转移代币到合约
        require(tokenA.transferFrom(msg.sender, address(this), _amountA), "TokenA transfer failed");
        require(tokenB.transferFrom(msg.sender, address(this), _amountB), "TokenB transfer failed");
        
        // 更新储备
        reserveA += _amountA;
        reserveB += _amountB;
        
        emit AddLiquidity(msg.sender, _amountA, _amountB);
    }
    
    // 计算兑换数量（简化版，实际应考虑滑点和手续费）
    function calculateSwap(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) public pure returns (uint256) {
        require(_amountIn > 0, "Amount in must be greater than 0");
        require(_reserveIn > 0 && _reserveOut > 0, "Reserves must be greater than 0");
        
        // 简化的恒定乘积公式：x * y = k
        uint256 amountOut = (_amountIn * _reserveOut) / (_reserveIn + _amountIn);
        return amountOut;
    }
    
    // 兑换TokenA到TokenB
    function swapAToB(uint256 _amountA) public returns (uint256) {
        uint256 amountB = calculateSwap(_amountA, reserveA, reserveB);
        
        // 转移代币
        require(tokenA.transferFrom(msg.sender, address(this), _amountA), "TokenA transfer failed");
        require(tokenB.transfer(msg.sender, amountB), "TokenB transfer failed");
        
        // 更新储备
        reserveA += _amountA;
        reserveB -= amountB;
        
        emit Swap(msg.sender, address(tokenA), address(tokenB), _amountA, amountB);
        return amountB;
    }
    
    // 兑换TokenB到TokenA
    function swapBToA(uint256 _amountB) public returns (uint256) {
        uint256 amountA = calculateSwap(_amountB, reserveB, reserveA);
        
        // 转移代币
        require(tokenB.transferFrom(msg.sender, address(this), _amountB), "TokenB transfer failed");
        require(tokenA.transfer(msg.sender, amountA), "TokenA transfer failed");
        
        // 更新储备
        reserveB += _amountB;
        reserveA -= amountA;
        
        emit Swap(msg.sender, address(tokenB), address(tokenA), _amountB, amountA);
        return amountA;
    }
}
```

### 5.3 部署和测试
1. 部署两个ERC20代币合约
2. 部署SimpleDEX合约，传入两个代币地址
3. 向DEX合约添加流动性：
   - 调用代币的`approve`函数授权DEX合约
   - 调用DEX的`addLiquidity`函数添加流动性
4. 测试兑换功能：
   - 调用`swapAToB`函数将TokenA兑换为TokenB
   - 调用`swapBToA`函数将TokenB兑换为TokenA
5. 检查储备和余额变化

## 六、练习

1. 实现一个合约，调用另一个合约的多个函数
2. 编写一个接口，用于与Uniswap V2交互
3. 实现一个代理合约，使用delegatecall调用其他合约
4. 编写一个函数，使用abi.encode和abi.decode处理复杂数据
5. 实现一个跨合约的投票系统

## 七、总结

通过本章的学习，你已经掌握了Solidity中的合约交互机制，包括：

- 合约之间的直接调用
- 接口和抽象合约的使用
- 委托调用（Delegatecall）和静态调用（Staticcall）
- 以太币的接收和发送
- ABI编码和解码
- 简单DEX的实现

这些知识对于构建复杂的去中心化应用至关重要，特别是当需要多个合约协同工作时。在下一章中，我们将学习Solidity的进阶特性，包括高级数据类型、函数修饰符、事件等。