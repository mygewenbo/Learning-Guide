# 身份验证与授权

## 1. 基本概念

### 1.1 身份验证(Authentication)
身份验证是验证用户身份的过程，确认用户是他们声称的人。在Web应用中，常见的身份验证方式包括：
- 用户名/密码
- 邮箱/密码
- 手机号/验证码
- 第三方登录（OAuth2.0、OpenID Connect）
- 生物识别（指纹、面部识别）
- 多因素认证(MFA)

### 1.2 授权(Authorization)
授权是确定已认证用户可以访问哪些资源或执行哪些操作的过程。常见的授权模型包括：
- 基于角色的访问控制(RBAC)
- 基于属性的访问控制(ABAC)
- 基于策略的访问控制(PBAC)

### 1.3 会话管理
会话管理是在用户身份验证后，维护用户状态的过程。常见的会话管理方式包括：
- Cookie-Session
- JWT(JSON Web Token)
- Redis会话存储

## 2. 常见身份验证策略

### 2.1 JWT(JSON Web Token)
JWT是一种轻量级的身份验证机制，通过JSON对象传递信息。它由三部分组成：
- Header(头部)：包含算法和令牌类型
- Payload(负载)：包含声明信息
- Signature(签名)：用于验证令牌的完整性

#### 代码示例：使用jsonwebtoken库生成和验证JWT

```javascript
const jwt = require('jsonwebtoken');
const secretKey = 'your-secret-key';

// 生成JWT
function generateToken(user) {
  const payload = {
    userId: user.id,
    username: user.username,
    role: user.role
  };
  
  return jwt.sign(payload, secretKey, { expiresIn: '1h' });
}

// 验证JWT
function verifyToken(token) {
  try {
    return jwt.verify(token, secretKey);
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// 使用示例
const user = { id: 1, username: 'admin', role: 'admin' };
const token = generateToken(user);
console.log('Generated Token:', token);

const decoded = verifyToken(token);
console.log('Decoded Token:', decoded);
```

### 2.2 OAuth2.0
OAuth2.0是一种授权框架，允许第三方应用访问用户在另一个服务上的资源，而无需共享密码。主要角色包括：
- 资源所有者：用户
- 客户端：第三方应用
- 授权服务器：验证用户身份并颁发访问令牌
- 资源服务器：存储用户资源

#### 代码示例：使用Passport.js实现OAuth2.0身份验证

```javascript
const express = require('express');
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const session = require('express-session');

const app = express();

// 配置会话
app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: true
}));

// 初始化Passport
app.use(passport.initialize());
app.use(passport.session());

// 配置Google策略
passport.use(new GoogleStrategy({
    clientID: 'your-client-id',
    clientSecret: 'your-client-secret',
    callbackURL: 'http://localhost:3000/auth/google/callback'
  },
  function(accessToken, refreshToken, profile, done) {
    // 这里可以保存用户信息到数据库
    return done(null, profile);
  }
));

// 序列化和反序列化用户
passport.serializeUser(function(user, done) {
  done(null, user);
});

passport.deserializeUser(function(obj, done) {
  done(null, obj);
});

// 路由
app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile', 'email'] }));

app.get('/auth/google/callback', 
  passport.authenticate('google', { failureRedirect: '/login' }),
  function(req, res) {
    // 认证成功，重定向到主页
    res.redirect('/');
  });

app.get('/', (req, res) => {
  if (req.isAuthenticated()) {
    res.send(`Hello, ${req.user.displayName}!`);
  } else {
    res.send('Please login <a href="/auth/google">with Google</a>');
  }
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

### 2.3 Passport.js
Passport.js是Node.js中最流行的身份验证中间件，支持超过500种身份验证策略。

#### 代码示例：使用Passport.js实现本地身份验证

```javascript
const express = require('express');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const session = require('express-session');
const bcrypt = require('bcrypt');

const app = express();

// 模拟用户数据库
const users = [
  {
    id: 1,
    username: 'admin',
    password: '$2b$10$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW' // 密码: password
  }
];

// 配置中间件
app.use(express.urlencoded({ extended: true }));
app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: true
}));
app.use(passport.initialize());
app.use(passport.session());

// 配置本地策略
passport.use(new LocalStrategy(
  function(username, password, done) {
    const user = users.find(u => u.username === username);
    if (!user) {
      return done(null, false, { message: 'Incorrect username.' });
    }
    
    bcrypt.compare(password, user.password, (err, result) => {
      if (err) return done(err);
      if (!result) {
        return done(null, false, { message: 'Incorrect password.' });
      }
      return done(null, user);
    });
  }
));

// 序列化和反序列化用户
passport.serializeUser(function(user, done) {
  done(null, user.id);
});

passport.deserializeUser(function(id, done) {
  const user = users.find(u => u.id === id);
  done(null, user);
});

// 路由
app.get('/login', (req, res) => {
  res.send(`
    <form action="/login" method="post">
      <div>
        <label>Username:</label>
        <input type="text" name="username"/>
      </div>
      <div>
        <label>Password:</label>
        <input type="password" name="password"/>
      </div>
      <div>
        <input type="submit" value="Login"/>
      </div>
    </form>
  `);
});

app.post('/login',
  passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' })
);

app.get('/', (req, res) => {
  if (req.isAuthenticated()) {
    res.send(`Hello, ${req.user.username}! <a href="/logout">Logout</a>`);
  } else {
    res.send('Please login <a href="/login">here</a>');
  }
});

app.get('/logout', (req, res) => {
  req.logout();
  res.redirect('/');
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

## 3. 授权实现

### 3.1 基于角色的访问控制(RBAC)
RBAC是一种常见的授权模型，根据用户的角色来控制对资源的访问。

#### 代码示例：实现RBAC中间件

```javascript
// 角色中间件
function checkRole(roles) {
  return function(req, res, next) {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: 'Unauthorized' });
    }
    
    if (roles.includes(req.user.role)) {
      return next();
    }
    
    return res.status(403).json({ message: 'Forbidden' });
  };
}

// 使用示例
app.get('/admin', checkRole(['admin']), (req, res) => {
  res.send('Admin Dashboard');
});

app.get('/user', checkRole(['user', 'admin']), (req, res) => {
  res.send('User Dashboard');
});
```

### 3.2 JWT授权
使用JWT进行授权时，通常将用户角色信息存储在JWT的payload中，然后在中间件中验证用户是否有权限访问资源。

#### 代码示例：JWT授权中间件

```javascript
const jwt = require('jsonwebtoken');
const secretKey = 'your-secret-key';

// JWT验证中间件
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ message: 'Token missing' });
  }
  
  jwt.verify(token, secretKey, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid token' });
    }
    
    req.user = user;
    next();
  });
}

// 角色授权中间件
function authorizeRole(roles) {
  return function(req, res, next) {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Insufficient permissions' });
    }
    next();
  };
}

// 使用示例
app.get('/protected', authenticateToken, (req, res) => {
  res.json({ message: 'Protected resource', user: req.user });
});

app.get('/admin-only', authenticateToken, authorizeRole(['admin']), (req, res) => {
  res.json({ message: 'Admin-only resource' });
});
```

## 4. 最佳实践

### 4.1 密码安全
- 使用强密码哈希算法（如bcrypt、Argon2）
- 实现密码复杂度要求
- 定期要求用户更新密码
- 禁止使用常见密码
- 实现密码重置机制

### 4.2 会话安全
- 使用安全的Cookie设置（HttpOnly、Secure、SameSite）
- 实现会话超时
- 防止会话固定攻击
- 使用安全的会话存储（如Redis）

### 4.3 JWT安全
- 使用强密钥
- 设置合理的过期时间
- 实现令牌刷新机制
- 不要在JWT中存储敏感信息
- 使用HTTPS传输JWT

### 4.4 多因素认证(MFA)
- 为敏感操作启用MFA
- 支持多种MFA方式（短信、邮件、TOTP应用）
- 实现MFA恢复机制

### 4.5 安全头
- 设置适当的CORS策略
- 启用CSRF保护
- 设置安全相关的HTTP头（如Content-Security-Policy、X-Frame-Options）

## 5. 常见库和框架

### 5.1 身份验证库
- **Passport.js**: 灵活的身份验证中间件
- **jsonwebtoken**: JWT生成和验证
- **bcrypt**: 密码哈希
- **argon2**: 现代密码哈希算法
- **Auth0**: 完整的身份验证和授权平台
- **Okta**: 企业级身份管理

### 5.2 授权库
- **casl**: 基于能力的授权库
- **accesscontrol**: 基于角色的授权库
- **express-acl**: Express的ACL中间件

## 6. 总结

身份验证和授权是Web应用安全的核心组成部分。在Node.js生态系统中，有多种成熟的库和框架可以帮助开发者实现安全可靠的身份验证和授权机制。选择合适的身份验证策略和授权模型，结合最佳实践，可以有效地保护应用和用户数据的安全。

在实际开发中，建议根据应用的需求和规模选择合适的解决方案：
- 小型应用可以使用Passport.js结合本地策略或JWT
- 中型应用可以考虑使用OAuth2.0或OpenID Connect
- 大型应用或企业级应用可以考虑使用Auth0、Okta等完整的身份管理平台

无论选择哪种解决方案，都应该始终关注安全最佳实践，定期更新依赖库，及时修复安全漏洞。