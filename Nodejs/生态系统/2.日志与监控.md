# 日志与监控

## 1. 日志基础

### 1.1 日志的重要性
日志是应用程序运行状态的记录，对于：
- 调试和故障排除
- 性能分析和优化
- 安全审计和合规性
- 业务分析和决策
- 监控和告警

### 1.2 日志级别
常见的日志级别（从低到高）：
- **TRACE**: 最详细的日志，用于开发和调试
- **DEBUG**: 调试信息，用于开发和测试环境
- **INFO**: 常规运行信息，如服务启动、配置加载
- **WARN**: 警告信息，如 deprecated 功能使用、资源不足
- **ERROR**: 错误信息，如异常抛出、API调用失败
- **FATAL**: 致命错误，如服务崩溃、数据库连接失败

### 1.3 日志格式
常见的日志格式：
- 文本格式：易于阅读，适合开发环境
- JSON格式：易于机器解析，适合生产环境和日志聚合
- 结构化格式：包含时间戳、日志级别、模块、消息等字段

## 2. 常见日志库

### 2.1 Winston
Winston是Node.js中最流行的日志库之一，支持多种传输方式和灵活的配置。

#### 代码示例：使用Winston配置日志

```javascript
const winston = require('winston');

// 创建日志记录器
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    winston.format.errors({
      stack: true
    }),
    winston.format.splat(),
    process.env.NODE_ENV === 'production' ?
      winston.format.json() :
      winston.format.simple()
  ),
  defaultMeta: { service: 'user-service' },
  transports: [
    // 错误日志输出到文件
    new winston.transports.File({
      filename: 'error.log',
      level: 'error'
    }),
    // 所有日志输出到文件
    new winston.transports.File({
      filename: 'combined.log'
    })
  ]
});

// 开发环境下输出到控制台
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

// 使用示例
logger.info('服务启动成功');
logger.warn('内存使用率超过80%');
try {
  // 可能抛出错误的代码
  throw new Error('测试错误');
} catch (error) {
  logger.error('发生错误', error);
}
```

### 2.2 Pino
Pino是一个高性能的日志库，专注于速度和低开销，适合高流量应用。

#### 代码示例：使用Pino配置日志

```javascript
const pino = require('pino');

// 创建日志记录器
const logger = pino({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  timestamp: pino.stdTimeFunctions.isoTime,
  base: {
    service: 'user-service',
    pid: process.pid
  },
  transport: {
    targets: [
      {
        level: 'error',
        target: 'pino/file',
        options: {
          destination: './error.log'
        }
      },
      {
        level: 'info',
        target: 'pino/file',
        options: {
          destination: './combined.log'
        }
      },
      {
        level: 'debug',
        target: 'pino-pretty',
        options: {
          colorize: true
        }
      }
    ]
  }
});

// 使用示例
logger.info('服务启动成功');
logger.warn('内存使用率超过80%');
try {
  // 可能抛出错误的代码
  throw new Error('测试错误');
} catch (error) {
  logger.error(error, '发生错误');
}
```

### 2.3 Bunyan
Bunyan是一个结构化日志库，输出JSON格式的日志，适合大型应用和日志聚合。

#### 代码示例：使用Bunyan配置日志

```javascript
const bunyan = require('bunyan');

// 创建日志记录器
const logger = bunyan.createLogger({
  name: 'user-service',
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  streams: [
    {
      level: 'error',
      path: './error.log'
    },
    {
      level: 'info',
      path: './combined.log'
    },
    {
      level: 'debug',
      stream: process.stdout
    }
  ],
  serializers: {
    err: bunyan.stdSerializers.err,
    req: bunyan.stdSerializers.req,
    res: bunyan.stdSerializers.res
  }
});

// 使用示例
logger.info('服务启动成功');
logger.warn('内存使用率超过80%');
try {
  // 可能抛出错误的代码
  throw new Error('测试错误');
} catch (error) {
  logger.error({ err: error }, '发生错误');
}
```

## 3. 日志管理

### 3.1 日志存储
- **本地文件**: 简单易用，但不适合大规模应用
- **日志聚合服务**: 如ELK Stack(Elasticsearch, Logstash, Kibana)、Graylog、Splunk
- **云服务**: AWS CloudWatch Logs、Google Cloud Logging、Azure Monitor

### 3.2 日志轮转
日志轮转是指定期创建新日志文件，防止单个日志文件过大。常见的日志轮转策略：
- 按大小轮转
- 按时间轮转（每天、每周、每月）
- 保留一定数量的旧日志文件

#### 代码示例：使用winston-daily-rotate-file实现日志轮转

```javascript
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new DailyRotateFile({
      filename: 'application-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d'
    })
  ]
});
```

### 3.3 日志查询和分析
使用日志聚合服务可以方便地查询和分析日志：
- 全文搜索
- 按字段过滤
- 时间范围查询
- 日志可视化
- 告警和通知

## 4. 监控基础

### 4.1 监控的类型
- **健康监控**: 检查服务是否正常运行
- **性能监控**: 监控响应时间、吞吐量、资源使用率等
- **错误监控**: 监控错误率、异常类型和频率
- **业务监控**: 监控业务指标，如用户注册数、订单量等

### 4.2 监控指标
常见的监控指标：
- **响应时间**: 平均响应时间、P95、P99等
- **吞吐量**: 每秒请求数(RPS)
- **错误率**: 错误请求占总请求的比例
- **资源使用率**: CPU、内存、磁盘、网络
- **数据库指标**: 查询响应时间、连接数、慢查询数
- **中间件指标**: 队列长度、消息处理速率

## 5. 常见监控工具

### 5.1 Prometheus + Grafana
Prometheus是一个开源的监控和告警系统，Grafana用于数据可视化。

#### 代码示例：使用prom-client暴露监控指标

```javascript
const express = require('express');
const client = require('prom-client');

const app = express();

// 收集默认指标
client.collectDefaultMetrics();

// 自定义指标
const httpRequestDurationMicroseconds = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.5, 1, 2.5, 5]
});

// 监控中间件
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDurationMicroseconds.labels(req.method, req.route?.path || req.path, res.statusCode).observe(duration);
  });
  
  next();
});

// 暴露指标端点
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.send(await client.register.metrics());
});

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

### 5.2 New Relic
New Relic是一个全栈监控平台，提供应用性能监控、基础设施监控和错误监控。

#### 代码示例：使用New Relic监控Node.js应用

```javascript
// 在应用入口文件的最顶部引入
require('newrelic');

const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

### 5.3 Datadog
Datadog是一个云原生监控平台，支持基础设施、应用和日志监控。

### 5.4 PM2
PM2是Node.js应用的进程管理器，同时提供基本的监控功能。

#### 代码示例：使用PM2启动和监控应用

```bash
# 安装PM2
npm install -g pm2

# 启动应用
pm2 start app.js --name "user-service"

# 查看监控面板
pm2 monit

# 查看应用状态
pm2 status

# 查看日志
pm2 logs
```

## 6. 错误监控

### 6.1 错误监控的重要性
错误监控可以帮助开发者及时发现和修复应用中的错误，提高应用的可靠性和用户体验。

### 6.2 常见错误监控工具
- **Sentry**: 实时错误监控和崩溃报告
- **Bugsnag**: 错误监控和诊断
- **Rollbar**: 实时错误监控和告警
- **Airbrake**: 错误监控和性能监控

#### 代码示例：使用Sentry监控错误

```javascript
// 在应用入口文件的最顶部引入
const Sentry = require('@sentry/node');
const express = require('express');

// 初始化Sentry
Sentry.init({
  dsn: 'your-sentry-dsn',
  integrations: [
    new Sentry.Integrations.Http({ tracing: true }),
    new Sentry.Integrations.Express({ app })
  ],
  tracesSampleRate: 1.0
});

const app = express();

// Sentry中间件
app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());

app.get('/', (req, res) => {
  throw new Error('测试错误');
  res.send('Hello World!');
});

// Sentry错误处理中间件
app.use(Sentry.Handlers.errorHandler());

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

## 7. 最佳实践

### 7.1 日志最佳实践
- 根据环境设置适当的日志级别
- 使用结构化日志格式
- 包含足够的上下文信息（如请求ID、用户ID、时间戳）
- 不要在日志中记录敏感信息（如密码、API密钥）
- 实现日志轮转和归档
- 使用日志聚合服务进行集中管理
- 定期清理旧日志

### 7.2 监控最佳实践
- 监控关键业务指标和技术指标
- 设置合理的告警阈值
- 使用多级告警策略（如警告、严重、紧急）
- 实现告警通知（如邮件、Slack、短信）
- 定期审查和优化监控配置
- 建立监控仪表盘，方便实时查看系统状态
- 实现分布式追踪，便于分析复杂系统的性能问题

### 7.3 性能监控最佳实践
- 监控端到端响应时间
- 识别性能瓶颈（如数据库查询、外部API调用）
- 定期进行性能测试和基准测试
- 实现自动扩缩容，根据负载调整资源
- 优化慢查询和高CPU使用率的代码

## 8. 总结

日志和监控是Node.js应用生态系统中的重要组成部分，对于确保应用的可靠性、性能和安全性至关重要。选择合适的日志库和监控工具，结合最佳实践，可以帮助开发者更好地了解应用运行状态，及时发现和解决问题，优化应用性能。

在实际开发中，建议：
- 从小规模开始，逐步扩展日志和监控体系
- 根据应用的规模和需求选择合适的工具
- 定期审查和优化日志和监控配置
- 建立完善的告警和响应机制
- 结合日志和监控数据，进行根因分析和持续优化

通过有效的日志和监控策略，可以显著提高应用的可靠性、性能和可维护性，为用户提供更好的体验。