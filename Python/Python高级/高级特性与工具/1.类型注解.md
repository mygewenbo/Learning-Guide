# 类型注解

## 1. 类型注解概述

类型注解是Python 3.5引入的特性，它允许开发者为变量、函数参数和返回值添加类型信息。类型注解的主要目的是：
- 提高代码的可读性和可维护性
- 帮助IDE提供更好的代码补全和错误提示
- 支持静态类型检查工具（如mypy、pytype）
- 为文档生成工具提供更丰富的信息

类型注解不会影响Python代码的运行时行为，它们只是一种元数据，供静态分析工具使用。

## 2. 基本类型注解

### 2.1 变量注解

Python 3.6引入了变量注解语法，可以直接为变量添加类型注解：

```python
# 基本类型
age: int = 30
name: str = "Alice"
is_student: bool = True
height: float = 1.75

# 容器类型
primes: list[int] = [2, 3, 5, 7, 11]
scores: dict[str, int] = {"math": 90, "english": 85}
coordinates: tuple[float, float] = (10.0, 20.0)

# 可选类型
from typing import Optional

# 表示可能为None的值
optional_name: Optional[str] = None

# Python 3.10+ 支持 | 语法
optional_age: int | None = None
```

### 2.2 函数注解

可以为函数的参数和返回值添加类型注解：

```python
# 基本函数注解
def greet(name: str, age: int) -> str:
    return f"Hello, {name}! You are {age} years old."

# 带有默认值的参数
def calculate_discount(price: float, discount_rate: float = 0.1) -> float:
    return price * (1 - discount_rate)

# 可变参数
def sum_numbers(*numbers: int) -> int:
    return sum(numbers)

# 关键字参数
def create_user(**kwargs: str) -> dict[str, str]:
    return kwargs
```

### 2.3 类注解

可以为类的属性和方法添加类型注解：

```python
class User:
    # 类属性注解
    total_users: int = 0
    
    # 实例属性注解
    name: str
    age: int
    email: Optional[str]
    
    def __init__(self, name: str, age: int, email: Optional[str] = None) -> None:
        self.name = name
        self.age = age
        self.email = email
        User.total_users += 1
    
    # 方法注解
    def update_age(self, new_age: int) -> None:
        self.age = new_age
    
    def get_user_info(self) -> dict[str, str | int | None]:
        return {
            "name": self.name,
            "age": self.age,
            "email": self.email
        }
```

## 3. 高级类型注解

### 3.1 泛型类型

泛型类型允许我们为容器类型指定元素的具体类型：

```python
from typing import List, Dict, Tuple, Set, Optional

# 列表泛型
numbers: List[int] = [1, 2, 3, 4, 5]

# 字典泛型
user_scores: Dict[str, int] = {"Alice": 90, "Bob": 85}

# 元组泛型
coordinate: Tuple[float, float] = (10.0, 20.0)

# 集合泛型
unique_numbers: Set[int] = {1, 2, 3, 4, 5}

# 可选类型
optional_value: Optional[str] = None
```

### 3.2 联合类型

联合类型表示一个值可以是多种类型中的一种：

```python
from typing import Union

# Python 3.9- 使用 Union
number: Union[int, float] = 3.14

# Python 3.10+ 支持 | 语法
number: int | float = 3.14

# 更复杂的联合类型
result: str | int | None = "success"
```

### 3.3 字面量类型

字面量类型表示一个值只能是特定的字面量：

```python
from typing import Literal

# 字符串字面量
direction: Literal["north", "south", "east", "west"] = "north"

# 数值字面量
status_code: Literal[200, 400, 404, 500] = 200

# 布尔字面量
bool_literal: Literal[True] = True
```

### 3.4 类型别名

类型别名允许我们为复杂的类型创建一个更简单的名称：

```python
from typing import List, Dict, Tuple

# 简单类型别名
UserId = int
Username = str

# 复杂类型别名
UserInfo = Dict[str, str | int | None]
Coordinates = Tuple[float, float]

# 使用类型别名
def get_user_info(user_id: UserId) -> UserInfo:
    return {
        "id": user_id,
        "name": "Alice",
        "age": 30,
        "email": "alice@example.com"
    }
```

### 3.5 泛型类型变量

泛型类型变量允许我们创建通用的函数和类：

```python
from typing import TypeVar, List

# 创建类型变量
T = TypeVar("T")

# 通用函数
def reverse_list(items: List[T]) -> List[T]:
    return items[::-1]

# 使用通用函数
numbers = [1, 2, 3, 4, 5]
reversed_numbers = reverse_list(numbers)  # 类型为 List[int]

strings = ["a", "b", "c"]
reversed_strings = reverse_list(strings)  # 类型为 List[str]
```

### 3.6 协议类型

协议类型允许我们定义鸭子类型的接口：

```python
from typing import Protocol

# 定义协议
class SupportsLength(Protocol):
    def __len__(self) -> int: ...

# 使用协议
def get_length(obj: SupportsLength) -> int:
    return len(obj)

# 支持协议的类型
print(get_length([1, 2, 3]))  # 3
print(get_length("hello"))  # 5
print(get_length({"a": 1, "b": 2}))  # 2
```

## 4. 特殊类型注解

### 4.1 Self类型

Self类型用于标注返回自身实例的方法：

```python
from typing import Self

class MyLock:
    def __enter__(self) -> Self:
        self.lock()
        return self
    
    def lock(self) -> None:
        # 实现锁逻辑
        pass
    
    def unlock(self) -> None:
        # 实现解锁逻辑
        pass
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        self.unlock()

class MyInt:
    def __init__(self, value: int) -> None:
        self.value = value
    
    @classmethod
    def fromhex(cls, s: str) -> Self:
        return cls(int(s, 16))
    
    def __add__(self, other: Self) -> Self:
        return MyInt(self.value + other.value)
```

### 4.2 Annotated类型

Annotated类型允许我们为类型添加自定义元数据：

```python
from typing import Annotated, get_origin, get_args
from dataclasses import dataclass

# 定义元数据
@dataclass
class ValueRange:
    lo: int
    hi: int

@dataclass
class MaxLen:
    value: int

# 使用Annotated
type Password = Annotated[str, "secret"]
type Age = Annotated[int, ValueRange(0, 120)]
type Vec[T] = Annotated[list[tuple[T, T]], MaxLen(10)]

# 访问原始类型
print(get_origin(Password))  # <class 'str'>

# 访问元数据
print(get_args(Password))  # ('secret',)

# 使用泛型Annotated
type IntVec = Vec[int]  # 相当于 Annotated[list[tuple[int, int]], MaxLen(10)]

# 嵌套Annotated会被展平
NestedAnnotated = Annotated[Annotated[int, "first"], "second"]
print(get_args(NestedAnnotated))  # ('first', 'second')
```

### 4.3 类对象类型

使用`type[...]`来标注类对象本身，而不是类的实例：

```python
from typing import Type

class User: ...
class ProUser(User): ...
class TeamUser(User): ...

# 标注类对象类型
def make_new_user(user_class: type[User]) -> User:
    return user_class()

# 正确使用
make_new_user(User)      # OK
make_new_user(ProUser)   # OK: type[ProUser] 是 type[User] 的子类型
make_new_user(TeamUser)  # OK

# 错误使用
# make_new_user(User())    # Error: 期望 type[User] 但得到 User
# make_new_user(int)       # Error: type[int] 不是 type[User] 的子类型

# 使用 Union
from typing import Union

def new_non_team_user(user_class: type[User | ProUser]) -> User:
    return user_class()
```

## 5. 类型检查工具

### 5.1 mypy

mypy是最流行的Python静态类型检查工具：

```bash
pip install mypy
```

使用mypy检查代码：

```bash
mypy your_script.py
```

### 5.2 pytype

pytype是Google开发的静态类型检查工具：

```bash
pip install pytype
```

使用pytype检查代码：

```bash
pytype your_script.py
```

### 5.3 pyright

pyright是Microsoft开发的静态类型检查工具，速度非常快：

```bash
pip install pyright
```

使用pyright检查代码：

```bash
pyright your_script.py
```

## 6. 类型注解最佳实践

### 6.1 不要过度使用类型注解

对于简单的脚本和原型代码，过度使用类型注解可能会降低代码的可读性和开发效率。

### 6.2 使用具体类型而非抽象类型

在函数参数中，使用具体类型（如`list`、`dict`）可以提供更精确的类型信息；在返回值中，使用抽象类型（如`Sequence`、`Mapping`）可以提供更好的灵活性。

```python
from typing import Sequence, Mapping

# 好的做法：参数使用具体类型，返回值使用抽象类型
def process_items(items: list[str]) -> Sequence[str]:
    return items[::-1]

def get_user_info() -> Mapping[str, str | int]:
    return {"name": "Alice", "age": 30}
```

### 6.3 使用类型别名简化复杂类型

对于复杂的类型，使用类型别名可以提高代码的可读性：

```python
# 不好的做法：复杂类型直接使用

def process_data(data: list[dict[str, str | int | list[float]]]) -> dict[str, list[float]]:
    ...

# 好的做法：使用类型别名

from typing import List, Dict, Tuple

DataType = List[Dict[str, str | int | List[float]]]
ResultType = Dict[str, List[float]]

def process_data(data: DataType) -> ResultType:
    ...
```

### 6.4 为公共API添加类型注解

为公共API添加类型注解可以提高API的可用性和可维护性，帮助使用者更好地理解API的用法。

### 6.5 使用类型检查工具

在开发过程中，定期使用类型检查工具可以帮助发现潜在的类型错误，提高代码质量。

## 7. 类型注解的局限性

### 7.1 运行时开销

虽然类型注解本身不会影响Python代码的运行时行为，但在某些情况下，类型检查和类型转换可能会带来一定的运行时开销。

### 7.2 动态类型的限制

Python是一种动态类型语言，类型注解无法完全捕捉Python的动态特性。例如，类型注解无法处理运行时动态添加的属性和方法。

### 7.3 学习曲线

对于初学者来说，类型注解可能会增加学习曲线，需要掌握各种类型注解的语法和用法。

## 8. 总结

类型注解是Python的一项重要特性，它可以提高代码的可读性、可维护性和可靠性。通过使用类型注解，我们可以：

- 为变量、函数参数和返回值添加类型信息
- 支持静态类型检查工具
- 帮助IDE提供更好的代码补全和错误提示
- 为文档生成工具提供更丰富的信息

在实际开发中，我们应该根据项目的需求和团队的习惯，合理使用类型注解，不要过度使用，也不要完全不使用。通过结合类型检查工具，我们可以充分发挥类型注解的优势，提高代码质量和开发效率。