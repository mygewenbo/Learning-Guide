# Solidity基础语法

## 一、合约结构

### 1.1 合约基本结构

一个完整的Solidity合约通常包含以下部分：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 导入其他合约或库
import "./OtherContract.sol";

// 合约定义
contract MyContract {
    // 状态变量
    uint256 public myNumber;
    string public myString;
    
    // 事件定义
    event NumberChanged(uint256 oldValue, uint256 newValue);
    
    // 构造函数
    constructor(uint256 initialNumber) {
        myNumber = initialNumber;
        myString = "Hello";
    }
    
    // 函数定义
    function setNumber(uint256 newNumber) public {
        uint256 oldValue = myNumber;
        myNumber = newNumber;
        emit NumberChanged(oldValue, newNumber);
    }
    
    function getNumber() public view returns (uint256) {
        return myNumber;
    }
}
```

### 1.2  SPDX许可证标识符
- 用于指定合约的许可证类型
- 必须放在文件的第一行
- 常用许可证：MIT、GPL-3.0、Apache-2.0
- 示例：`// SPDX-License-Identifier: MIT`

### 1.3 版本指令
- 指定合约兼容的Solidity版本范围
- 使用语义化版本控制
- 示例：
  ```solidity
  // 兼容0.8.x版本
  pragma solidity ^0.8.0;
  
  // 兼容0.7.0到0.9.0之间的版本（不包括0.9.0）
  pragma solidity >=0.7.0 <0.9.0;
  ```

## 二、数据类型

### 2.1 值类型

#### 2.1.1 布尔类型
- `bool`：布尔值，只能是`true`或`false`
- 示例：
  ```solidity
  bool public isActive = true;
  ```

#### 2.1.2 整数类型
- 有符号整数：`int8`到`int256`（步长为8）
- 无符号整数：`uint8`到`uint256`（步长为8）
- 默认整数类型：`uint`（等同于`uint256`）
- 示例：
  ```solidity
  uint8 public smallNumber = 255;
  uint public bigNumber = 123456789;
  int public negativeNumber = -42;
  ```

#### 2.1.3 地址类型
- `address`：20字节的以太坊地址
- `address payable`：可接收以太币的地址
- 示例：
  ```solidity
  address public myAddress = 0x1234567890123456789012345678901234567890;
  address payable public myPayableAddress = payable(0x1234567890123456789012345678901234567890);
  ```

#### 2.1.4 字节类型
- 固定长度字节：`bytes1`到`bytes32`
- 示例：
  ```solidity
  bytes1 public b1 = 0x12;
  bytes2 public b2 = 0x1234;
  ```

#### 2.1.5 枚举类型
- 自定义类型，用于表示一组离散值
- 示例：
  ```solidity
  enum Status { Pending, Active, Completed, Canceled }
  Status public currentStatus = Status.Pending;
  ```

### 2.2 引用类型

#### 2.2.1 数组
- 固定大小数组：`type[size]`
- 动态大小数组：`type[]`
- 示例：
  ```solidity
  // 固定大小数组
  uint[5] public fixedArray = [1, 2, 3, 4, 5];
  
  // 动态大小数组
  uint[] public dynamicArray;
  
  function addToArray(uint value) public {
      dynamicArray.push(value);
  }
  ```

#### 2.2.2 结构体
- 自定义复合数据类型
- 示例：
  ```solidity
  struct Person {
      string name;
      uint age;
      address wallet;
  }
  
  Person public person = Person("Alice", 30, 0x1234567890123456789012345678901234567890);
  ```

#### 2.2.3 映射
- 键值对存储结构
- 示例：
  ```solidity
  mapping(address => uint) public balances;
  mapping(string => mapping(address => bool)) public permissions;
  
  function setBalance(address user, uint amount) public {
      balances[user] = amount;
  }
  ```

#### 2.2.4 字符串
- `string`：动态大小的UTF-8编码字符串
- 示例：
  ```solidity
  string public myString = "Hello, Solidity!";
  ```

## 三、变量和作用域

### 3.1 状态变量
- 存储在区块链上的变量
- 合约级别的变量
- 可以被所有函数访问
- 示例：
  ```solidity
  contract MyContract {
      uint256 public stateVariable = 42;
  }
  ```

### 3.2 局部变量
- 只在函数内部可见的变量
- 存储在内存中，函数执行完毕后消失
- 示例：
  ```solidity
  function myFunction() public {
      uint256 localVariable = 100;
      // 只能在函数内部访问
  }
  ```

### 3.3 全局变量
- Solidity内置的全局变量
- 提供区块链和交易的相关信息
- 常用全局变量：
  - `block.timestamp`：当前块的时间戳
  - `block.number`：当前块号
  - `msg.sender`：当前调用者的地址
  - `msg.value`：当前调用发送的以太币数量
  - `gasleft()`：剩余的gas量
- 示例：
  ```solidity
  function getBlockInfo() public view returns (uint, uint, address) {
      return (block.timestamp, block.number, msg.sender);
  }
  ```

## 四、函数

### 4.1 函数定义
- 基本语法：
  ```solidity
  function functionName(parameterType parameterName) visibility modifier returns (returnType) {
      // 函数体
  }
  ```

### 4.2 函数可见性
- `public`：可以被内部和外部调用
- `private`：只能在当前合约内部调用
- `internal`：可以在当前合约和继承合约中调用
- `external`：只能从外部调用

### 4.3 函数修饰符
- `view`：只读函数，不修改状态
- `pure`：纯函数，不读取也不修改状态
- `payable`：可以接收以太币的函数
- `override`：重写父合约的函数

### 4.4 函数返回值
- 可以返回多个值
- 可以命名返回值
- 示例：
  ```solidity
  // 返回多个值
  function getMultipleValues() public pure returns (uint, string memory) {
      return (42, "Hello");
  }
  
  // 命名返回值
  function getNamedValues() public pure returns (uint x, string memory y) {
      x = 42;
      y = "Hello";
  }
  ```

## 五、控制流

### 5.1 条件语句
- `if-else`语句
- 示例：
  ```solidity
  function checkNumber(uint number) public pure returns (string memory) {
      if (number > 0) {
          return "Positive";
      } else if (number < 0) {
          return "Negative";
      } else {
          return "Zero";
      }
  }
  ```

### 5.2 循环语句

#### 5.2.1 for循环
- 示例：
  ```solidity
  function sumArray(uint[] memory array) public pure returns (uint) {
      uint sum = 0;
      for (uint i = 0; i < array.length; i++) {
          sum += array[i];
      }
      return sum;
  }
  ```

#### 5.2.2 while循环
- 示例：
  ```solidity
  function countDown(uint start) public pure returns (uint[] memory) {
      uint[] memory result = new uint[](start + 1);
      uint i = 0;
      while (start >= 0) {
          result[i] = start;
          start--;
          i++;
      }
      return result;
  }
  ```

#### 5.2.3 do-while循环
- 示例：
  ```solidity
  function doWhileExample(uint start) public pure returns (uint) {
      uint count = 0;
      do {
          count++;
          start--;
      } while (start > 0);
      return count;
  }
  ```

### 5.3 异常处理
- `require`：验证条件，如果不满足则回滚
- `revert`：显式回滚交易
- `assert`：用于内部错误检查
- 示例：
  ```solidity
  function withdraw(uint amount) public {
      // 验证余额是否充足
      require(balances[msg.sender] >= amount, "Insufficient balance");
      
      // 执行转账
      balances[msg.sender] -= amount;
      
      // 显式回滚示例
      if (someCondition) {
          revert("Transaction failed due to some condition");
      }
      
      // 内部错误检查
      assert(balances[msg.sender] >= 0);
  }
  ```

## 六、事件和日志

### 6.1 事件定义
- 用于记录合约状态变化
- 可以被外部应用监听
- 示例：
  ```solidity
  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);
  ```

### 6.2 事件触发
- 使用`emit`关键字触发事件
- 示例：
  ```solidity
  function transfer(address to, uint256 value) public returns (bool) {
      // 转账逻辑
      emit Transfer(msg.sender, to, value);
      return true;
  }
  ```

### 6.3 事件索引
- 使用`indexed`关键字标记可索引的事件参数
- 每个事件最多可以有3个索引参数
- 索引参数可以用于高效过滤事件

## 七、练习

1. 创建一个合约，包含不同类型的状态变量
2. 编写函数来修改和查询这些状态变量
3. 实现一个简单的计数器合约，包含增加、减少和重置功能
4. 创建一个结构体来表示用户信息，并实现相关的CRUD操作
5. 编写一个函数，使用循环计算斐波那契数列

## 八、总结

通过本章的学习，你已经掌握了Solidity的基础语法，包括合约结构、数据类型、变量、函数、控制流和事件等核心概念。这些是编写智能合约的基础，后续章节将深入学习Solidity的进阶特性和最佳实践。

在下一章中，我们将学习智能合约的基础知识，包括合约生命周期、状态管理和合约交互等内容。