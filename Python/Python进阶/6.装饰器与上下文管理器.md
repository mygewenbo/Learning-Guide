# 装饰器与上下文管理器

## 一、装饰器概述

### 1.1 什么是装饰器

装饰器（Decorator）是Python中用于修改函数或类行为的一种高级特性，它允许在不修改原函数代码的情况下，对函数的功能进行扩展或修改。

装饰器的主要特点是：
- 不修改原函数的代码
- 不改变原函数的调用方式
- 可以在函数执行前后添加额外的功能
- 可以嵌套使用

### 1.2 装饰器的应用场景

装饰器在Python中有广泛的应用，常见的应用场景包括：
- 日志记录
- 性能测试
- 权限验证
- 缓存
- 事务处理
- 输入验证

## 二、装饰器基础

### 2.1 装饰器的基本语法

装饰器的基本语法是使用`@装饰器名`放在函数定义的前面。

**示例**：

```python
# 定义装饰器
def simple_decorator(func):
    def wrapper():
        print("函数执行前")
        func()
        print("函数执行后")
    return wrapper

# 使用装饰器
@simple_decorator
def hello():
    print("Hello, World!")

# 调用函数
hello()
# 输出：
# 函数执行前
# Hello, World!
# 函数执行后
```

### 2.2 装饰器的工作原理

装饰器的工作原理是：
1. 定义一个装饰器函数，该函数接收一个函数作为参数
2. 在装饰器函数内部定义一个包装函数（wrapper）
3. 在包装函数中调用原函数，并添加额外的功能
4. 返回包装函数
5. 使用`@装饰器名`语法将装饰器应用到目标函数上
6. 当调用目标函数时，实际上是调用了装饰器返回的包装函数

**示例**：

```python
# 装饰器的工作原理演示
def decorator(func):
    print(f"装饰器被调用，装饰的函数是：{func.__name__}")
    
    def wrapper():
        print(f"包装函数执行，调用的函数是：{func.__name__}")
        return func()
    
    return wrapper

@decorator
def greet():
    return "Hello!"

print("\n调用greet()函数：")
result = greet()
print(f"函数返回值：{result}")
```

### 2.3 装饰带有参数的函数

装饰器可以装饰带有参数的函数，只需要在包装函数中接收并传递这些参数。

**示例**：

```python
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print(f"函数执行前，参数：args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"函数执行后，返回值：{result}")
        return result
    return wrapper

@decorator_with_args
def add(a, b):
    return a + b

@decorator_with_args
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

# 调用函数
print("\n调用add(1, 2)：")
add(1, 2)

print("\n调用greet('Alice')：")
greet('Alice')

print("\n调用greet('Bob', greeting='Hi')：")
greet('Bob', greeting='Hi')
```

### 2.4 保留原函数的元信息

使用装饰器时，原函数的元信息（如函数名、文档字符串、参数列表等）会丢失，需要使用`functools.wraps`装饰器来保留原函数的元信息。

**示例**：

```python
import functools

# 不使用functools.wraps的装饰器
def bad_decorator(func):
    def wrapper(*args, **kwargs):
        """包装函数的文档字符串"""
        return func(*args, **kwargs)
    return wrapper

# 使用functools.wraps的装饰器
def good_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        """包装函数的文档字符串"""
        return func(*args, **kwargs)
    return wrapper

@bad_decorator
def example():
    """示例函数的文档字符串"""
    pass

@good_decorator
def example2():
    """示例函数2的文档字符串"""
    pass

print("不使用functools.wraps的装饰器：")
print(f"函数名：{example.__name__}")
print(f"文档字符串：{example.__doc__}")

print("\n使用functools.wraps的装饰器：")
print(f"函数名：{example2.__name__}")
print(f"文档字符串：{example2.__doc__}")
```

## 三、多个装饰器的使用

### 3.1 多个装饰器的应用顺序

当一个函数应用多个装饰器时，装饰器的应用顺序是从下到上（或从右到左）。

**示例**：

```python
import functools

# 装饰器1
def decorator1(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("装饰器1开始执行")
        result = func(*args, **kwargs)
        print("装饰器1执行结束")
        return result
    return wrapper

# 装饰器2
def decorator2(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("装饰器2开始执行")
        result = func(*args, **kwargs)
        print("装饰器2执行结束")
        return result
    return wrapper

# 装饰器3
def decorator3(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("装饰器3开始执行")
        result = func(*args, **kwargs)
        print("装饰器3执行结束")
        return result
    return wrapper

# 应用多个装饰器（从下到上执行）
@decorator1
@decorator2
@decorator3
def hello():
    print("Hello, World!")

# 调用函数
print("调用hello()函数：")
hello()
# 输出顺序：
# 装饰器1开始执行
# 装饰器2开始执行
# 装饰器3开始执行
# Hello, World!
# 装饰器3执行结束
# 装饰器2执行结束
# 装饰器1执行结束
```

### 3.2 多个装饰器的应用场景

多个装饰器可以用于为函数添加多种不同的功能，例如同时添加日志记录、性能测试和权限验证。

**示例**：

```python
import functools
import time

# 日志装饰器
def log_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[日志] 函数 {func.__name__} 开始执行")
        result = func(*args, **kwargs)
        print(f"[日志] 函数 {func.__name__} 执行结束")
        return result
    return wrapper

# 性能测试装饰器
def performance_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"[性能] 函数 {func.__name__} 执行时间：{end_time - start_time:.4f}秒")
        return result
    return wrapper

# 权限验证装饰器
def auth_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 模拟权限验证
        is_authenticated = True
        if is_authenticated:
            print("[权限] 验证通过")
            return func(*args, **kwargs)
        else:
            print("[权限] 验证失败，拒绝访问")
            return None
    return wrapper

# 应用多个装饰器
@log_decorator
@performance_decorator
@auth_decorator
def process_data(data):
    # 模拟数据处理
    time.sleep(0.5)
    return f"处理后的数据：{data.upper()}"

# 调用函数
print("调用process_data('test')函数：")
result = process_data('test')
print(f"函数返回值：{result}")
```

## 四、带参数的装饰器

### 4.1 带参数的装饰器的定义

带参数的装饰器是指装饰器本身可以接收参数，需要在原有装饰器的基础上再嵌套一层函数来接收这些参数。

**示例**：

```python
import functools

# 带参数的装饰器
def decorator_with_params(prefix=""):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"{prefix}函数 {func.__name__} 执行前")
            result = func(*args, **kwargs)
            print(f"{prefix}函数 {func.__name__} 执行后")
            return result
        return wrapper
    return decorator

# 使用带参数的装饰器
@decorator_with_params(prefix="[INFO]")
def hello():
    print("Hello!")

@decorator_with_params(prefix="[DEBUG]")
def add(a, b):
    return a + b

# 调用函数
print("调用hello()函数：")
hello()

print("\n调用add(1, 2)函数：")
result = add(1, 2)
print(f"函数返回值：{result}")
```

### 4.2 带参数装饰器的应用场景

带参数的装饰器可以用于根据不同的参数配置装饰器的行为，例如日志级别、缓存过期时间等。

**示例**：

```python
import functools
import time

# 带参数的缓存装饰器
def cache_decorator(expire=60):
    # 缓存字典
    cache = {}
    
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            key = f"{func.__name__}:{args}:{kwargs}"
            
            # 检查缓存是否存在且未过期
            if key in cache:
                cached_data, timestamp = cache[key]
                if time.time() - timestamp < expire:
                    print(f"[缓存] 命中缓存，键：{key}")
                    return cached_data
                else:
                    print(f"[缓存] 缓存过期，键：{key}")
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache[key] = (result, time.time())
            print(f"[缓存] 缓存结果，键：{key}，过期时间：{expire}秒")
            return result
        return wrapper
    return decorator

# 使用带参数的缓存装饰器
@cache_decorator(expire=5)  # 缓存5秒
@cache_decorator()  # 使用默认过期时间60秒
def expensive_operation(n):
    print(f"执行耗时操作，n={n}")
    time.sleep(1)  # 模拟耗时操作
    return n * 2

# 调用函数
print("第一次调用expensive_operation(10)：")
result1 = expensive_operation(10)
print(f"结果：{result1}")

print("\n第二次调用expensive_operation(10)（应该命中缓存）：")
result2 = expensive_operation(10)
print(f"结果：{result2}")

print("\n等待6秒后第三次调用expensive_operation(10)（缓存应该过期）：")
time.sleep(6)
result3 = expensive_operation(10)
print(f"结果：{result3}")
```

### 4.3 装饰器工厂

带参数的装饰器也被称为装饰器工厂，因为它是一个生成装饰器的函数。

**示例**：

```python
import functools

# 装饰器工厂
def create_decorator(option1, option2):
    """创建一个装饰器，根据参数配置装饰器行为"""
    print(f"创建装饰器，参数：option1={option1}, option2={option2}")
    
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"装饰器执行，配置：option1={option1}, option2={option2}")
            # 根据配置执行不同的逻辑
            if option1:
                print("执行选项1的逻辑")
            if option2:
                print("执行选项2的逻辑")
            return func(*args, **kwargs)
        return wrapper
    
    return decorator

# 使用装饰器工厂创建装饰器
@create_decorator(option1=True, option2=False)
def func1():
    print("执行func1")

@create_decorator(option1=False, option2=True)
def func2():
    print("执行func2")

# 调用函数
print("\n调用func1()：")
func1()

print("\n调用func2()：")
func2()
```

## 五、装饰器的高级应用

### 5.1 装饰类

装饰器不仅可以装饰函数，还可以装饰类，用于修改类的行为或添加额外的功能。类装饰器可以：
- 为类添加属性和方法
- 修改类的初始化过程
- 实现单例模式
- 为类添加日志记录
- 实现类的代理或包装

**示例1：为类添加属性和修改初始化过程**

```python
def class_decorator(cls):
    # 为类添加类属性
    cls.decorated = True
    cls.version = "1.0"
    
    # 保存原有的__init__方法
    original_init = cls.__init__
    
    # 定义新的__init__方法
    def new_init(self, *args, **kwargs):
        print(f"类 {cls.__name__} 被实例化，参数：args={args}, kwargs={kwargs}")
        original_init(self, *args, **kwargs)
        # 为实例添加属性
        self.created_at = "2023-01-01"
    
    # 替换原有的__init__方法
    cls.__init__ = new_init
    
    # 为类添加实例方法
    def greet(self):
        return f"Hello, I'm {self.name}!"
    
    cls.greet = greet
    
    return cls

# 使用装饰器装饰类
@class_decorator
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"Person(name={self.name}, age={self.age})"

# 创建类实例
print("创建Person实例：")
p = Person("Alice", 25)
print(f"实例：{p}")
print(f"实例是否被装饰：{p.decorated}")
print(f"类版本：{Person.version}")
print(f"实例创建时间：{p.created_at}")
print(f"调用添加的方法：{p.greet()}")
```

**示例2：使用类装饰器实现单例模式**

```python
def singleton(cls):
    """单例模式装饰器"""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class DatabaseConnection:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        print(f"创建数据库连接：{host}:{port}")
    
    def connect(self):
        return f"连接到数据库：{self.host}:{self.port}"

# 创建实例
print("第一次创建实例：")
db1 = DatabaseConnection("localhost", 3306)
print(f"db1: {db1}")
print(f"db1连接：{db1.connect()}")

print("\n第二次创建实例（应该返回同一个实例）：")
db2 = DatabaseConnection("localhost", 3306)
print(f"db2: {db2}")
print(f"db2连接：{db2.connect()}")

print(f"\ndb1和db2是否是同一个实例：{db1 is db2}")
```

### 5.2 装饰类方法和静态方法

装饰器可以装饰类方法和静态方法，需要注意装饰器的顺序。

**示例**：

```python
import functools

# 方法装饰器
def method_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"方法 {func.__name__} 执行前")
        result = func(*args, **kwargs)
        print(f"方法 {func.__name__} 执行后")
        return result
    return wrapper

class MyClass:
    def __init__(self, value):
        self.value = value
    
    # 装饰实例方法
    @method_decorator
    def instance_method(self):
        print(f"实例方法执行，实例值：{self.value}")
        return self.value
    
    # 装饰类方法（注意装饰器顺序）
    @classmethod
    @method_decorator
    def class_method(cls):
        print(f"类方法执行，类名：{cls.__name__}")
        return cls.__name__
    
    # 装饰静态方法（注意装饰器顺序）
    @staticmethod
    @method_decorator
    def static_method():
        print("静态方法执行")
        return "static"

# 使用
obj = MyClass(10)

print("调用实例方法：")
result1 = obj.instance_method()
print(f"返回值：{result1}")

print("\n调用类方法：")
result2 = MyClass.class_method()
print(f"返回值：{result2}")

print("\n调用静态方法：")
result3 = MyClass.static_method()
print(f"返回值：{result3}")
```

## 六、上下文管理器概述

### 6.1 什么是上下文管理器

上下文管理器（Context Manager）是Python中用于管理资源的对象，它提供了一种在进入和退出代码块时自动执行特定操作的机制，例如自动关闭文件、释放锁等。

上下文管理器的主要特点是：
- 自动管理资源，确保资源在使用后被正确释放
- 简化代码，避免手动管理资源的繁琐操作
- 提高代码的健壮性，即使发生异常也能正确释放资源

### 6.2 上下文管理器的使用

上下文管理器通常与`with`语句一起使用，语法如下：

```python
with 上下文管理器 as 变量:
    # 使用资源的代码块
```

**示例**：

```python
# 文件操作示例（使用上下文管理器自动关闭文件）
print("使用with语句操作文件：")
with open("test.txt", "w") as f:
    f.write("Hello, Context Manager!")
    print("文件写入完成")

# 文件已经自动关闭，尝试写入会报错
try:
    f.write("再次写入")
except ValueError as e:
    print(f"尝试写入已关闭的文件，报错：{e}")
```

## 七、上下文管理器的实现

### 7.1 使用类实现上下文管理器

使用类实现上下文管理器需要实现两个特殊方法：
- `__enter__()`：进入`with`语句块时调用，返回要管理的资源
- `__exit__(exc_type, exc_val, exc_tb)`：退出`with`语句块时调用，负责释放资源
  - `exc_type`：异常类型（如果有异常发生）
  - `exc_val`：异常值（如果有异常发生）
  - `exc_tb`：异常回溯信息（如果有异常发生）

**示例1：文件管理上下文管理器**

```python
# 使用类实现上下文管理器
class FileManager:
    def __init__(self, file_path, mode="r"):
        self.file_path = file_path
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """进入with语句块时调用，返回要管理的资源"""
        print(f"[FileManager] 打开文件：{self.file_path}")
        self.file = open(self.file_path, self.mode)
        return self.file  # 返回资源给with语句
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出with语句块时调用，负责释放资源"""
        print(f"[FileManager] 关闭文件：{self.file_path}")
        if self.file:
            self.file.close()
        
        # 处理异常
        if exc_type:
            print(f"[FileManager] 发生异常：{exc_type.__name__}: {exc_val}")
            # 返回True表示异常已处理，不会向上传播
            # 返回False表示异常未处理，会向上传播
            return False

# 使用自定义上下文管理器
print("使用自定义FileManager：")
with FileManager("test.txt", "w") as f:
    f.write("使用自定义上下文管理器写入")
    # 模拟异常（取消注释测试）
    # raise ValueError("测试异常")

print("\n文件操作完成")
```

**示例2：数据库连接上下文管理器**

```python
class DatabaseConnection:
    def __init__(self, host, port, user, password, db):
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.db = db
        self.connection = None
    
    def __enter__(self):
        """建立数据库连接"""
        print(f"[DB] 连接到数据库：{self.host}:{self.port}/{self.db}")
        # 模拟数据库连接
        self.connection = f"DBConnection({self.host}:{self.port})"
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """关闭数据库连接"""
        print(f"[DB] 关闭数据库连接：{self.connection}")
        self.connection = None
        
        if exc_type:
            print(f"[DB] 数据库操作异常：{exc_type.__name__}: {exc_val}")
            return False

# 使用数据库连接上下文管理器
print("使用数据库连接上下文管理器：")
with DatabaseConnection("localhost", 3306, "root", "password", "test_db") as conn:
    print(f"[DB] 使用连接：{conn} 执行查询")

print("\n数据库操作完成")
```

### 7.2 使用contextlib.contextmanager实现上下文管理器

Python的`contextlib`模块提供了`contextmanager`装饰器，可以使用生成器函数更简单地实现上下文管理器。这种方式将`__enter__`和`__exit__`方法合并到一个函数中，通过`yield`语句分隔资源获取和释放逻辑。

**示例1：文件管理上下文管理器**

```python
from contextlib import contextmanager

# 使用contextmanager装饰器实现上下文管理器
@contextmanager
def file_manager(file_path, mode="r"):
    """文件管理上下文管理器"""
    print(f"[ContextManager] 打开文件：{file_path}")
    file = open(file_path, mode)
    
    try:
        # yield之前的代码相当于__enter__方法，yield返回资源
        yield file
    except Exception as e:
        print(f"[ContextManager] 发生异常：{e}")
        # 可以选择重新抛出异常
        raise
    finally:
        # yield之后的代码相当于__exit__方法，负责释放资源
        print(f"[ContextManager] 关闭文件：{file_path}")
        file.close()

# 使用上下文管理器
print("使用contextmanager装饰器实现的上下文管理器：")
with file_manager("test.txt", "w") as f:
    f.write("使用contextmanager写入")

print("\n文件操作完成")
```

**示例2：临时目录上下文管理器**

```python
import os
import tempfile
from contextlib import contextmanager

@contextmanager
def temporary_directory():
    """创建临时目录，退出时自动删除"""
    # 创建临时目录
    temp_dir = tempfile.mkdtemp()
    print(f"[TempDir] 创建临时目录：{temp_dir}")
    
    try:
        yield temp_dir
    finally:
        # 删除临时目录及其内容
        import shutil
        shutil.rmtree(temp_dir)
        print(f"[TempDir] 删除临时目录：{temp_dir}")

# 使用临时目录上下文管理器
print("使用临时目录上下文管理器：")
with temporary_directory() as tmp_dir:
    # 在临时目录中创建文件
    file_path = os.path.join(tmp_dir, "test.txt")
    with open(file_path, "w") as f:
        f.write("临时文件内容")
    
    print(f"[TempDir] 在临时目录中创建文件：{file_path}")
    print(f"[TempDir] 文件存在：{os.path.exists(file_path)}")

print(f"\n临时目录已删除，文件存在：{os.path.exists(file_path)}")
```

### 7.3 上下文管理器的应用场景

上下文管理器可以用于管理各种资源，常见的应用场景包括：

| 应用场景 | 描述 | 示例 |
|---------|------|------|
| 文件操作 | 自动打开和关闭文件 | `with open("file.txt", "r") as f:` |
| 数据库连接 | 自动建立和关闭数据库连接 | `with db.connect() as conn:` |
| 网络连接 | 自动建立和关闭网络连接 | `with socket.socket() as s:` |
| 锁管理 | 自动获取和释放锁 | `with threading.Lock():` |
| 临时资源 | 自动创建和清理临时资源 | `with tempfile.TemporaryFile() as f:` |
| 状态管理 | 临时修改和恢复状态 | 临时修改环境变量、配置等 |
| 性能测量 | 自动开始和停止计时 | 测量代码执行时间 |
| 异常处理 | 自动捕获和处理异常 | 特定异常的统一处理 |

**示例1：测量代码执行时间**

```python
from contextlib import contextmanager
import time

@contextmanager
def timer(name=""):
    """测量代码执行时间的上下文管理器"""
    start_time = time.time()
    print(f"{name}开始执行")
    yield  # 不返回任何资源
    end_time = time.time()
    print(f"{name}执行结束，耗时：{end_time - start_time:.4f}秒")

# 使用
print("使用timer上下文管理器：")
with timer("测试函数"):
    time.sleep(0.5)  # 模拟耗时操作
    print("执行耗时操作")
```

**示例2：临时修改环境变量**

```python
import os
from contextlib import contextmanager

@contextmanager
def temporary_env_var(key, value):
    """临时修改环境变量，退出时恢复"""
    # 保存原始值
    original_value = os.environ.get(key)
    print(f"[Env] 保存原始环境变量 {key} = {original_value}")
    
    # 设置新值
    os.environ[key] = value
    print(f"[Env] 设置环境变量 {key} = {value}")
    
    try:
        yield
    finally:
        # 恢复原始值
        if original_value is not None:
            os.environ[key] = original_value
            print(f"[Env] 恢复环境变量 {key} = {original_value}")
        else:
            del os.environ[key]
            print(f"[Env] 删除环境变量 {key}")

# 使用
env_key = "TEST_VAR"
print(f"原始环境变量 {env_key} = {os.environ.get(env_key)}")

with temporary_env_var(env_key, "temporary_value"):
    print(f"with块内 {env_key} = {os.environ.get(env_key)}")

print(f"with块外 {env_key} = {os.environ.get(env_key)}")
```

## 八、上下文管理器的高级应用

### 8.1 嵌套上下文管理器

可以在一个`with`语句中使用多个上下文管理器，用逗号分隔。

**示例**：

```python
# 嵌套上下文管理器示例
from contextlib import contextmanager

@contextmanager
def context1(name):
    print(f"进入上下文1：{name}")
    yield f"上下文1返回值：{name}"
    print(f"退出上下文1：{name}")

@contextmanager
def context2(name):
    print(f"进入上下文2：{name}")
    yield f"上下文2返回值：{name}"
    print(f"退出上下文2：{name}")

# 嵌套使用上下文管理器
print("嵌套使用上下文管理器：")
with context1("A") as c1, context2("B") as c2:
    print(f"在with块内，c1={c1}, c2={c2}")
    print("执行with块内的操作")

print("\nwith块执行完毕")
```

### 8.2 contextlib中的其他工具

`contextlib`模块还提供了其他有用的上下文管理器工具：

- `contextlib.suppress`：忽略指定的异常
- `contextlib.redirect_stdout`：重定向标准输出
- `contextlib.redirect_stderr`：重定向标准错误
- `contextlib.ExitStack`：动态管理多个上下文管理器

**示例**：

```python
import contextlib
import io

# 使用contextlib.suppress忽略异常
print("使用contextlib.suppress忽略异常：")
with contextlib.suppress(FileNotFoundError):
    with open("non_existent_file.txt", "r") as f:
        content = f.read()
    print(f"文件内容：{content}")
print("异常被忽略，程序继续执行")

# 使用contextlib.redirect_stdout重定向标准输出
print("\n使用contextlib.redirect_stdout重定向标准输出：")
buffer = io.StringIO()
with contextlib.redirect_stdout(buffer):
    print("这条消息会被重定向到buffer")
    print("这条消息也会被重定向")

redirected_output = buffer.getvalue()
print(f"重定向的输出：\n{redirected_output}")
print("这条消息会直接输出到控制台")

# 使用contextlib.ExitStack动态管理上下文管理器
print("\n使用contextlib.ExitStack动态管理上下文管理器：")
with contextlib.ExitStack() as stack:
    # 动态打开多个文件
    files = [stack.enter_context(open(f"file{i}.txt", "w")) for i in range(3)]
    
    # 写入内容
    for i, f in enumerate(files):
        f.write(f"这是文件{i}的内容")
        print(f"写入文件{i}.txt")

print("所有文件已自动关闭")
```

## 九、最佳实践

### 9.1 装饰器的最佳实践

1. **使用functools.wraps保留原函数的元信息**
2. **装饰器函数名和参数名要清晰，便于理解**
3. **对于复杂的装饰器，使用类实现可能更清晰**
4. **多个装饰器的应用顺序要合理，从内到外依次增强功能**
5. **带参数的装饰器要注意参数的默认值和类型**
6. **装饰器应该保持单一职责，只做一件事**
7. **避免过度使用装饰器，以免代码难以理解和调试**

### 9.2 上下文管理器的最佳实践

1. **优先使用`with`语句管理资源**
2. **对于简单的上下文管理器，使用`contextlib.contextmanager`装饰器实现**
3. **对于复杂的上下文管理器，使用类实现**
4. **确保上下文管理器能够正确处理异常**
5. **上下文管理器的名称要清晰，反映其功能**
6. **避免在上下文管理器中做过多的业务逻辑**
7. **使用`contextlib.ExitStack`管理多个上下文管理器**

## 十、总结

本章介绍了Python装饰器与上下文管理器的相关知识，包括：

1. **装饰器基础**：装饰器的定义、工作原理、装饰带有参数的函数
2. **多个装饰器的使用**：装饰器的应用顺序、多个装饰器的应用场景
3. **带参数的装饰器**：带参数装饰器的定义、应用场景、装饰器工厂
4. **装饰器的高级应用**：装饰类、装饰类方法和静态方法
5. **上下文管理器概述**：什么是上下文管理器、上下文管理器的使用
6. **上下文管理器的实现**：使用类实现、使用`contextlib.contextmanager`实现
7. **上下文管理器的高级应用**：嵌套上下文管理器、`contextlib`中的其他工具
8. **最佳实践**：装饰器的最佳实践、上下文管理器的最佳实践

通过本章的学习，你应该已经掌握了Python装饰器与上下文管理器的基本概念和使用方法，能够编写自定义装饰器和上下文管理器，熟练使用它们来增强函数功能和管理资源。装饰器与上下文管理器是Python中的重要特性，它们可以帮助你编写更简洁、更健壮、更可维护的代码。

## 十一、练习

1. 编写一个装饰器，用于记录函数的调用日志，包括调用时间、参数和返回值。
2. 编写一个装饰器，用于验证函数参数的类型，确保参数类型符合要求。
3. 编写一个带参数的装饰器，用于限制函数的调用频率，例如每秒最多调用5次。
4. 编写一个类，实现上下文管理器，用于管理数据库连接。
5. 使用`contextlib.contextmanager`装饰器实现一个上下文管理器，用于临时修改环境变量。
6. 编写一个装饰器，用于缓存函数的返回值，支持设置缓存过期时间。
7. 编写一个嵌套的上下文管理器，用于同时管理多个资源。
8. 使用装饰器和上下文管理器结合，实现一个事务管理系统。

## 十二、参考资料

1. Python官方文档：https://docs.python.org/zh-cn/3/glossary.html#term-decorator
2. Python官方文档：https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with
3. Python官方文档：https://docs.python.org/zh-cn/3/library/contextlib.html
4. 《流畅的Python》（Luciano Ramalho）
5. 《Python Cookbook》（David Beazley）
6. 《Effective Python》（Brett Slatkin）
7. Python装饰器教程：https://realpython.com/primer-on-python-decorators/
8. Python上下文管理器教程：https://realpython.com/python-with-statement/