# 5. 流模块

## 5.1 流模块概述

流（Stream）是Node.js的核心模块之一，用于处理大量数据或连续数据，如文件读写、网络通信、数据压缩等。流是一种抽象的数据处理方式，它允许数据以小块的形式进行处理，而不是一次性加载到内存中，这对于处理大文件或大量数据非常重要。

### 5.1.1 流的基本概念

流是一种数据处理方式，它将数据分解成一系列小块（chunk），并逐个处理这些小块，而不是一次性加载整个数据。流的主要特点包括：

- **高效性**：流处理数据时，只需要将当前处理的数据块加载到内存中，而不是整个数据，因此可以处理非常大的文件或数据。
- **连续性**：流可以处理连续的数据，如网络流、实时数据等。
- **可组合性**：流可以通过管道（pipe）连接起来，形成一个处理链，使数据可以从一个流流向另一个流，实现复杂的数据处理。

### 5.1.2 流模块的基本用法

```javascript
const fs = require('node:fs');

// 创建可读流
const readableStream = fs.createReadStream('input.txt');

// 创建可写流
const writableStream = fs.createWriteStream('output.txt');

// 使用管道连接流
readableStream.pipe(writableStream);
```

## 5.2 流的类型

Node.js中有四种基本的流类型：

### 5.2.1 可读流（Readable）

可读流用于从数据源读取数据，如文件、网络请求等。可读流的状态包括：
- **暂停状态**：默认状态，需要手动调用`read()`方法读取数据。
- **流动状态**：数据自动从数据源流向消费者，可以通过`resume()`方法切换到流动状态，或通过`pipe()`方法自动切换到流动状态。

### 5.2.2 可写流（Writable）

可写流用于向目标写入数据，如文件、网络响应等。可写流的状态包括：
- **可写状态**：可以写入数据。
- **不可写状态**：缓冲区已满，暂时不能写入数据。

### 5.2.3 双工流（Duplex）

双工流同时具有可读和可写的能力，如TCP套接字、WebSocket等。双工流的可读和可写部分是独立的，可以分别处理。

### 5.2.4 转换流（Transform）

转换流是一种特殊的双工流，它可以在写入数据的同时转换数据，然后读取转换后的数据，如数据压缩、加密解密等。

## 5.3 可读流

### 5.3.1 创建可读流

```javascript
const fs = require('node:fs');
const { Readable } = require('node:stream');

// 从文件创建可读流
const fileStream = fs.createReadStream('input.txt', {
  encoding: 'utf8',
  highWaterMark: 16 * 1024 // 16KB
});

// 自定义可读流
class MyReadableStream extends Readable {
  constructor(options) {
    super(options);
    this.data = ['a', 'b', 'c', 'd', 'e'];
  }

  _read(size) {
    if (this.data.length === 0) {
      this.push(null); // 表示数据读取完毕
    } else {
      const chunk = this.data.shift();
      this.push(chunk); // 推送数据到可读流
    }
  }
}

const customStream = new MyReadableStream();
```

### 5.3.2 可读流事件

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('input.txt', 'utf8');

// data事件：当有数据可读时触发
readableStream.on('data', (chunk) => {
  console.log('Received chunk:', chunk);
  console.log('Chunk size:', chunk.length, 'bytes');
});

// end事件：当数据读取完毕时触发
readableStream.on('end', () => {
  console.log('Data reading completed');
});

// error事件：当读取过程中发生错误时触发
readableStream.on('error', (error) => {
  console.error('Error reading file:', error);
});

// open事件：当文件打开时触发
readableStream.on('open', (fd) => {
  console.log('File opened with file descriptor:', fd);
});

// close事件：当文件关闭时触发
readableStream.on('close', () => {
  console.log('File closed');
});
```

### 5.3.3 可读流方法

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('input.txt', 'utf8');

// resume()：切换到流动状态，开始读取数据
readableStream.resume();

// pause()：切换到暂停状态，停止读取数据
readableStream.pause();

// read(size)：从内部缓冲区读取数据
const chunk = readableStream.read(1024);

// pipe(destination[, options])：将可读流的数据通过管道流向可写流
const writableStream = fs.createWriteStream('output.txt');
readableStream.pipe(writableStream);

// unpipe([destination])：解除管道连接
readableStream.unpipe(writableStream);

// unshift(chunk)：将数据推回到内部缓冲区
readableStream.unshift(chunk);

// wrap(stream)：包装一个旧版本的流
const oldStream = /* 旧版本的流 */;
const wrappedStream = Readable.wrap(oldStream);
```

## 5.4 可写流

### 5.4.1 创建可写流

```javascript
const fs = require('node:fs');
const { Writable } = require('node:stream');

// 从文件创建可写流
const fileStream = fs.createWriteStream('output.txt', {
  encoding: 'utf8',
  highWaterMark: 16 * 1024 // 16KB
});

// 自定义可写流
class MyWritableStream extends Writable {
  constructor(options) {
    super(options);
  }

  _write(chunk, encoding, callback) {
    // 处理写入的数据
    console.log('Writing chunk:', chunk.toString());
    
    // 调用callback表示写入完成
    callback();
  }
}

const customStream = new MyWritableStream();
```

### 5.4.2 可写流事件

```javascript
const fs = require('node:fs');

const writableStream = fs.createWriteStream('output.txt', 'utf8');

// drain事件：当内部缓冲区为空，可以继续写入数据时触发
writableStream.on('drain', () => {
  console.log('Buffer drained, can write more data');
});

// finish事件：当调用end()方法，且所有数据都已写入目标时触发
writableStream.on('finish', () => {
  console.log('Data writing completed');
});

// error事件：当写入过程中发生错误时触发
writableStream.on('error', (error) => {
  console.error('Error writing file:', error);
});

// pipe事件：当可读流通过pipe()方法连接到可写流时触发
writableStream.on('pipe', (src) => {
  console.log('Pipe connected from:', src);
});

// unpipe事件：当可读流通过unpipe()方法解除管道连接时触发
writableStream.on('unpipe', (src) => {
  console.log('Pipe disconnected from:', src);
});
```

### 5.4.3 可写流方法

```javascript
const fs = require('node:fs');

const writableStream = fs.createWriteStream('output.txt', 'utf8');

// write(chunk[, encoding][, callback])：写入数据到可写流
const canWrite = writableStream.write('Hello, Node.js!');
if (!canWrite) {
  console.log('Buffer is full, waiting for drain event');
}

// end([chunk][, encoding][, callback])：结束写入，不再接受新的数据
writableStream.end('End of data');

// cork()：暂停写入，将数据缓冲在内部
writableStream.cork();

// uncork()：恢复写入，将缓冲的数据写入目标
writableStream.uncork();

// setDefaultEncoding(encoding)：设置默认编码
writableStream.setDefaultEncoding('utf8');
```

## 5.5 双工流和转换流

### 5.5.1 双工流（Duplex）

双工流同时具有可读和可写的能力，如TCP套接字、WebSocket等。双工流的可读和可写部分是独立的，可以分别处理。

```javascript
const { Duplex } = require('node:stream');

class MyDuplexStream extends Duplex {
  constructor(options) {
    super(options);
    this.data = [];
  }

  _read(size) {
    if (this.data.length === 0) {
      this.push(null);
    } else {
      const chunk = this.data.shift();
      this.push(chunk);
    }
  }

  _write(chunk, encoding, callback) {
    // 处理写入的数据，并将其添加到可读流的数据源
    this.data.push(chunk.toString().toUpperCase());
    callback();
  }
}

const duplexStream = new MyDuplexStream();

// 写入数据
 duplexStream.write('hello');
duplexStream.write('world');
duplexStream.end();

// 读取数据
duplexStream.on('data', (chunk) => {
  console.log('Received:', chunk.toString());
});
```

### 5.5.2 转换流（Transform）

转换流是一种特殊的双工流，它可以在写入数据的同时转换数据，然后读取转换后的数据，如数据压缩、加密解密、数据格式化等。

```javascript
const { Transform } = require('node:stream');

// 创建一个将数据转换为大写的转换流
class UpperCaseTransform extends Transform {
  constructor(options) {
    super(options);
  }

  _transform(chunk, encoding, callback) {
    // 将数据转换为大写
    const transformedChunk = chunk.toString().toUpperCase();
    // 推送转换后的数据
    this.push(transformedChunk);
    // 调用callback表示转换完成
    callback();
  }
}

const upperCaseTransform = new UpperCaseTransform();

// 使用转换流
const fs = require('node:fs');
const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt');

readableStream.pipe(upperCaseTransform).pipe(writableStream);
```

### 5.5.3 内置转换流

Node.js提供了一些内置的转换流，如：

- **zlib**：用于数据压缩和解压缩
- **crypto**：用于数据加密和解密
- **string_decoder**：用于将Buffer转换为字符串

```javascript
const fs = require('node:fs');
const zlib = require('node:zlib');

// 使用zlib创建压缩流
const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt.gz');
const gzip = zlib.createGzip();

readableStream.pipe(gzip).pipe(writableStream);

// 使用zlib创建解压缩流
const compressedStream = fs.createReadStream('output.txt.gz');
const decompressedStream = fs.createWriteStream('decompressed.txt');
const gunzip = zlib.createGunzip();

compressedStream.pipe(gunzip).pipe(decompressedStream);
```

## 5.6 流的管道

流的管道是一种将可读流的数据自动流向可写流的机制，它可以简化流的使用，提高代码的可读性和可维护性。

### 5.6.1 基本管道

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt');

// 使用管道连接流
readableStream.pipe(writableStream);

// 监听finish事件
writableStream.on('finish', () => {
  console.log('File copying completed');
});
```

### 5.6.2 管道链

流的管道可以连接多个流，形成一个处理链，使数据可以从一个流流向另一个流，实现复杂的数据处理。

```javascript
const fs = require('node:fs');
const zlib = require('node:zlib');
const { Transform } = require('node:stream');

// 创建转换流，将数据转换为大写
class UpperCaseTransform extends Transform {
  _transform(chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
}

const upperCaseTransform = new UpperCaseTransform();

// 创建管道链：读取文件 -> 转换为大写 -> 压缩 -> 写入文件
const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt.gz');
const gzip = zlib.createGzip();

readableStream
  .pipe(upperCaseTransform)
  .pipe(gzip)
  .pipe(writableStream)
  .on('finish', () => {
    console.log('Processing completed');
  });
```

### 5.6.3 管道选项

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt');

// 管道选项
const options = {
  end: false // 当可读流结束时，不结束可写流
};

readableStream.pipe(writableStream, options);

// 手动结束可写流
readableStream.on('end', () => {
  writableStream.end('Additional data');
});
```

## 5.7 流的最佳实践

### 5.7.1 始终处理错误

流的错误事件不会自动传播，因此需要为每个流单独处理错误事件，避免程序崩溃。

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt');

readableStream.on('error', (error) => {
  console.error('Error reading file:', error);
});

writableStream.on('error', (error) => {
  console.error('Error writing file:', error);
});

readableStream.pipe(writableStream);
```

### 5.7.2 使用管道代替手动处理

使用管道可以简化流的使用，提高代码的可读性和可维护性，同时自动处理背压（backpressure）问题。

```javascript
// 推荐：使用管道
readableStream.pipe(writableStream);

// 不推荐：手动处理数据
readableStream.on('data', (chunk) => {
  const canWrite = writableStream.write(chunk);
  if (!canWrite) {
    readableStream.pause();
  }
});

writableStream.on('drain', () => {
  readableStream.resume();
});
```

### 5.7.3 处理背压

背压是指当可写流的写入速度跟不上可读流的读取速度时，出现的一种现象。管道会自动处理背压问题，但手动处理流时需要注意。

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('large-file.txt');
const writableStream = fs.createWriteStream('output.txt');

readableStream.on('data', (chunk) => {
  // 检查是否可以写入数据
  const canWrite = writableStream.write(chunk);
  if (!canWrite) {
    // 暂停读取数据
    readableStream.pause();
  }
});

writableStream.on('drain', () => {
  // 恢复读取数据
  readableStream.resume();
});

readableStream.on('end', () => {
  // 结束写入
  writableStream.end();
});
```

### 5.7.4 使用合适的缓冲区大小

根据实际情况调整流的缓冲区大小（highWaterMark），可以提高流的性能。对于大文件，可以使用较大的缓冲区大小；对于小文件，可以使用较小的缓冲区大小。

```javascript
const fs = require('node:fs');

// 调整缓冲区大小为64KB
const readableStream = fs.createReadStream('large-file.txt', {
  highWaterMark: 64 * 1024
});

const writableStream = fs.createWriteStream('output.txt', {
  highWaterMark: 64 * 1024
});

readableStream.pipe(writableStream);
```

### 5.7.5 关闭流

当流不再使用时，应该及时关闭流，释放资源。

```javascript
const fs = require('node:fs');

const readableStream = fs.createReadStream('input.txt');
const writableStream = fs.createWriteStream('output.txt');

readableStream.pipe(writableStream);

writableStream.on('finish', () => {
  // 关闭流
  readableStream.close();
  writableStream.close();
  console.log('Streams closed');
});
```

## 5.8 实践练习

1. 使用可读流和可写流复制一个大文件
2. 创建一个转换流，将文本转换为大写并添加行号
3. 使用管道链实现：读取文件 -> 压缩 -> 写入文件
4. 实现一个简单的HTTP服务器，使用流处理请求和响应
5. 创建一个自定义的可读流，生成随机数据
6. 创建一个自定义的可写流，将数据写入多个文件
7. 使用流处理CSV文件，统计数据
8. 使用流实现一个简单的日志系统

通过以上练习，你将掌握Node.js流模块的核心概念和使用方法，能够编写高效、可靠的流处理代码。