# 1. 文件系统模块

## 1.1 fs模块概述

fs（File System）是Node.js的核心模块之一，用于处理文件系统操作，包括文件读写、目录操作、文件状态检查等。fs模块提供了同步和异步两种API，异步API使用回调函数，同步API则会阻塞主线程。

### 1.1.1 fs模块的基本用法

```javascript
// 引入fs模块
const fs = require('node:fs');
```

### 1.1.2 同步API vs 异步API

- **同步API**：函数名以`Sync`结尾，会阻塞主线程，直到操作完成
- **异步API**：函数名不以`Sync`结尾，使用回调函数，不会阻塞主线程

```javascript
// 同步API
try {
  const data = fs.readFileSync('file.txt', 'utf8');
  console.log('Data:', data);
} catch (error) {
  console.error('Error:', error);
}

// 异步API
fs.readFile('file.txt', 'utf8', (error, data) => {
  if (error) {
    console.error('Error:', error);
    return;
  }
  console.log('Data:', data);
});
```

## 1.2 文件读写操作

### 1.2.1 异步文件读写

#### 读取文件

```javascript
// 读取文件
fs.readFile('file.txt', 'utf8', (error, data) => {
  if (error) {
    console.error('Error reading file:', error);
    return;
  }
  console.log('File content:', data);
});

// 读取二进制文件
fs.readFile('image.jpg', (error, data) => {
  if (error) {
    console.error('Error reading image:', error);
    return;
  }
  console.log('Image size:', data.length, 'bytes');
});
```

#### 写入文件

```javascript
// 写入文件，覆盖原有内容
fs.writeFile('file.txt', 'Hello, Node.js!', (error) => {
  if (error) {
    console.error('Error writing file:', error);
    return;
  }
  console.log('File written successfully!');
});

// 写入文件，追加内容
fs.appendFile('file.txt', '\nAppend this line!', (error) => {
  if (error) {
    console.error('Error appending to file:', error);
    return;
  }
  console.log('Content appended successfully!');
});
```

### 1.2.2 同步文件读写

#### 读取文件

```javascript
try {
  const data = fs.readFileSync('file.txt', 'utf8');
  console.log('File content:', data);
} catch (error) {
  console.error('Error reading file:', error);
}
```

#### 写入文件

```javascript
try {
  fs.writeFileSync('file.txt', 'Hello, Node.js!');
  console.log('File written successfully!');
} catch (error) {
  console.error('Error writing file:', error);
}

// 追加内容
try {
  fs.appendFileSync('file.txt', '\nAppend this line!');
  console.log('Content appended successfully!');
} catch (error) {
  console.error('Error appending to file:', error);
}
```

### 1.2.3 流式文件读写

对于大文件，使用流式读写可以减少内存占用，提高性能。

#### 读取流

```javascript
const readStream = fs.createReadStream('large-file.txt', 'utf8');

readStream.on('data', (chunk) => {
  console.log('Received chunk:', chunk.length, 'bytes');
});

readStream.on('end', () => {
  console.log('File reading completed!');
});

readStream.on('error', (error) => {
  console.error('Error reading file:', error);
});
```

#### 写入流

```javascript
const writeStream = fs.createWriteStream('output.txt');

writeStream.write('Hello, ');
writeStream.write('Node.js!');
writeStream.end();

writeStream.on('finish', () => {
  console.log('File writing completed!');
});

writeStream.on('error', (error) => {
  console.error('Error writing file:', error);
});
```

#### 管道流

```javascript
const readStream = fs.createReadStream('input.txt');
const writeStream = fs.createWriteStream('output.txt');

readStream.pipe(writeStream);

writeStream.on('finish', () => {
  console.log('File copying completed!');
});
```

## 1.3 目录操作

### 1.3.1 创建目录

```javascript
// 创建单个目录
fs.mkdir('new-directory', (error) => {
  if (error) {
    console.error('Error creating directory:', error);
    return;
  }
  console.log('Directory created successfully!');
});

// 创建多级目录
fs.mkdir('parent/child/grandchild', { recursive: true }, (error) => {
  if (error) {
    console.error('Error creating directories:', error);
    return;
  }
  console.log('Directories created successfully!');
});
```

### 1.3.2 读取目录

```javascript
// 读取目录
fs.readdir('directory', (error, files) => {
  if (error) {
    console.error('Error reading directory:', error);
    return;
  }
  console.log('Files:', files);
});

// 读取目录并获取文件信息
fs.readdir('directory', { withFileTypes: true }, (error, entries) => {
  if (error) {
    console.error('Error reading directory:', error);
    return;
  }
  entries.forEach((entry) => {
    console.log(entry.name, entry.isDirectory() ? '(directory)' : '(file)');
  });
});
```

### 1.3.3 删除目录

```javascript
// 删除空目录
fs.rmdir('empty-directory', (error) => {
  if (error) {
    console.error('Error deleting directory:', error);
    return;
  }
  console.log('Directory deleted successfully!');
});

// 删除非空目录
fs.rm('non-empty-directory', { recursive: true, force: true }, (error) => {
  if (error) {
    console.error('Error deleting directory:', error);
    return;
  }
  console.log('Directory deleted successfully!');
});
```

## 1.4 文件和目录状态

### 1.4.1 获取文件状态

```javascript
// 获取文件状态
fs.stat('file.txt', (error, stats) => {
  if (error) {
    console.error('Error getting file stats:', error);
    return;
  }
  console.log('File stats:', stats);
  console.log('Is file:', stats.isFile());
  console.log('Is directory:', stats.isDirectory());
  console.log('File size:', stats.size, 'bytes');
  console.log('Creation time:', stats.birthtime);
  console.log('Last modified time:', stats.mtime);
  console.log('Last accessed time:', stats.atime);
});
```

### 1.4.2 检查文件是否存在

```javascript
// 检查文件是否存在（已废弃，建议使用fs.access或fs.stat）
fs.exists('file.txt', (exists) => {
  console.log('File exists:', exists);
});

// 使用fs.access检查文件是否存在
fs.access('file.txt', fs.constants.F_OK, (error) => {
  console.log('File exists:', !error);
});
```

### 1.4.3 获取文件信息

```javascript
// 获取文件信息
fs.lstat('file.txt', (error, stats) => {
  if (error) {
    console.error('Error getting file info:', error);
    return;
  }
  console.log('File info:', stats);
});
```

## 1.5 文件权限

### 1.5.1 获取文件权限

```javascript
fs.stat('file.txt', (error, stats) => {
  if (error) {
    console.error('Error getting file stats:', error);
    return;
  }
  console.log('File mode:', stats.mode.toString(8));
});
```

### 1.5.2 设置文件权限

```javascript
// 设置文件权限
fs.chmod('file.txt', 0o644, (error) => {
  if (error) {
    console.error('Error changing file permissions:', error);
    return;
  }
  console.log('File permissions changed successfully!');
});
```

## 1.6 符号链接

### 1.6.1 创建符号链接

```javascript
// 创建符号链接
fs.symlink('target-file.txt', 'link-file.txt', (error) => {
  if (error) {
    console.error('Error creating symlink:', error);
    return;
  }
  console.log('Symlink created successfully!');
});
```

### 1.6.2 读取符号链接

```javascript
// 读取符号链接
fs.readlink('link-file.txt', (error, target) => {
  if (error) {
    console.error('Error reading symlink:', error);
    return;
  }
  console.log('Symlink target:', target);
});
```

## 1.7 路径操作

### 1.7.1 路径拼接

```javascript
const path = require('node:path');

// 拼接路径
const fullPath = path.join(__dirname, 'directory', 'file.txt');
console.log('Full path:', fullPath);

// 解析绝对路径
const absolutePath = path.resolve('directory', 'file.txt');
console.log('Absolute path:', absolutePath);
```

### 1.7.2 路径解析

```javascript
const path = require('node:path');

const filePath = '/home/user/directory/file.txt';

console.log('Directory name:', path.dirname(filePath));
console.log('Base name:', path.basename(filePath));
console.log('File extension:', path.extname(filePath));
console.log('Parse path:', path.parse(filePath));
```

## 1.8 文件系统事件

### 1.8.1 监听文件变化

```javascript
const fs = require('node:fs');

// 创建文件监听器
const watcher = fs.watch('file.txt', (eventType, filename) => {
  console.log(`Event type: ${eventType}`);
  if (filename) {
    console.log(`File: ${filename}`);
  }
});

// 停止监听
// watcher.close();
```

## 1.9 最佳实践

### 1.9.1 优先使用异步API

异步API不会阻塞主线程，提高了程序的响应速度和吞吐量，适合处理大量并发请求。

### 1.9.2 使用流式API处理大文件

对于大文件，使用流式API可以减少内存占用，提高性能。

### 1.9.3 正确处理错误

始终检查和处理fs操作返回的错误，避免程序崩溃。

### 1.9.4 使用path模块处理路径

使用path模块可以确保路径在不同操作系统上的兼容性。

### 1.9.5 避免使用同步API

同步API会阻塞主线程，影响程序的性能和响应速度，尽量避免在生产环境中使用。

### 1.9.6 使用fs.promises API

fs.promises API提供了基于Promise的异步API，使用async/await可以使代码更加简洁和易于维护。

```javascript
const fs = require('node:fs/promises');

async function readFile() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    console.log('File content:', data);
  } catch (error) {
    console.error('Error reading file:', error);
  }
}

readFile();
```

## 1.10 实践练习

1. 使用fs模块创建一个新文件，并写入内容
2. 使用fs模块读取一个文件的内容，并输出到控制台
3. 使用fs模块复制一个文件
4. 使用fs模块创建一个目录结构
5. 使用fs模块列出目录中的所有文件和子目录
6. 使用fs模块删除一个文件或目录
7. 使用fs模块获取文件的状态信息
8. 使用fs模块监听文件的变化
9. 使用流式API复制一个大文件
10. 使用fs.promises API重写上述练习

通过以上练习，你将掌握Node.js文件系统模块的核心概念和使用方法，能够编写高效、可靠的文件系统操作代码。