# 4. 异步编程基础

## 4.1 异步编程概述

在JavaScript中，代码通常是单线程执行的，这意味着一次只能执行一个任务。为了处理耗时操作（如网络请求、文件I/O、数据库查询等），JavaScript采用了异步编程模型，允许程序在等待耗时操作完成的同时继续执行其他任务。

### 4.1.1 同步 vs 异步

#### 同步编程

同步编程是指代码按照顺序执行，每一行代码必须等待前一行代码执行完成后才能执行。

```javascript
console.log('1');
console.log('2');
console.log('3');
// 输出：1 2 3
```

#### 异步编程

异步编程是指代码不按照顺序执行，耗时操作会被放入事件队列中，等待主线程空闲时再执行。

```javascript
console.log('1');
setTimeout(() => {
  console.log('2');
}, 1000);
console.log('3');
// 输出：1 3 2
```

### 4.1.2 异步编程的优势

- **提高性能**：避免了主线程阻塞，提高了程序的响应速度
- **更好的用户体验**：在浏览器中，避免了页面卡顿
- **更高效的资源利用**：可以同时处理多个请求，提高了服务器的吞吐量

## 4.2 回调函数

回调函数是Node.js中最原始的异步编程方式，它是指将一个函数作为参数传递给另一个函数，当异步操作完成后，这个函数会被调用。

### 4.2.1 回调函数的基本用法

```javascript
// 定义一个异步函数，使用回调函数返回结果
function fetchData(callback) {
  setTimeout(() => {
    const data = { name: 'Node.js', version: '20.0.0' };
    callback(null, data); // 第一个参数是错误，第二个参数是结果
  }, 1000);
}

// 调用异步函数，传入回调函数
fetchData((error, data) => {
  if (error) {
    console.error('Error:', error);
    return;
  }
  console.log('Data:', data);
});
```

### 4.2.2 回调地狱

当多个异步操作嵌套在一起时，会导致代码的缩进越来越深，可读性越来越差，这种情况被称为"回调地狱"（Callback Hell）。

```javascript
fs.readFile('file1.txt', 'utf8', (err1, data1) => {
  if (err1) {
    console.error('Error reading file1:', err1);
    return;
  }
  fs.readFile('file2.txt', 'utf8', (err2, data2) => {
    if (err2) {
      console.error('Error reading file2:', err2);
      return;
    }
    fs.writeFile('output.txt', data1 + data2, (err3) => {
      if (err3) {
        console.error('Error writing file:', err3);
        return;
      }
      console.log('Files merged successfully!');
    });
  });
});
```

### 4.2.3 回调函数的最佳实践

- **错误优先回调**：第一个参数总是错误对象，第二个参数是结果
- **避免回调地狱**：使用Promise或async/await来处理多个异步操作
- **保持回调函数简洁**：复杂的逻辑应该拆分成多个简单的函数

## 4.3 Promise

Promise是ES6引入的一种异步编程解决方案，它可以避免回调地狱，使异步代码更加清晰和易于维护。

### 4.3.1 Promise的基本概念

Promise有三种状态：
- **pending**：初始状态，既不是成功，也不是失败
- **fulfilled**：操作成功完成
- **rejected**：操作失败

Promise的状态一旦改变，就不会再改变。

### 4.3.2 Promise的基本用法

```javascript
// 创建一个Promise
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve({ name: 'Node.js', version: '20.0.0' }); // 成功时调用resolve
    } else {
      reject(new Error('Operation failed')); // 失败时调用reject
    }
  }, 1000);
});

// 使用Promise
promise
  .then((data) => {
    console.log('Success:', data);
  })
  .catch((error) => {
    console.error('Error:', error);
  })
  .finally(() => {
    console.log('Operation completed');
  });
```

### 4.3.3 Promise链式调用

Promise支持链式调用，可以将多个异步操作串联起来，避免回调地狱。

```javascript
// 定义三个异步函数
function fetchUser() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: 1, name: 'John' });
    }, 1000);
  });
}

function fetchPosts(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Post 1', userId: 1 },
        { id: 2, title: 'Post 2', userId: 1 }
      ]);
    }, 1000);
  });
}

function fetchComments(postId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, content: 'Comment 1', postId: 1 },
        { id: 2, content: 'Comment 2', postId: 1 }
      ]);
    }, 1000);
  });
}

// 链式调用
fetchUser()
  .then((user) => {
    console.log('User:', user);
    return fetchPosts(user.id);
  })
  .then((posts) => {
    console.log('Posts:', posts);
    return fetchComments(posts[0].id);
  })
  .then((comments) => {
    console.log('Comments:', comments);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

### 4.3.4 Promise.all

`Promise.all`用于并行执行多个Promise，当所有Promise都成功时，返回一个包含所有结果的数组；如果有任何一个Promise失败，就会立即返回失败的结果。

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log('Results:', results); // [1, 2, 3]
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

### 4.3.5 Promise.race

`Promise.race`用于并行执行多个Promise，当其中任何一个Promise状态改变时，就返回该Promise的结果。

```javascript
const promise1 = new Promise((resolve) => {
  setTimeout(() => resolve('Promise 1'), 1000);
});

const promise2 = new Promise((resolve) => {
  setTimeout(() => resolve('Promise 2'), 500);
});

Promise.race([promise1, promise2])
  .then((result) => {
    console.log('Result:', result); // Promise 2
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

### 4.3.6 Promise.allSettled

`Promise.allSettled`用于并行执行多个Promise，当所有Promise都完成时（无论成功或失败），返回一个包含所有Promise结果的数组。

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject(new Error('Error'));
const promise3 = Promise.resolve(3);

Promise.allSettled([promise1, promise2, promise3])
  .then((results) => {
    console.log('Results:', results);
    /*
    [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: Error: Error },
      { status: 'fulfilled', value: 3 }
    ]
    */
  });
```

### 4.3.7 Promise.any

`Promise.any`用于并行执行多个Promise，当其中任何一个Promise成功时，返回该Promise的结果；如果所有Promise都失败，就返回一个包含所有失败原因的AggregateError。

```javascript
const promise1 = Promise.reject(new Error('Error 1'));
const promise2 = Promise.resolve(2);
const promise3 = Promise.reject(new Error('Error 3'));

Promise.any([promise1, promise2, promise3])
  .then((result) => {
    console.log('Result:', result); // 2
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

## 4.4 async/await

async/await是ES2017引入的异步编程语法糖，它基于Promise，使异步代码看起来像同步代码，更加易于阅读和维护。

### 4.4.1 async函数

`async`关键字用于声明一个异步函数，异步函数返回一个Promise。

```javascript
async function fetchData() {
  return { name: 'Node.js', version: '20.0.0' };
}

fetchData()
  .then((data) => {
    console.log('Data:', data);
  });
```

### 4.4.2 await关键字

`await`关键字用于等待一个Promise完成，只能在async函数中使用。

```javascript
function fetchUser() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: 1, name: 'John' });
    }, 1000);
  });
}

async function getUser() {
  const user = await fetchUser();
  console.log('User:', user);
}

getUser();
```

### 4.4.3 async/await的错误处理

使用try/catch来处理async/await中的错误。

```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = false;
      if (success) {
        resolve({ name: 'Node.js', version: '20.0.0' });
      } else {
        reject(new Error('Operation failed'));
      }
    }, 1000);
  });
}

async function getData() {
  try {
    const data = await fetchData();
    console.log('Success:', data);
  } catch (error) {
    console.error('Error:', error);
  } finally {
    console.log('Operation completed');
  }
}

getData();
```

### 4.4.4 async/await的并行执行

使用`Promise.all`来并行执行多个异步操作。

```javascript
function fetchUser() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: 1, name: 'John' });
    }, 1000);
  });
}

function fetchPosts() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Post 1' },
        { id: 2, title: 'Post 2' }
      ]);
    }, 1000);
  });
}

async function fetchData() {
  // 并行执行
  const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);
  console.log('User:', user);
  console.log('Posts:', posts);
}

fetchData();
```

## 4.5 异步流程控制

### 4.5.1 串行执行

```javascript
async function serialExecution() {
  console.time('serial');
  
  const result1 = await fetchData(1);
  const result2 = await fetchData(2);
  const result3 = await fetchData(3);
  
  console.log('Results:', result1, result2, result3);
  console.timeEnd('serial');
}
```

### 4.5.2 并行执行

```javascript
async function parallelExecution() {
  console.time('parallel');
  
  const promises = [fetchData(1), fetchData(2), fetchData(3)];
  const results = await Promise.all(promises);
  
  console.log('Results:', results);
  console.timeEnd('parallel');
}
```

### 4.5.3 限制并发数

当需要执行大量异步操作时，为了避免同时发起过多请求，可以限制并发数。

```javascript
async function limitedParallelExecution(tasks, limit) {
  const results = [];
  const executing = [];
  
  for (const task of tasks) {
    const promise = task();
    results.push(promise);
    
    const executingPromise = promise.then(() => {
      executing.splice(executing.indexOf(executingPromise), 1);
    });
    
    executing.push(executingPromise);
    
    if (executing.length >= limit) {
      await Promise.race(executing);
    }
  }
  
  return Promise.all(results);
}
```

## 4.6 错误处理

### 4.6.1 回调函数的错误处理

```javascript
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }
  // 处理数据
});
```

### 4.6.2 Promise的错误处理

```javascript
fetchData()
  .then((data) => {
    // 处理数据
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

### 4.6.3 async/await的错误处理

```javascript
async function getData() {
  try {
    const data = await fetchData();
    // 处理数据
  } catch (error) {
    console.error('Error:', error);
  }
}
```

### 4.6.4 全局错误处理

在Node.js中，可以使用`process.on('unhandledRejection')`来捕获未处理的Promise拒绝。

```javascript
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // 可以在这里添加一些清理工作
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  // 可以在这里添加一些清理工作，然后退出进程
  process.exit(1);
});
```

## 4.7 最佳实践

### 4.7.1 选择合适的异步编程方式

- **简单的异步操作**：可以使用回调函数
- **复杂的异步流程**：使用Promise或async/await
- **需要并行执行多个异步操作**：使用`Promise.all`
- **需要限制并发数**：使用自定义的并发控制函数

### 4.7.2 错误处理最佳实践

- **始终处理错误**：不要忽略任何可能的错误
- **使用统一的错误处理方式**：保持代码风格一致
- **提供有用的错误信息**：便于调试和定位问题
- **使用结构化的错误对象**：包含错误码、错误信息等

### 4.7.3 性能优化

- **避免不必要的异步操作**：同步操作比异步操作更快
- **使用并行执行**：对于独立的异步操作，使用并行执行可以提高性能
- **限制并发数**：避免同时发起过多请求，导致资源耗尽
- **使用流处理大数据**：对于大文件或大量数据，使用流可以减少内存占用

## 4.8 实践练习

1. 使用回调函数实现一个简单的文件读取和写入操作
2. 使用Promise重写上述操作，避免回调地狱
3. 使用async/await重写上述操作，使代码更加简洁
4. 实现一个并行执行多个异步操作的函数
5. 实现一个限制并发数的异步流程控制函数
6. 实现一个带有错误处理的异步函数
7. 使用`Promise.race`实现一个带有超时机制的异步函数
8. 使用`Promise.allSettled`处理多个可能失败的异步操作

通过以上练习，你将掌握Node.js异步编程的核心概念和使用方法，能够编写高效、可靠的异步代码。