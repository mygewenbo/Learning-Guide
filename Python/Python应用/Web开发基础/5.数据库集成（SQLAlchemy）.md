# 数据库集成（SQLAlchemy）

## 一、数据库集成的基本概念

### 1.1 什么是ORM

ORM（Object-Relational Mapping，对象关系映射）是一种将对象模型与关系数据库表结构映射起来的技术。它允许开发者使用面向对象的方式来操作数据库，而不需要编写原始的SQL语句。

### 1.2 SQLAlchemy简介

SQLAlchemy是Python中最流行的ORM库之一，它提供了两种主要的使用方式：

- **SQLAlchemy Core**：提供了SQL表达式语言，允许开发者使用Python代码构建SQL查询
- **SQLAlchemy ORM**：基于Core构建，提供了完整的对象关系映射功能

### 1.3 Flask-SQLAlchemy

Flask-SQLAlchemy是Flask的一个扩展，它简化了SQLAlchemy在Flask应用中的使用，提供了以下功能：

- 自动配置SQLAlchemy
- 与Flask应用上下文集成
- 简化的模型定义
- 自动处理会话管理
- 支持多种数据库后端

## 二、安装和配置

### 2.1 安装Flask-SQLAlchemy

```bash
pip install flask-sqlalchemy
```

### 2.2 基本配置

在Flask应用中配置SQLAlchemy：

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

# 配置数据库URI
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
# 禁用SQLAlchemy事件系统（可选，减少内存使用）
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# 创建SQLAlchemy实例
db = SQLAlchemy(app)
```

### 2.3 数据库URI格式

不同数据库的URI格式：

| 数据库 | URI格式 |
|--------|---------|
| SQLite | `sqlite:///database.db` 或 `sqlite:////absolute/path/to/database.db` |
| MySQL | `mysql://username:password@hostname/database` |
| PostgreSQL | `postgresql://username:password@hostname/database` |
| Oracle | `oracle://username:password@hostname:port/sid` |

## 三、模型定义

### 3.1 基本模型

使用Flask-SQLAlchemy定义模型：

```python
from datetime import datetime

class User(db.Model):
    # 表名
    __tablename__ = 'users'
    
    # 主键
    id = db.Column(db.Integer, primary_key=True)
    # 字符串字段，唯一，不为空
    username = db.Column(db.String(20), unique=True, nullable=False)
    # 字符串字段，唯一，不为空
    email = db.Column(db.String(120), unique=True, nullable=False)
    # 字符串字段，不为空
    password = db.Column(db.String(60), nullable=False)
    # 日期时间字段，默认值为当前时间
    date_created = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    
    # 关系：一个用户可以有多个帖子
    posts = db.relationship('Post', backref='author', lazy=True)
    
    # 字符串表示
    def __repr__(self):
        return f"User('{self.username}', '{self.email}')"

class Post(db.Model):
    __tablename__ = 'posts'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    date_posted = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    content = db.Column(db.Text, nullable=False)
    # 外键：引用users表的id字段
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    
    def __repr__(self):
        return f"Post('{self.title}', '{self.date_posted}')"
```

### 3.2 常用字段类型

| 类型 | 描述 |
|------|------|
| `db.Integer` | 整数 |
| `db.String(size)` | 字符串，指定最大长度 |
| `db.Text` | 长文本 |
| `db.DateTime` | 日期时间 |
| `db.Float` | 浮点数 |
| `db.Boolean` | 布尔值 |
| `db.LargeBinary` | 二进制数据 |
| `db.Enum` | 枚举类型 |
| `db.JSON` | JSON数据 |

### 3.3 字段选项

| 选项 | 描述 |
|------|------|
| `primary_key` | 主键 |
| `unique` | 唯一约束 |
| `nullable` | 是否允许为空 |
| `default` | 默认值 |
| `index` | 创建索引 |
| `autoincrement` | 自增 |

### 3.4 关系

Flask-SQLAlchemy支持多种关系类型：

- **一对多**：使用`db.relationship()`和`db.ForeignKey()`
- **一对一**：使用`db.relationship(uselist=False)`
- **多对多**：使用关联表

#### 3.4.1 一对多关系

```python
class User(db.Model):
    # ...
    posts = db.relationship('Post', backref='author', lazy=True)

class Post(db.Model):
    # ...
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
```

#### 3.4.2 多对多关系

```python
# 关联表
followers = db.Table('followers',
    db.Column('follower_id', db.Integer, db.ForeignKey('users.id')),
    db.Column('followed_id', db.Integer, db.ForeignKey('users.id'))
)

class User(db.Model):
    # ...
    followed = db.relationship(
        'User', secondary=followers,
        primaryjoin=(followers.c.follower_id == id),
        secondaryjoin=(followers.c.followed_id == id),
        backref=db.backref('followers', lazy='dynamic'), lazy='dynamic'
    )
```

## 四、数据库操作

### 4.1 创建数据库

在Flask应用中创建数据库表：

```python
# 在Python shell中
from your_app import app, db
with app.app_context():
    db.create_all()
```

### 4.2 添加数据

```python
from your_app import app, db, User, Post

with app.app_context():
    # 创建用户
    user = User(username='john', email='john@example.com', password='password123')
    # 添加到会话
    db.session.add(user)
    # 提交会话
    db.session.commit()
    
    # 创建帖子
    post = Post(title='First Post', content='This is my first post!', author=user)
    db.session.add(post)
    db.session.commit()
    
    # 批量添加
    users = [
        User(username='jane', email='jane@example.com', password='password123'),
        User(username='bob', email='bob@example.com', password='password123')
    ]
    db.session.add_all(users)
    db.session.commit()
```

### 4.3 查询数据

#### 4.3.1 基本查询

```python
# 获取所有用户
users = User.query.all()

# 获取第一个用户
user = User.query.first()

# 根据主键获取用户
user = User.query.get(1)

# 过滤查询
users = User.query.filter_by(username='john').all()
user = User.query.filter_by(username='john').first()

# 复杂过滤
users = User.query.filter(User.username.like('%john%')).all()
users = User.query.filter(User.id > 1).all()

# 排序
users = User.query.order_by(User.username.desc()).all()

# 限制结果
users = User.query.limit(5).all()

# 偏移
users = User.query.offset(2).limit(5).all()

# 计数
user_count = User.query.count()
```

#### 4.3.2 关系查询

```python
# 获取用户的所有帖子
user = User.query.get(1)
posts = user.posts

# 获取帖子的作者
post = Post.query.get(1)
author = post.author

# 过滤关系
posts = Post.query.filter_by(author_id=1).all()
posts = Post.query.join(User).filter(User.username == 'john').all()
```

### 4.4 更新数据

```python
# 更新单个属性
user = User.query.get(1)
user.username = 'johnny'
db.session.commit()

# 更新多个属性
user = User.query.get(1)
user.username = 'johnny'
user.email = 'johnny@example.com'
db.session.commit()

# 批量更新
User.query.filter(User.username == 'john').update({'username': 'johnny'})
db.session.commit()
```

### 4.5 删除数据

```python
# 删除单个对象
user = User.query.get(1)
db.session.delete(user)
db.session.commit()

# 批量删除
User.query.filter(User.username == 'john').delete()
db.session.commit()
```

## 五、数据库迁移

### 5.1 安装Flask-Migrate

当数据库模型发生变化时，使用Flask-Migrate进行数据库迁移：

```bash
pip install flask-migrate
```

### 5.2 配置Flask-Migrate

```python
from flask_migrate import Migrate

# ...

migrate = Migrate(app, db)
```

### 5.3 初始化迁移仓库

```bash
flask db init
```

### 5.4 创建迁移脚本

```bash
flask db migrate -m "Initial migration"
```

### 5.5 应用迁移

```bash
flask db upgrade
```

### 5.6 回滚迁移

```bash
# 查看迁移历史
flask db history

# 回滚到指定版本
flask db downgrade <revision_id>
```

## 六、高级查询

### 6.1 聚合函数

```python
from sqlalchemy import func

# 计数
user_count = db.session.query(func.count(User.id)).scalar()

# 平均值
avg_posts = db.session.query(func.avg(Post.id)).scalar()

# 分组
posts_per_user = db.session.query(User.username, func.count(Post.id)).join(Post).group_by(User.username).all()
```

### 6.2 子查询

```python
from sqlalchemy import subquery

# 获取帖子数大于5的用户
subq = db.session.query(Post.author_id, func.count(Post.id).label('post_count')).group_by(Post.author_id).subquery()
users = db.session.query(User).join(subq, User.id == subq.c.author_id).filter(subq.c.post_count > 5).all()
```

### 6.3 原始SQL

```python
# 执行原始SQL查询
users = db.session.execute('SELECT * FROM users WHERE username = :name', {'name': 'john'}).fetchall()

# 使用原始SQL更新
result = db.session.execute('UPDATE users SET email = :email WHERE id = :id', {'email': 'new@example.com', 'id': 1})
db.session.commit()
```

## 七、会话管理

### 7.1 会话的生命周期

- 会话在请求开始时创建
- 在请求处理过程中使用
- 在请求结束时关闭

### 7.2 手动管理会话

```python
# 创建会话
with app.app_context():
    # 使用db.session进行操作
    user = User(username='john', email='john@example.com')
    db.session.add(user)
    db.session.commit()
```

## 八、数据库连接池

### 8.1 连接池配置

```python
app.config['SQLALCHEMY_POOL_SIZE'] = 10
app.config['SQLALCHEMY_MAX_OVERFLOW'] = 20
app.config['SQLALCHEMY_POOL_TIMEOUT'] = 30
app.config['SQLALCHEMY_POOL_RECYCLE'] = 1800
```

### 8.2 连接池参数说明

| 参数 | 描述 |
|------|------|
| `SQLALCHEMY_POOL_SIZE` | 连接池大小（默认5） |
| `SQLALCHEMY_MAX_OVERFLOW` | 连接池溢出大小（默认10） |
| `SQLALCHEMY_POOL_TIMEOUT` | 连接超时时间（默认30秒） |
| `SQLALCHEMY_POOL_RECYCLE` | 连接回收时间（默认-1，不回收） |

## 九、最佳实践

### 9.1 模型设计

- 保持模型简洁，每个模型对应一个表
- 使用有意义的表名和字段名
- 为每个模型添加`__repr__`方法
- 合理设计关系，避免循环引用

### 9.2 查询优化

- 使用`lazy='dynamic'`处理大型关系
- 避免N+1查询问题，使用`joinedload`或`subqueryload`
- 只查询需要的字段
- 使用索引加速查询

### 9.3 会话管理

- 保持会话的生命周期尽可能短
- 不要在请求之间共享会话
- 始终提交或回滚会话

### 9.4 安全性

- 使用参数化查询，避免SQL注入
- 对敏感数据进行加密
- 限制数据库用户的权限
- 定期备份数据库

### 9.5 测试

- 使用单独的测试数据库
- 在测试前创建表，测试后删除表
- 使用事务进行测试，测试后回滚

## 十、总结

- SQLAlchemy是Python中流行的ORM库，提供了Core和ORM两种使用方式
- Flask-SQLAlchemy简化了SQLAlchemy在Flask应用中的使用
- 模型定义使用`db.Model`类，字段使用`db.Column`
- 数据库操作包括创建、添加、查询、更新和删除
- Flask-Migrate用于管理数据库迁移
- 遵循最佳实践，确保数据库操作的高效和安全

## 十一、练习

1. 创建一个Flask应用，配置SQLAlchemy连接到SQLite数据库
2. 定义User和Post模型，建立一对多关系
3. 实现以下功能：
   - 创建用户和帖子
   - 查询所有用户和帖子
   - 根据用户名查询用户
   - 根据用户查询帖子
   - 更新用户信息
   - 删除帖子
4. 安装Flask-Migrate，实现数据库迁移
5. 优化查询，避免N+1查询问题

## 十二、参考资源

- Flask-SQLAlchemy官方文档：https://flask-sqlalchemy.palletsprojects.com/
- SQLAlchemy官方文档：https://www.sqlalchemy.org/
- Flask-Migrate官方文档：https://flask-migrate.readthedocs.io/
- SQLAlchemy ORM教程：https://docs.sqlalchemy.org/en/20/orm/

至此，我们已经完成了Flask Web开发基础的学习，包括Flask框架简介与安装、路由与视图函数、模板引擎（Jinja2）、表单处理和数据库集成（SQLAlchemy）。这些知识将帮助你构建功能完整的Web应用。