# Next.js 实战项目 - 项目优化与测试

## 一、性能优化

在本章节中，我们将学习如何优化 Next.js 应用的性能，确保应用在生产环境中能够高效稳定运行。Next.js 提供了多种优化手段，包括代码分割、图像优化、字体优化等。

### 1.1 代码分割与懒加载

#### 1.1.1 组件懒加载

使用 React 的 `lazy` 和 `Suspense` 实现组件的懒加载，减少初始加载时间：

```typescript
'use client';

import React, { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

export default function Home() {
  return (
    <div>
      <h1>Home Page</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
}
```

#### 1.1.2 动态导入

使用 Next.js 的 `dynamic` 函数实现组件的动态导入，支持服务器组件和客户端组件：

```typescript
import dynamic from 'next/dynamic';

// 动态导入客户端组件
const ClientComponent = dynamic(() => import('./ClientComponent'), {
  ssr: false,
  loading: () => <div>Loading...</div>,
});

// 动态导入服务器组件
const ServerComponent = dynamic(() => import('./ServerComponent'));

export default function Page() {
  return (
    <div>
      <ServerComponent />
      <ClientComponent />
    </div>
  );
}
```

### 1.2 图像优化

#### 1.2.1 使用 Next.js Image 组件

Next.js 的 `Image` 组件提供了自动优化功能，包括：
- 自动调整图像大小
- 延迟加载
- WebP 格式转换
- 响应式图像

```typescript
import Image from 'next/image';

export default function Page() {
  return (
    <div>
      <Image
        src="/hero.jpg"
        alt="Hero image"
        width={1200}
        height={600}
        priority
        className="rounded-lg"
      />
    </div>
  );
}
```

#### 1.2.2 外部图像配置

对于外部图像，需要在 `next.config.mjs` 中配置 `images.remotePatterns`：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/images/**',
      },
    ],
  },
};

export default nextConfig;
```

### 1.3 字体优化

#### 1.3.1 使用 Next.js Fonts

Next.js 13+ 提供了内置的字体优化功能，自动处理字体的下载、缓存和预加载：

```typescript
import { Inter } from 'next/font/google';

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
});

export default function RootLayout({
  children,
}: { children: React.ReactNode }) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  );
}
```

#### 1.3.2 自定义字体

对于自定义字体，使用 `next/font/local`：

```typescript
import localFont from 'next/font/local';

const myFont = localFont({
  src: [
    {
      path: './fonts/MyFont-Regular.woff2',
      weight: '400',
      style: 'normal',
    },
    {
      path: './fonts/MyFont-Bold.woff2',
      weight: '700',
      style: 'normal',
    },
  ],
});

export default function Page() {
  return <div className={myFont.className}>Hello World</div>;
}
```

### 1.4 缓存策略

#### 1.4.1 静态资源缓存

Next.js 自动为静态资源（如图像、CSS、JavaScript）设置长期缓存策略。可以在 `next.config.mjs` 中配置缓存行为：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  headers: async () => [
    {
      source: '/(.*)',
      headers: [
        {
          key: 'Cache-Control',
          value: 'public, max-age=31536000, immutable',
        },
      ],
    },
  ],
};

export default nextConfig;
```

#### 1.4.2 数据缓存

使用 `fetch` API 的 `next` 选项配置数据缓存：

```typescript
// 静态缓存，构建时生成
const staticData = await fetch('https://api.example.com/data', {
  next: { revalidate: false },
});

// 增量静态再生，每 60 秒更新一次
const isrData = await fetch('https://api.example.com/data', {
  next: { revalidate: 60 },
});

// 动态数据，每次请求重新获取
const dynamicData = await fetch('https://api.example.com/data', {
  cache: 'no-store',
});
```

### 1.5 服务器组件优化

#### 1.5.1 合理使用服务器组件

- 优先使用服务器组件处理数据获取和渲染
- 仅在需要交互时使用客户端组件
- 将交互逻辑提取到客户端组件中

#### 1.5.2 组件拆分

将大型组件拆分为更小的组件，提高代码复用性和性能：

```typescript
// 服务器组件
import ClientInteractiveComponent from './ClientInteractiveComponent';

export default async function ServerComponent() {
  const data = await fetchData();
  
  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.content}</p>
      <ClientInteractiveComponent data={data} />
    </div>
  );
}
```

### 1.6 构建优化

#### 1.6.1 启用 React Compiler

React Compiler 可以自动优化 React 组件，减少不必要的重新渲染：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactCompiler: true,
};

export default nextConfig;
```

#### 1.6.2 启用 Turbopack

Turbopack 是 Next.js 的下一代构建工具，提供更快的构建速度：

```bash
# 使用 Turbopack 启动开发服务器
npm run dev -- --turbopack
```

#### 1.6.3 分析构建大小

使用 Next.js 的分析工具分析构建大小：

```bash
npm run build -- --analyze
```

## 二、测试策略

### 2.1 测试类型

#### 2.1.1 单元测试

测试单个函数、组件或模块的功能：

```bash
# 安装测试依赖
npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom
```

配置 `vitest.config.ts`：

```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
  },
  resolve: {
    alias: {
      '@/': '/src/',
    },
  },
});
```

编写单元测试：

```typescript
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import Button from '@/components/Button';

describe('Button Component', () => {
  it('should render the button with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('should call onClick when clicked', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    screen.getByText('Click me').click();
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

#### 2.1.2 集成测试

测试多个组件或模块之间的交互：

```typescript
import { describe, it, expect } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import Form from '@/components/Form';

describe('Form Component', () => {
  it('should submit the form with correct data', () => {
    const handleSubmit = vi.fn();
    render(<Form onSubmit={handleSubmit} />);
    
    fireEvent.change(screen.getByLabelText('Name'), {
      target: { value: 'John Doe' },
    });
    
    fireEvent.change(screen.getByLabelText('Email'), {
      target: { value: 'john@example.com' },
    });
    
    fireEvent.click(screen.getByText('Submit'));
    
    expect(handleSubmit).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com',
    });
  });
});
```

#### 2.1.3 端到端测试

使用 Playwright 进行端到端测试，测试完整的用户流程：

```bash
# 安装 Playwright
npm install -D @playwright/test
npx playwright install
```

配置 `playwright.config.ts`：

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

编写端到端测试：

```typescript
import { test, expect } from '@playwright/test';

test('should login successfully', async ({ page }) => {
  await page.goto('/auth/login');
  await page.fill('input[name="email"]', 'test@example.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');
  await expect(page).toHaveURL('/dashboard');
  await expect(page.getByText('Welcome, Test User')).toBeVisible();
});
```

### 2.2 测试最佳实践

#### 2.2.1 测试覆盖率

使用 `vitest` 的覆盖率报告功能，确保代码覆盖率达到目标：

```bash
npm run test -- --coverage
```

配置覆盖率阈值：

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      lines: 80,
      functions: 80,
      branches: 80,
      statements: 80,
    },
  },
});
```

#### 2.2.2 测试命名规范

遵循一致的测试命名规范，提高测试的可读性和可维护性：

```typescript
// 描述测试功能
it('should render the component correctly', () => {
  // 测试代码
});

// 描述测试场景
it('should display error message when form is submitted with invalid data', () => {
  // 测试代码
});

// 使用 Given-When-Then 格式
describe('Button Component', () => {
  it('Given a disabled button, When clicked, Then it should not call onClick', () => {
    // 测试代码
  });
});
```

#### 2.2.3 测试数据管理

使用测试数据工厂或 fixtures 管理测试数据：

```typescript
// src/test/factories.ts
export const createUser = (overrides = {}) => ({
  id: '123',
  name: 'Test User',
  email: 'test@example.com',
  ...overrides,
});

export const createPost = (overrides = {}) => ({
  id: '456',
  title: 'Test Post',
  content: 'Test content',
  ...overrides,
});
```

## 三、最佳实践

### 3.1 代码规范

#### 3.1.1 使用 ESLint 和 Prettier

配置 ESLint 和 Prettier，保持代码风格一致：

```bash
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier
```

配置 `.eslintrc.json`：

```json
{
  "extends": [
    "next/core-web-vitals",
    "prettier"
  ],
  "plugins": ["prettier"],
  "rules": {
    "prettier/prettier": "error"
  }
}
```

配置 `.prettierrc`：

```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

#### 3.1.2 TypeScript 最佳实践

- 启用严格模式
- 为所有函数和组件添加类型定义
- 使用 `zod` 进行运行时数据验证
- 避免使用 `any` 类型
- 使用类型别名和接口提高代码可读性

### 3.2 安全最佳实践

#### 3.2.1 防止 XSS 攻击

- 使用 React 的 JSX 转义功能
- 避免使用 `dangerouslySetInnerHTML`
- 对用户输入进行验证和清理
- 使用 Content Security Policy (CSP)

#### 3.2.2 防止 CSRF 攻击

- 使用 NextAuth.js 的内置 CSRF 保护
- 为 API 路由添加 CSRF 令牌验证
- 使用 SameSite cookies

#### 3.2.3 安全的密码处理

- 使用 `bcryptjs` 或 `argon2` 进行密码哈希
- 实现密码强度验证
- 支持双因素认证
- 定期提醒用户更新密码

### 3.3 可维护性

#### 3.3.1 目录结构

保持清晰的目录结构，便于代码管理和维护：

```
src/
├── app/              # App Router 目录
├── components/       # 通用组件
├── lib/              # 工具函数和配置
├── models/           # 数据模型
├── schemas/          # 数据验证模式
├── services/         # API 服务
├── styles/           # 全局样式
└── utils/            # 通用工具函数
```

#### 3.3.2 文档

- 为组件和函数添加 JSDoc 注释
- 编写 README 文件，说明项目结构和使用方法
- 维护 CHANGELOG 文件，记录版本更新
- 编写 API 文档

#### 3.3.3 代码复用

- 将通用逻辑提取为自定义 hooks
- 创建可复用的组件库
- 使用工具函数封装重复代码
- 遵循 DRY (Don't Repeat Yourself) 原则

## 四、部署准备

### 4.1 环境配置

#### 4.1.1 环境变量

为不同环境配置不同的环境变量：

- `.env.local` - 本地开发环境
- `.env.development` - 开发服务器环境
- `.env.production` - 生产环境
- `.env.test` - 测试环境

#### 4.1.2 构建配置

优化生产构建配置：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  compress: true,
  productionBrowserSourceMaps: false,
  images: {
    unoptimized: false,
  },
};

export default nextConfig;
```

### 4.2 CI/CD 流程

#### 4.2.1 GitHub Actions

配置 GitHub Actions 工作流，实现自动构建、测试和部署：

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run build
      - run: npm run test

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./
          vercel-args: '--prod'
```

### 4.3 部署到 Vercel

#### 4.3.1 自动部署

将代码推送到 GitHub 仓库，Vercel 会自动部署应用：

1. 登录 Vercel 控制台
2. 连接 GitHub 仓库
3. 配置项目设置
4. 点击 "Deploy"

#### 4.3.2 手动部署

使用 Vercel CLI 手动部署应用：

```bash
# 安装 Vercel CLI
npm install -g vercel

# 登录 Vercel
vercel login

# 部署到生产环境
vercel --prod
```

### 4.4 部署到其他平台

#### 4.4.1 部署到 Netlify

```bash
# 安装 Netlify CLI
npm install -g netlify-cli

# 登录 Netlify
netlify login

# 部署应用
netlify deploy --prod
```

#### 4.4.2 部署到 AWS

使用 AWS Amplify 部署 Next.js 应用：

1. 登录 AWS 控制台
2. 打开 Amplify 服务
3. 点击 "New app" → "Host web app"
4. 连接 GitHub 仓库
5. 配置构建设置
6. 点击 "Save and deploy"

#### 4.4.3 Docker 部署

创建 `Dockerfile`：

```dockerfile
FROM node:20-alpine AS base

FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM base AS runner
WORKDIR /app
ENV NODE_ENV production
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
USER nextjs
EXPOSE 3000
ENV PORT 3000
CMD ["node", "server.js"]
```

构建和运行 Docker 容器：

```bash
docker build -t my-blog .
docker run -p 3000:3000 my-blog
```

## 五、性能监控与优化

### 5.1 使用 Lighthouse 进行性能分析

使用 Lighthouse 分析应用性能：

```bash
# 安装 Lighthouse CLI
npm install -g lighthouse

# 运行 Lighthouse 分析
lighthouse https://example.com --view
```

### 5.2 使用 Next.js Analytics

配置 Next.js Analytics，监控应用性能：

1. 登录 Vercel 控制台
2. 打开项目设置
3. 启用 "Analytics"
4. 复制分析 ID
5. 在 `next.config.mjs` 中配置：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  analyticsId: 'your-analytics-id',
};

export default nextConfig;
```

### 5.3 使用 Sentry 进行错误监控

配置 Sentry，监控应用错误：

```bash
npm install @sentry/nextjs
```

初始化 Sentry：

```bash
npx @sentry/wizard -i nextjs
```

配置 `sentry.client.config.ts` 和 `sentry.server.config.ts`：

```typescript
// sentry.client.config.ts
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: 'https://your-dsn@sentry.io/123456',
  tracesSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
});
```

## 六、总结

在本章节中，我们学习了 Next.js 应用的性能优化、测试策略和部署准备，包括：

1. 性能优化：
   - 代码分割和懒加载
   - 图像优化和字体优化
   - 缓存策略
   - 服务器组件优化
   - 构建优化

2. 测试策略：
   - 单元测试、集成测试和端到端测试
   - 测试最佳实践
   - 测试覆盖率和命名规范

3. 最佳实践：
   - 代码规范和安全最佳实践
   - 可维护性和代码复用
   - 目录结构和文档

4. 部署准备：
   - 环境配置和构建配置
   - CI/CD 流程
   - 部署到 Vercel、Netlify、AWS 和 Docker

5. 性能监控：
   - 使用 Lighthouse 进行性能分析
   - Next.js Analytics
   - Sentry 错误监控

通过本章节的学习，我们已经掌握了 Next.js 应用的完整开发流程，从项目初始化到部署上线，涵盖了性能优化、测试、部署等各个方面。现在，我们可以将所学的知识应用到实际项目中，构建高性能、可维护的生产级 Next.js 应用。

---

**学习计划完成**：Next.js 从0到1完整学习计划

恭喜你完成了 Next.js 从0到1完整学习计划！通过本学习计划，你已经掌握了 Next.js 的核心概念、特性和最佳实践，能够独立构建生产级别的 Next.js 应用。

学习是一个持续的过程，建议你：
1. 关注 Next.js 的最新动态和更新
2. 参与 Next.js 社区，与其他开发者交流学习
3. 阅读优秀的 Next.js 开源项目源码
4. 尝试构建更复杂的 Next.js 应用
5. 学习 Next.js 的高级特性，如 WebSockets、GraphQL 集成等

祝你在 Next.js 开发之路上越走越远！