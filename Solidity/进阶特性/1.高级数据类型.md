# 高级数据类型

## 一、结构体（Structs）

### 1.1 结构体定义和使用
- 结构体是自定义的复合数据类型
- 可以包含不同类型的成员变量
- 用于组织相关数据
- 示例：
  ```solidity
  // 定义结构体
  struct Person {
      string name;
      uint256 age;
      address wallet;
      bool isActive;
  }
  
  contract StructExample {
      // 状态变量：结构体数组
      Person[] public people;
      
      // 状态变量：结构体映射
      mapping(address => Person) public personByAddress;
      
      // 添加人员
      function addPerson(string memory _name, uint256 _age) public {
          Person memory newPerson = Person({
              name: _name,
              age: _age,
              wallet: msg.sender,
              isActive: true
          });
          
          people.push(newPerson);
          personByAddress[msg.sender] = newPerson;
      }
      
      // 更新人员信息
      function updatePerson(address _wallet, uint256 _newAge) public {
          // 找到对应的Person
          for (uint256 i = 0; i < people.length; i++) {
              if (people[i].wallet == _wallet) {
                  // 更新结构体
                  people[i].age = _newAge;
                  personByAddress[_wallet].age = _newAge;
                  break;
              }
          }
      }
  }
  ```

### 1.2 结构体的存储位置
- 结构体可以存储在`storage`、`memory`或`calldata`中
- 示例：
  ```solidity
  function structStorageExample() public {
      // storage结构体（引用）
      Person storage person1 = people[0];
      person1.age = 30; // 会修改原始数据
      
      // memory结构体（副本）
      Person memory person2 = people[0];
      person2.age = 40; // 不会修改原始数据
  }
  ```

### 1.3 结构体作为函数参数和返回值
- 结构体可以作为函数参数和返回值
- 示例：
  ```solidity
  // 结构体作为参数
  function processPerson(Person memory _person) public pure returns (string memory) {
      return string(abi.encodePacked("Hello, ", _person.name));
  }
  
  // 结构体作为返回值
  function getPerson(address _wallet) public view returns (Person memory) {
      return personByAddress[_wallet];
  }
  
  // 返回多个结构体
  function getFirstTwoPeople() public view returns (Person memory, Person memory) {
      require(people.length >= 2, "Not enough people");
      return (people[0], people[1]);
  }
  ```

## 二、枚举（Enums）

### 2.1 枚举定义和使用
- 枚举是自定义的类型，用于表示一组离散值
- 每个枚举值都有一个对应的整数
- 默认从0开始
- 示例：
  ```solidity
  // 定义枚举
  enum Status {
      Pending,
      Active,
      Completed,
      Canceled
  }
  
  contract EnumExample {
      // 状态变量：枚举类型
      Status public currentStatus;
      
      // 映射：地址到状态
      mapping(address => Status) public userStatus;
      
      // 设置状态
      function setStatus(Status _status) public {
          currentStatus = _status;
      }
      
      // 设置用户状态
      function setUserStatus(Status _status) public {
          userStatus[msg.sender] = _status;
      }
      
      // 获取状态作为整数
      function getStatusAsInt() public view returns (uint256) {
          return uint256(currentStatus);
      }
      
      // 基于状态执行不同操作
      function processStatus() public view returns (string memory) {
          if (currentStatus == Status.Pending) {
              return "Pending: Waiting for approval";
          } else if (currentStatus == Status.Active) {
              return "Active: In progress";
          } else if (currentStatus == Status.Completed) {
              return "Completed: Successfully finished";
          } else {
              return "Canceled: Operation canceled";
          }
      }
  }
  ```

### 2.2 枚举的转换
- 枚举可以转换为整数，反之亦然
- 示例：
  ```solidity
  function enumConversion() public {
      // 枚举到整数
      uint256 statusInt = uint256(Status.Active); // 1
      
      // 整数到枚举
      Status statusEnum = Status(statusInt); // Status.Active
      
      // 安全转换
      function safeConvertToStatus(uint256 _value) public pure returns (Status) {
          require(_value < uint256(Status.Canceled) + 1, "Invalid status value");
          return Status(_value);
      }
  }
  ```

## 三、数组（Arrays）

### 3.1 数组定义和初始化
- 固定大小数组：`type[size]`
- 动态大小数组：`type[]`
- 示例：
  ```solidity
  contract ArrayExample {
      // 固定大小数组
      uint256[5] public fixedArray = [1, 2, 3, 4, 5];
      
      // 动态大小数组
      uint256[] public dynamicArray;
      string[] public stringArray;
      
      // 结构体数组
      Person[] public personArray;
      
      // 初始化数组
      constructor() {
          dynamicArray = [uint256(10), 20, 30];
          stringArray = ["apple", "banana", "cherry"];
      }
  }
  ```

### 3.2 数组操作
- **push**：向动态数组末尾添加元素
- **pop**：移除动态数组末尾元素
- **length**：获取数组长度
- 示例：
  ```solidity
  function arrayOperations() public {
      // 添加元素
      dynamicArray.push(40);
      stringArray.push("date");
      
      // 移除元素
      dynamicArray.pop();
      
      // 获取长度
      uint256 arrayLength = dynamicArray.length;
      
      // 修改元素
      dynamicArray[0] = 100;
      
      // 遍历数组
      for (uint256 i = 0; i < dynamicArray.length; i++) {
          // 处理每个元素
      }
  }
  ```

### 3.3 多维数组
- 支持二维及以上的数组
- 示例：
  ```solidity
  contract MultiDimensionalArray {
      // 二维固定大小数组
      uint256[2][3] public twoDimFixedArray = [
          [1, 2],
          [3, 4],
          [5, 6]
      ];
      
      // 二维动态数组
      uint256[][] public twoDimDynamicArray;
      
      function addRow() public {
          // 添加一行
          twoDimDynamicArray.push([uint256(1), 2, 3]);
          
          // 访问元素
          uint256 element = twoDimDynamicArray[0][1]; // 2
      }
  }
  ```

### 3.4 数组的存储位置
- 数组可以存储在`storage`、`memory`或`calldata`中
- 示例：
  ```solidity
  function arrayStorage() public {
      // storage数组（引用）
      uint256[] storage myStorageArray = dynamicArray;
      myStorageArray[0] = 500; // 会修改原始数据
      
      // memory数组（副本）
      uint256[] memory myMemoryArray = dynamicArray;
      myMemoryArray[0] = 1000; // 不会修改原始数据
      
      // 创建新的memory数组
      uint256[] memory newArray = new uint256[](5);
      for (uint256 i = 0; i < newArray.length; i++) {
          newArray[i] = i * 2;
      }
  }
  ```

## 四、映射（Mappings）

### 4.1 映射定义和使用
- 映射是键值对存储结构
- 类似于哈希表
- 只能用于状态变量
- 示例：
  ```solidity
  contract MappingExample {
      // 基本映射
      mapping(address => uint256) public balances;
      mapping(string => address) public nameToAddress;
      
      // 嵌套映射
      mapping(address => mapping(address => uint256)) public allowances;
      mapping(address => mapping(uint256 => bool)) public userPermissions;
      
      // 设置映射值
      function setBalance(address _user, uint256 _amount) public {
          balances[_user] = _amount;
      }
      
      // 获取映射值
      function getBalance(address _user) public view returns (uint256) {
          return balances[_user];
      }
      
      // 设置嵌套映射值
      function setAllowance(address _owner, address _spender, uint256 _amount) public {
          allowances[_owner][_spender] = _amount;
      }
      
      // 获取嵌套映射值
      function getAllowance(address _owner, address _spender) public view returns (uint256) {
          return allowances[_owner][_spender];
      }
  }
  ```

### 4.2 映射的特性
- 映射的键可以是任何基本类型
- 映射的值可以是任何类型，包括结构体和数组
- 映射没有长度，无法遍历
- 映射的所有键默认对应值为0或false
- 示例：
  ```solidity
  function mappingFeatures() public view returns (uint256, bool) {
      // 默认值
      uint256 defaultBalance = balances[address(0x123)]; // 0
      bool defaultPermission = userPermissions[msg.sender][1]; // false
      
      return (defaultBalance, defaultPermission);
  }
  ```

### 4.3 映射的遍历
- 映射本身无法直接遍历
- 需要维护一个额外的数组来存储键
- 示例：
  ```solidity
  contract MappingWithKeys {
      mapping(address => uint256) public balances;
      address[] public userAddresses;
      
      function addUser(address _user, uint256 _balance) public {
          // 只有新用户才添加到数组
          if (balances[_user] == 0) {
              userAddresses.push(_user);
          }
          balances[_user] = _balance;
      }
      
      function getAllBalances() public view returns (address[] memory, uint256[] memory) {
          uint256 length = userAddresses.length;
          uint256[] memory balancesArray = new uint256[](length);
          
          for (uint256 i = 0; i < length; i++) {
              balancesArray[i] = balances[userAddresses[i]];
          }
          
          return (userAddresses, balancesArray);
      }
      
      function getTotalBalance() public view returns (uint256) {
          uint256 total = 0;
          for (uint256 i = 0; i < userAddresses.length; i++) {
              total += balances[userAddresses[i]];
          }
          return total;
      }
  }
  ```

## 五、动态字节数组（Bytes）

### 5.1 字节数组类型
- **bytes1**到**bytes32**：固定大小的字节数组
- **bytes**：动态大小的字节数组
- **string**：UTF-8编码的动态字节数组
- 示例：
  ```solidity
  contract BytesExample {
      // 固定大小字节数组
      bytes1 public b1 = 0x12;
      bytes2 public b2 = 0x1234;
      bytes32 public b32 = 0x1234567890123456789012345678901234567890123456789012345678901234;
      
      // 动态字节数组
      bytes public dynamicBytes;
      string public myString = "Hello, Solidity!";
  }
  ```

### 5.2 字节数组操作
- **push**：向动态字节数组添加字节
- **length**：获取字节数组长度
- **索引访问**：通过索引访问单个字节
- 示例：
  ```solidity
  function bytesOperations() public {
      // 初始化动态字节数组
      dynamicBytes = "Hello"; // 等同于bytes("Hello")
      
      // 添加字节
      dynamicBytes.push(0x21); // 添加感叹号
      
      // 获取长度
      uint256 bytesLength = dynamicBytes.length;
      
      // 访问单个字节
      bytes1 firstByte = dynamicBytes[0]; // 'H'的ASCII码
      
      // 修改字节
      dynamicBytes[0] = 0x4A; // 将'H'改为'J'
  }
  ```

### 5.3 字节数组和字符串转换
- 字节数组和字符串可以相互转换
- 示例：
  ```solidity
  function bytesStringConversion() public view returns (string memory, bytes memory) {
      // 字符串到字节数组
      bytes memory strBytes = bytes(myString);
      
      // 字节数组到字符串
      string memory bytesStr = string(dynamicBytes);
      
      return (bytesStr, strBytes);
  }
  ```

### 5.4 字节数组的比较
- 使用`keccak256`哈希进行比较
- 示例：
  ```solidity
  function compareBytes(bytes memory a, bytes memory b) public pure returns (bool) {
      return keccak256(a) == keccak256(b);
  }
  
  function compareStrings(string memory a, string memory b) public pure returns (bool) {
      return keccak256(bytes(a)) == keccak256(bytes(b));
  }
  ```

## 六、实践项目：NFT元数据管理

### 6.1 项目概述
- 实现一个NFT元数据管理合约
- 支持创建和更新NFT元数据
- 使用结构体存储元数据
- 使用映射关联tokenId和元数据

### 6.2 合约代码
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NFTMetadata {
    // 枚举：NFT类型
    enum NFTType {
        Art,
        Music,
        Video,
        GameItem
    }
    
    // 结构体：NFT元数据
    struct Metadata {
        string name;
        string description;
        string imageURL;
        NFTType nftType;
        uint256 createdAt;
        mapping(string => string) attributes;
    }
    
    // 状态变量
    uint256 public nextTokenId;
    mapping(uint256 => Metadata) public tokenMetadata;
    mapping(uint256 => string[]) public attributeKeys;
    
    // 事件
    event NFTMetadataCreated(uint256 indexed tokenId, string name, NFTType nftType);
    event NFTMetadataUpdated(uint256 indexed tokenId, string name);
    event AttributeAdded(uint256 indexed tokenId, string key, string value);
    
    // 创建NFT元数据
    function createMetadata(
        string memory _name,
        string memory _description,
        string memory _imageURL,
        NFTType _nftType
    ) public returns (uint256) {
        uint256 tokenId = nextTokenId;
        nextTokenId++;
        
        Metadata storage metadata = tokenMetadata[tokenId];
        metadata.name = _name;
        metadata.description = _description;
        metadata.imageURL = _imageURL;
        metadata.nftType = _nftType;
        metadata.createdAt = block.timestamp;
        
        emit NFTMetadataCreated(tokenId, _name, _nftType);
        return tokenId;
    }
    
    // 更新NFT元数据
    function updateMetadata(
        uint256 _tokenId,
        string memory _name,
        string memory _description,
        string memory _imageURL
    ) public {
        Metadata storage metadata = tokenMetadata[_tokenId];
        metadata.name = _name;
        metadata.description = _description;
        metadata.imageURL = _imageURL;
        
        emit NFTMetadataUpdated(_tokenId, _name);
    }
    
    // 添加属性
    function addAttribute(
        uint256 _tokenId,
        string memory _key,
        string memory _value
    ) public {
        Metadata storage metadata = tokenMetadata[_tokenId];
        
        // 检查属性是否已存在
        bool exists = false;
        for (uint256 i = 0; i < attributeKeys[_tokenId].length; i++) {
            if (keccak256(bytes(attributeKeys[_tokenId][i])) == keccak256(bytes(_key))) {
                exists = true;
                break;
            }
        }
        
        // 如果属性不存在，添加到键数组
        if (!exists) {
            attributeKeys[_tokenId].push(_key);
        }
        
        // 设置属性值
        metadata.attributes[_key] = _value;
        emit AttributeAdded(_tokenId, _key, _value);
    }
    
    // 获取属性
    function getAttribute(uint256 _tokenId, string memory _key) public view returns (string memory) {
        return tokenMetadata[_tokenId].attributes[_key];
    }
    
    // 获取所有属性键
    function getAttributeKeys(uint256 _tokenId) public view returns (string[] memory) {
        return attributeKeys[_tokenId];
    }
    
    // 获取元数据（不包括属性）
    function getMetadata(uint256 _tokenId) public view returns (
        string memory name,
        string memory description,
        string memory imageURL,
        NFTType nftType,
        uint256 createdAt
    ) {
        Metadata storage metadata = tokenMetadata[_tokenId];
        return (
            metadata.name,
            metadata.description,
            metadata.imageURL,
            metadata.nftType,
            metadata.createdAt
        );
    }
}
```

### 6.3 部署和测试
1. 在Remix中编译合约
2. 部署合约
3. 测试创建元数据：
   - 调用`createMetadata`函数创建NFT元数据
   - 调用`getMetadata`函数获取元数据
4. 测试更新元数据：
   - 调用`updateMetadata`函数更新元数据
   - 验证更新结果
5. 测试属性管理：
   - 调用`addAttribute`函数添加属性
   - 调用`getAttribute`函数获取属性
   - 调用`getAttributeKeys`函数获取所有属性键

## 七、练习

1. 实现一个带有结构体和枚举的博客合约
2. 编写一个函数，使用数组和映射实现投票功能
3. 实现一个多维度数组，用于存储矩阵数据
4. 创建一个合约，使用字节数组处理二进制数据
5. 实现一个NFT元数据管理合约，支持多种属性类型

## 八、总结

通过本章的学习，你已经掌握了Solidity中的高级数据类型，包括：

- 结构体（Structs）：用于组织相关数据
- 枚举（Enums）：用于表示离散值
- 数组（Arrays）：包括固定大小和动态大小数组
- 映射（Mappings）：用于键值对存储
- 动态字节数组（Bytes）：用于处理二进制数据

这些高级数据类型是编写复杂智能合约的基础，它们可以帮助你组织和管理合约中的数据，提高代码的可读性和可维护性。在下一章中，我们将学习函数的高级特性，包括修饰符、视图函数、纯函数等。