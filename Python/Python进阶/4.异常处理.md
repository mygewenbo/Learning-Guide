# 异常处理

## 一、异常概述

### 1.1 什么是异常

异常是程序在执行过程中发生的错误或异常情况，它会中断程序的正常执行流程。在Python中，异常是一个对象，表示程序执行过程中发生的错误。

当程序发生异常时，如果没有进行处理，程序会终止执行，并显示一个错误信息（Traceback），包含异常类型、异常信息和异常发生的位置。

**示例：异常示例**

```python
# 除以零异常
a = 10
b = 0
print(a / b)  # ZeroDivisionError: division by zero

# 索引越界异常
numbers = [1, 2, 3]
print(numbers[5])  # IndexError: list index out of range

# 类型错误
a = 10
b = "20"
print(a + b)  # TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

### 1.2 异常的作用

异常处理是Python编程中的重要组成部分，它的主要作用是：

- **提高程序的健壮性**：即使程序发生异常，也能优雅地处理，而不是直接崩溃
- **提供有用的错误信息**：帮助开发者定位和修复错误
- **控制程序流程**：可以根据异常类型执行不同的处理逻辑
- **资源管理**：确保资源（如文件、网络连接等）在异常发生时也能正确释放

### 1.3 异常处理的基本语法

在Python中，使用`try-except`语句来处理异常：

```python
try:
    # 可能发生异常的代码块
except 异常类型:
    # 异常处理代码块
```

## 二、异常类型

### 2.1 Python内置异常

Python内置了许多异常类型，用于表示不同类型的错误。以下是一些常用的内置异常：

| 异常类型 | 描述 |
|----------|------|
| `BaseException` | 所有异常的基类 |
| `Exception` | 所有非系统退出异常的基类 |
| `SyntaxError` | 语法错误 |
| `IndentationError` | 缩进错误 |
| `NameError` | 名称未定义 |
| `TypeError` | 类型不匹配 |
| `ValueError` | 值无效 |
| `ZeroDivisionError` | 除以零 |
| `IndexError` | 序列索引越界 |
| `KeyError` | 字典键不存在 |
| `AttributeError` | 对象属性不存在 |
| `FileNotFoundError` | 文件未找到 |
| `IOError` | I/O操作失败 |
| `ImportError` | 导入模块失败 |
| `ModuleNotFoundError` | 模块未找到 |
| `KeyboardInterrupt` | 用户中断执行（Ctrl+C） |
| `SystemExit` | 系统退出 |
| `RuntimeError` | 运行时错误 |
| `NotImplementedError` | 方法未实现 |

### 2.2 异常层次结构

Python的异常类型之间存在层次关系，形成一个继承树。所有异常类型都继承自`BaseException`，而`Exception`是所有非系统退出异常的基类。

**异常层次结构简化图**：

```
BaseException
├── Exception
│   ├── ArithmeticError
│   │   ├── ZeroDivisionError
│   │   └── OverflowError
│   ├── LookupError
│   │   ├── IndexError
│   │   └── KeyError
│   ├── NameError
│   ├── TypeError
│   ├── ValueError
│   ├── FileNotFoundError
│   └── ...
├── KeyboardInterrupt
├── SystemExit
└── GeneratorExit
```

## 三、try-except-else-finally语句

### 3.1 try-except语句

`try-except`语句是最基本的异常处理结构，用于捕获和处理异常。

**语法**：

```python
try:
    # 可能发生异常的代码块
except 异常类型1:
    # 处理异常类型1的代码块
except 异常类型2:
    # 处理异常类型2的代码块
except (异常类型3, 异常类型4):
    # 处理异常类型3和4的代码块
except:
    # 处理所有其他异常的代码块
```

**示例**：

```python
try:
    # 可能发生异常的代码
    num1 = int(input("请输入第一个数字："))
    num2 = int(input("请输入第二个数字："))
    result = num1 / num2
    print(f"结果：{result}")
except ValueError:
    # 处理值错误
    print("输入错误：请输入有效的数字")
except ZeroDivisionError:
    # 处理除以零错误
    print("错误：除数不能为零")
except Exception as e:
    # 处理所有其他异常
    print(f"发生了未知错误：{e}")
```

### 3.2 捕获多个异常

可以在一个`except`子句中捕获多个异常，使用元组包含多个异常类型。

**示例**：

```python
try:
    # 可能发生异常的代码
    my_list = [1, 2, 3]
    print(my_list[5])
    my_dict = {"name": "Alice"}
    print(my_dict["age"])
except (IndexError, KeyError) as e:
    # 同时处理索引越界和键不存在异常
    print(f"发生了查找错误：{e}")
```

### 3.3 捕获所有异常

使用不带异常类型的`except`子句可以捕获所有异常，包括系统退出异常。但这种方式不推荐使用，因为它会捕获所有异常，包括你可能不想处理的异常（如`KeyboardInterrupt`）。

**示例**：

```python
try:
    # 可能发生异常的代码
    num = int(input("请输入一个数字："))
    print(f"你输入的数字是：{num}")
except:
    # 捕获所有异常
    print("发生了错误")
```

更推荐的方式是使用`except Exception as e`来捕获所有非系统退出异常：

```python
try:
    # 可能发生异常的代码
    num = int(input("请输入一个数字："))
    print(f"你输入的数字是：{num}")
except Exception as e:
    # 捕获所有非系统退出异常
    print(f"发生了错误：{e}")
```

### 3.4 获取异常信息

可以使用`as`关键字将异常对象赋值给一个变量，然后访问异常对象的属性来获取详细的异常信息。

**示例**：

```python
try:
    # 可能发生异常的代码
    num1 = int(input("请输入第一个数字："))
    num2 = int(input("请输入第二个数字："))
    result = num1 / num2
except Exception as e:
    # 获取异常类型
    print(f"异常类型：{type(e).__name__}")
    # 获取异常信息
    print(f"异常信息：{e}")
    # 获取异常的字符串表示
    print(f"异常字符串：{str(e)}")
```

### 3.5 try-except-else语句

`try-except-else`语句中，`else`子句中的代码会在`try`块没有发生异常时执行。

**语法**：

```python
try:
    # 可能发生异常的代码块
except 异常类型:
    # 异常处理代码块
else:
    # 没有发生异常时执行的代码块
```

**示例**：

```python
try:
    # 可能发生异常的代码
    num1 = int(input("请输入第一个数字："))
    num2 = int(input("请输入第二个数字："))
    result = num1 / num2
except ValueError:
    print("输入错误：请输入有效的数字")
except ZeroDivisionError:
    print("错误：除数不能为零")
else:
    # 没有发生异常时执行
    print(f"计算成功，结果是：{result}")
    print("程序继续执行...")
```

### 3.6 try-except-finally语句

`try-except-finally`语句中，`finally`子句中的代码无论是否发生异常都会执行，通常用于释放资源。

**语法**：

```python
try:
    # 可能发生异常的代码块
except 异常类型:
    # 异常处理代码块
finally:
    # 无论是否发生异常都会执行的代码块
```

**示例**：

```python
# 文件操作示例
try:
    # 打开文件
    file = open("test.txt", "r")
    # 读取文件内容
    content = file.read()
    print(f"文件内容：{content}")
except FileNotFoundError:
    print("错误：文件未找到")
finally:
    # 无论是否发生异常，都会关闭文件
    try:
        file.close()
        print("文件已关闭")
    except NameError:
        # 如果file变量未定义（文件未成功打开），则跳过
        pass
```

### 3.7 try-except-else-finally语句

可以将`else`和`finally`子句结合使用，形成完整的异常处理结构。

**语法**：

```python
try:
    # 可能发生异常的代码块
except 异常类型1:
    # 处理异常类型1的代码块
except 异常类型2:
    # 处理异常类型2的代码块
else:
    # 没有发生异常时执行的代码块
finally:
    # 无论是否发生异常都会执行的代码块
```

**示例**：

```python
try:
    # 可能发生异常的代码
    num1 = int(input("请输入第一个数字："))
    num2 = int(input("请输入第二个数字："))
    result = num1 / num2
except ValueError:
    print("输入错误：请输入有效的数字")
except ZeroDivisionError:
    print("错误：除数不能为零")
else:
    # 没有发生异常时执行
    print(f"计算成功，结果是：{result}")
finally:
    # 无论是否发生异常都会执行
    print("计算结束")
```

### 3.8 使用上下文管理器（with语句）

对于需要手动释放资源的操作（如文件操作、网络连接等），可以使用上下文管理器（`with`语句）来自动管理资源，无论是否发生异常都会正确释放资源。

**语法**：

```python
with 资源获取表达式 as 变量:
    # 使用资源的代码块
```

**示例**：

```python
# 文件操作示例
with open("test.txt", "r") as file:
    try:
        content = file.read()
        print(f"文件内容：{content}")
    except Exception as e:
        print(f"读取文件时发生错误：{e}")
# 退出with块后，文件会自动关闭
print("文件已自动关闭")

# 多个资源的上下文管理器
with open("input.txt", "r") as input_file, open("output.txt", "w") as output_file:
    content = input_file.read()
    output_file.write(content)
```

## 四、抛出异常

### 4.1 raise语句

使用`raise`语句可以手动抛出异常，用于在特定条件下中断程序执行并抛出异常。

**语法**：

```python
raise 异常对象
```

**示例**：

```python
def divide(a, b):
    if b == 0:
        # 手动抛出除以零异常
        raise ZeroDivisionError("除数不能为零")
    return a / b

try:
    result = divide(10, 0)
    print(f"结果：{result}")
except ZeroDivisionError as e:
    print(f"发生错误：{e}")
```

### 4.2 抛出指定类型的异常

可以抛出指定类型的异常，并提供自定义的异常信息。

**示例**：

```python
def check_age(age):
    if not isinstance(age, int):
        # 抛出类型错误
        raise TypeError("年龄必须是整数")
    if age < 0:
        # 抛出自定义值错误
        raise ValueError("年龄不能为负数")
    if age > 150:
        # 抛出自定义值错误
        raise ValueError("年龄不能超过150岁")
    print(f"年龄有效：{age}岁")

try:
    check_age("25")
except Exception as e:
    print(f"发生错误：{e}")

try:
    check_age(-5)
except Exception as e:
    print(f"发生错误：{e}")

try:
    check_age(200)
except Exception as e:
    print(f"发生错误：{e}")
```

### 4.3 重新抛出异常

在`except`块中，可以使用不带参数的`raise`语句重新抛出当前捕获的异常，用于在处理异常后继续传播异常。

**示例**：

```python
def process_data(data):
    try:
        # 处理数据
        result = data["value"] / data["divisor"]
        return result
    except Exception as e:
        # 记录异常信息
        print(f"处理数据时发生错误：{e}")
        # 重新抛出异常
        raise

try:
    data = {"value": 10, "divisor": 0}
    result = process_data(data)
    print(f"结果：{result}")
except Exception as e:
    print(f"捕获到重新抛出的异常：{e}")
```

## 五、自定义异常

### 5.1 创建自定义异常类

在Python中，可以通过继承`Exception`类或其子类来创建自定义异常类。自定义异常类通常用于表示特定领域的错误情况。

**语法**：

```python
class 自定义异常类名(Exception):
    def __init__(self, message):
        super().__init__(message)
```

**示例**：

```python
# 创建自定义异常类
class InvalidAgeError(Exception):
    """无效年龄异常"""
    def __init__(self, age, message="年龄无效"):
        self.age = age
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.message}：{self.age}"

# 使用自定义异常
def check_age(age):
    if age < 0 or age > 150:
        raise InvalidAgeError(age, "年龄必须在0到150之间")
    print(f"年龄有效：{age}岁")

try:
    check_age(200)
except InvalidAgeError as e:
    print(f"捕获到自定义异常：{e}")
    print(f"无效年龄：{e.age}")
```

### 5.2 自定义异常的继承层次

可以创建自定义异常的继承层次，用于表示不同级别的错误。

**示例**：

```python
# 基础异常类
class AppError(Exception):
    """应用程序基础异常"""
    pass

# 数据相关异常
class DataError(AppError):
    """数据相关异常"""
    pass

# 验证异常
class ValidationError(DataError):
    """数据验证异常"""
    pass

# 数据库异常
class DatabaseError(AppError):
    """数据库相关异常"""
    pass

# 使用自定义异常层次
try:
    # 模拟数据验证失败
    raise ValidationError("数据格式不正确")
except ValidationError as e:
    print(f"验证错误：{e}")
except DataError as e:
    print(f"数据错误：{e}")
except AppError as e:
    print(f"应用错误：{e}")
except Exception as e:
    print(f"通用错误：{e}")
```

## 六、异常链

### 6.1 什么是异常链

异常链是指在捕获一个异常后，抛出另一个异常，并保留原始异常的信息，以便更好地追踪异常的根源。

在Python 3中，可以使用`raise 新异常 from 原始异常`语法来创建异常链。

### 6.2 创建异常链

**示例**：

```python
def read_config_file(file_path):
    try:
        with open(file_path, "r") as f:
            content = f.read()
        return content
    except FileNotFoundError as e:
        # 创建异常链，保留原始异常信息
        raise ConfigError(f"无法读取配置文件：{file_path}") from e

class ConfigError(Exception):
    """配置错误异常"""
    pass

try:
    config = read_config_file("non_existent_config.txt")
    print(f"配置内容：{config}")
except ConfigError as e:
    print(f"捕获到配置错误：{e}")
    # 打印完整的异常链
    import traceback
    traceback.print_exc()
```

### 6.3 隐式异常链

当在`except`块中抛出新异常时，如果没有使用`from`关键字，Python会自动创建一个隐式的异常链，并在Traceback中显示"During handling of the above exception, another exception occurred:"。

**示例**：

```python
try:
    1 / 0
except ZeroDivisionError:
    # 隐式异常链
    raise ValueError("发生了值错误")
```

### 6.4 抑制异常链

如果不想在Traceback中显示原始异常，可以使用`raise 新异常 from None`语法来抑制异常链。

**示例**：

```python
try:
    1 / 0
except ZeroDivisionError:
    # 抑制异常链
    raise ValueError("发生了值错误") from None
```

## 七、异常处理的最佳实践

### 7.1 只捕获必要的异常

只捕获你能够处理的异常，不要捕获所有异常。捕获过多的异常会隐藏程序中的问题，使调试变得困难。

**不好的示例**：

```python
try:
    # 可能发生多种异常的代码
    result = some_function()
except:
    # 捕获所有异常，包括无法处理的异常
    print("发生了错误")
```

**好的示例**：

```python
try:
    # 可能发生特定异常的代码
    result = some_function()
except (ValueError, TypeError) as e:
    # 只捕获能够处理的异常
    print(f"发生了可处理的错误：{e}")
    # 进行适当的处理
    result = default_value
```

### 7.2 提供有用的异常信息

在抛出异常时，提供清晰、具体的异常信息，以便开发者能够快速定位和修复问题。

**不好的示例**：

```python
def process_data(data):
    if not data:
        raise ValueError("错误")
```

**好的示例**：

```python
def process_data(data):
    if not data:
        raise ValueError("数据不能为空")
    if not isinstance(data, dict):
        raise TypeError(f"数据必须是字典类型，当前类型是：{type(data).__name__}")
    if "required_field" not in data:
        raise ValueError("数据缺少必填字段：required_field")
```

### 7.3 避免使用异常控制流程

异常处理的开销较大，不应该将异常用于控制正常的程序流程。应该使用条件判断来处理预期的情况，只将异常用于处理意外情况。

**不好的示例**：

```python
def find_item(items, target):
    try:
        index = items.index(target)
        return index
    except ValueError:
        return -1
```

**好的示例**：

```python
def find_item(items, target):
    if target in items:
        return items.index(target)
    return -1
```

### 7.4 清理资源

在发生异常时，确保正确清理资源（如文件、网络连接、数据库连接等）。可以使用`finally`块或上下文管理器（`with`语句）来自动管理资源。

**示例**：

```python
# 使用finally块清理资源
db_connection = None
try:
    db_connection = connect_to_database()
    # 执行数据库操作
    result = db_connection.execute("SELECT * FROM users")
except DatabaseError as e:
    print(f"数据库操作失败：{e}")
finally:
    # 无论是否发生异常，都会关闭数据库连接
    if db_connection:
        db_connection.close()
        print("数据库连接已关闭")

# 使用上下文管理器自动管理资源
with connect_to_database() as db_connection:
    try:
        result = db_connection.execute("SELECT * FROM users")
    except DatabaseError as e:
        print(f"数据库操作失败：{e}")
# 退出with块后，数据库连接会自动关闭
```

### 7.5 记录异常

在捕获异常时，应该记录异常信息，以便后续分析和调试。可以使用Python的`logging`模块来记录异常。

**示例**：

```python
import logging

# 配置日志
logging.basicConfig(level=logging.ERROR, filename="app.log",
                    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")

try:
    # 可能发生异常的代码
    result = 10 / 0
except Exception as e:
    # 记录异常
    logging.error("发生了错误", exc_info=True)
    # 向用户显示友好的错误信息
    print("抱歉，程序发生了错误，请稍后重试")
```

### 7.6 自定义异常类

对于复杂的应用程序，应该创建自定义异常类，以便更好地组织和管理异常。自定义异常类应该继承自适当的基类，并提供有用的异常信息。

**示例**：

```python
# 基础异常类
class ServiceError(Exception):
    """服务基础异常"""
    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code
    
    def __str__(self):
        if self.error_code:
            return f"{self.error_code}: {self.args[0]}"
        return self.args[0]

# 认证异常
class AuthenticationError(ServiceError):
    """认证异常"""
    def __init__(self, message, error_code="AUTH_ERROR"):
        super().__init__(message, error_code)

# 授权异常
class AuthorizationError(ServiceError):
    """授权异常"""
    def __init__(self, message, error_code="AUTHZ_ERROR"):
        super().__init__(message, error_code)

# 使用自定义异常
try:
    # 模拟认证失败
    raise AuthenticationError("无效的用户名或密码")
except AuthenticationError as e:
    print(f"认证失败：{e}")
    print(f"错误代码：{e.error_code}")
```

## 八、常见异常处理场景

### 8.1 文件操作

```python
def read_file(file_path):
    """读取文件内容"""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
        return content
    except FileNotFoundError:
        print(f"错误：文件 {file_path} 未找到")
        return ""
    except PermissionError:
        print(f"错误：没有权限读取文件 {file_path}")
        return ""
    except UnicodeDecodeError:
        print(f"错误：文件 {file_path} 编码格式不正确")
        return ""
    except Exception as e:
        print(f"读取文件 {file_path} 时发生未知错误：{e}")
        return ""

# 使用
content = read_file("test.txt")
if content:
    print(f"文件内容：{content[:100]}...")
```

### 8.2 网络请求

```python
import requests

class NetworkError(Exception):
    """网络请求异常"""
    pass

def get_api_data(url):
    """从API获取数据"""
    try:
        response = requests.get(url, timeout=5)
        # 检查响应状态码
        response.raise_for_status()
        # 返回JSON数据
        return response.json()
    except requests.exceptions.Timeout:
        raise NetworkError(f"请求 {url} 超时")
    except requests.exceptions.ConnectionError:
        raise NetworkError(f"无法连接到 {url}")
    except requests.exceptions.HTTPError as e:
        raise NetworkError(f"HTTP错误：{e.response.status_code} - {e.response.reason}")
    except ValueError:
        raise NetworkError(f"响应不是有效的JSON格式")
    except Exception as e:
        raise NetworkError(f"请求 {url} 时发生未知错误：{e}")

# 使用
try:
    data = get_api_data("https://api.example.com/data")
    print(f"API数据：{data}")
except NetworkError as e:
    print(f"网络请求失败：{e}")
```

### 8.3 数据库操作

```python
import sqlite3

class DatabaseError(Exception):
    """数据库操作异常"""
    pass

def execute_query(db_path, query, params=None):
    """执行SQL查询"""
    conn = None
    cursor = None
    try:
        # 连接数据库
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # 执行查询
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        # 提交事务（如果是写操作）
        conn.commit()
        
        # 返回结果
        return cursor.fetchall()
    except sqlite3.IntegrityError:
        raise DatabaseError("数据库完整性错误")
    except sqlite3.OperationalError as e:
        raise DatabaseError(f"数据库操作错误：{e}")
    except Exception as e:
        raise DatabaseError(f"数据库查询失败：{e}")
    finally:
        # 清理资源
        if cursor:
            cursor.close()
        if conn:
            conn.close()

# 使用
try:
    results = execute_query(":memory:", "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
    results = execute_query(":memory:", "INSERT INTO users (name) VALUES (?)", ("Alice",))
    results = execute_query(":memory:", "SELECT * FROM users")
    print(f"查询结果：{results}")
except DatabaseError as e:
    print(f"数据库操作失败：{e}")
```

## 九、总结

本章介绍了Python异常处理的相关知识，包括：

1. **异常概述**：什么是异常、异常的作用、异常处理的基本语法
2. **异常类型**：Python内置异常、异常层次结构
3. **try-except-else-finally语句**：基本用法、捕获多个异常、获取异常信息、使用上下文管理器
4. **抛出异常**：raise语句、抛出指定类型的异常、重新抛出异常
5. **自定义异常**：创建自定义异常类、自定义异常的继承层次
6. **异常链**：创建异常链、隐式异常链、抑制异常链
7. **异常处理的最佳实践**：只捕获必要的异常、提供有用的异常信息、避免使用异常控制流程、清理资源、记录异常
8. **常见异常处理场景**：文件操作、网络请求、数据库操作

通过本章的学习，你应该已经掌握了Python异常处理的基本概念和使用方法，能够编写健壮的Python程序，正确处理各种异常情况。异常处理是Python编程中的重要组成部分，掌握好异常处理可以提高程序的健壮性和可维护性。

## 十、练习

1. 编写一个函数，接收一个字符串，将其转换为整数，如果转换失败，返回默认值0，并打印错误信息。
2. 编写一个函数，读取指定文件的内容，如果文件不存在或读取失败，返回空字符串，并打印相应的错误信息。
3. 创建一个自定义异常类`NegativeNumberError`，用于处理负数输入。编写一个函数，接收一个数字，如果是负数，抛出`NegativeNumberError`异常。
4. 编写一个函数，使用`requests`库获取指定URL的内容，如果请求失败，抛出带有原始异常信息的自定义异常。
5. 使用`try-except-else-finally`语句编写一个程序，模拟用户输入数字，计算其平方根，如果输入不是数字，提示错误信息，无论是否成功，都打印"计算结束"。
6. 编写一个上下文管理器，用于测量代码块的执行时间。
7. 创建一个异常链示例，模拟在处理数据时发生验证错误，然后将其包装为应用程序异常抛出。
8. 编写一个程序，读取配置文件，如果配置文件不存在或格式不正确，使用默认配置，并记录相应的日志。

## 十一、参考资料

1. Python官方文档：https://docs.python.org/zh-cn/3/tutorial/errors.html
2. Python异常层次结构：https://docs.python.org/zh-cn/3/library/exceptions.html
3. 《Python Cookbook》（David Beazley）
4. 《流畅的Python》（Luciano Ramalho）
5. 《Effective Python》（Brett Slatkin）