# 行为型模式

行为型模式关注对象之间的通信和职责分配，通过定义对象之间的交互方式，提高系统的灵活性和可扩展性。行为型模式主要包括观察者模式、策略模式、迭代器模式、模板方法模式、命令模式、状态模式、职责链模式、解释器模式、中介者模式、访问者模式和备忘录模式。

## 一、观察者模式（Observer Pattern）

### 1. 概念
观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新。

### 2. 适用场景
- 当一个对象的状态变化需要通知其他对象时
- 当一个对象需要将自己的状态变化通知给多个对象时
- 当一个对象与其他对象之间的耦合度需要降低时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import List

# 主题接口
class Subject(ABC):
    @abstractmethod
    def attach(self, observer) -> None:
        pass
    
    @abstractmethod
    def detach(self, observer) -> None:
        pass
    
    @abstractmethod
    def notify(self) -> None:
        pass

# 具体主题
class ConcreteSubject(Subject):
    def __init__(self) -> None:
        self._observers: List = []
        self._state: int = 0
    
    @property
    def state(self) -> int:
        return self._state
    
    @state.setter
    def state(self, state: int) -> None:
        self._state = state
        self.notify()
    
    def attach(self, observer) -> None:
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer) -> None:
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self) -> None:
        for observer in self._observers:
            observer.update(self)

# 观察者接口
class Observer(ABC):
    @abstractmethod
    def update(self, subject: Subject) -> None:
        pass

# 具体观察者1
class ConcreteObserver1(Observer):
    def update(self, subject: Subject) -> None:
        print(f"具体观察者1: 主题状态更新为 {subject.state}")

# 具体观察者2
class ConcreteObserver2(Observer):
    def update(self, subject: Subject) -> None:
        print(f"具体观察者2: 主题状态更新为 {subject.state}")

# 客户端代码
def client_code() -> None:
    # 创建主题
    subject = ConcreteSubject()
    
    # 创建观察者
    observer1 = ConcreteObserver1()
    observer2 = ConcreteObserver2()
    
    # 注册观察者
    subject.attach(observer1)
    subject.attach(observer2)
    
    # 改变主题状态
    print("改变主题状态为 1:")
    subject.state = 1
    
    print("\n改变主题状态为 2:")
    subject.state = 2
    
    # 移除一个观察者
    print("\n移除观察者1:")
    subject.detach(observer1)
    
    # 再次改变主题状态
    print("\n改变主题状态为 3:")
    subject.state = 3

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 实现了对象之间的解耦，主题和观察者之间的依赖关系是抽象的
- 可以动态地添加和移除观察者
- 当主题状态变化时，所有观察者都会得到通知并自动更新

#### 缺点
- 观察者数量过多时，通知的效率可能会降低
- 观察者之间的执行顺序可能会影响最终结果
- 可能会导致循环依赖

## 二、策略模式（Strategy Pattern）

### 1. 概念
策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法独立于使用它的客户而变化。

### 2. 适用场景
- 当需要在不同的算法之间进行选择时
- 当需要动态地切换算法时
- 当需要避免使用大量的条件判断语句时
- 当需要封装算法的实现细节时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 策略接口
class Strategy(ABC):
    @abstractmethod
    def do_algorithm(self, data: list) -> list:
        pass

# 具体策略1：冒泡排序
class BubbleSortStrategy(Strategy):
    def do_algorithm(self, data: list) -> list:
        print("使用冒泡排序")
        sorted_data = data.copy()
        n = len(sorted_data)
        for i in range(n):
            for j in range(0, n-i-1):
                if sorted_data[j] > sorted_data[j+1]:
                    sorted_data[j], sorted_data[j+1] = sorted_data[j+1], sorted_data[j]
        return sorted_data

# 具体策略2：快速排序
class QuickSortStrategy(Strategy):
    def do_algorithm(self, data: list) -> list:
        print("使用快速排序")
        sorted_data = data.copy()
        
        def quick_sort(arr):
            if len(arr) <= 1:
                return arr
            pivot = arr[len(arr) // 2]
            left = [x for x in arr if x < pivot]
            middle = [x for x in arr if x == pivot]
            right = [x for x in arr if x > pivot]
            return quick_sort(left) + middle + quick_sort(right)
        
        return quick_sort(sorted_data)

# 上下文类
class Context:
    def __init__(self, strategy: Strategy) -> None:
        self._strategy = strategy
    
    @property
    def strategy(self) -> Strategy:
        return self._strategy
    
    @strategy.setter
    def strategy(self, strategy: Strategy) -> None:
        self._strategy = strategy
    
    def do_some_business_logic(self, data: list) -> list:
        # 使用当前策略执行算法
        return self._strategy.do_algorithm(data)

# 客户端代码
def client_code() -> None:
    # 创建上下文
    context = Context(BubbleSortStrategy())
    
    # 测试数据
    data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
    
    print(f"原始数据: {data}")
    
    # 使用冒泡排序
    result = context.do_some_business_logic(data)
    print(f"排序结果: {result}")
    
    # 切换到快速排序
    print("\n切换到快速排序:")
    context.strategy = QuickSortStrategy()
    result = context.do_some_business_logic(data)
    print(f"排序结果: {result}")

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 可以动态地切换算法
- 避免了使用大量的条件判断语句
- 实现了算法的封装，提高了代码的可维护性和可扩展性
- 遵循了开放-封闭原则，新增算法不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 客户端需要知道所有的策略类
- 策略类之间的区别可能不够明显

## 三、迭代器模式（Iterator Pattern）

### 1. 概念
迭代器模式提供了一种方法来访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。

### 2. 适用场景
- 当需要遍历一个聚合对象中的元素，而不暴露该对象的内部表示时
- 当需要为不同的聚合对象提供统一的遍历接口时
- 当需要在遍历过程中对聚合对象进行修改时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import Any, List

# 迭代器接口
class Iterator(ABC):
    @abstractmethod
    def __next__(self) -> Any:
        pass
    
    @abstractmethod
    def has_next(self) -> bool:
        pass

# 具体迭代器
class ConcreteIterator(Iterator):
    def __init__(self, collection: List[Any]) -> None:
        self._collection = collection
        self._index = 0
    
    def __next__(self) -> Any:
        if self.has_next():
            item = self._collection[self._index]
            self._index += 1
            return item
        raise StopIteration
    
    def has_next(self) -> bool:
        return self._index < len(self._collection)

# 聚合接口
class Aggregate(ABC):
    @abstractmethod
    def create_iterator(self) -> Iterator:
        pass

# 具体聚合
class ConcreteAggregate(Aggregate):
    def __init__(self) -> None:
        self._items: List[Any] = []
    
    def add_item(self, item: Any) -> None:
        self._items.append(item)
    
    def create_iterator(self) -> Iterator:
        return ConcreteIterator(self._items)

# 客户端代码
def client_code() -> None:
    # 创建聚合
    aggregate = ConcreteAggregate()
    
    # 添加元素
    aggregate.add_item("元素1")
    aggregate.add_item("元素2")
    aggregate.add_item("元素3")
    aggregate.add_item("元素4")
    aggregate.add_item("元素5")
    
    # 创建迭代器
    iterator = aggregate.create_iterator()
    
    # 遍历聚合
    print("遍历聚合元素:")
    while iterator.has_next():
        item = next(iterator)
        print(item)
    
    # 使用Python的for循环遍历
    print("\n使用Python的for循环遍历:")
    for item in aggregate._items:
        print(item)

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 提供了统一的遍历接口，使得客户端可以使用相同的方式遍历不同的聚合对象
- 隐藏了聚合对象的内部表示，提高了代码的封装性
- 可以在遍历过程中对聚合对象进行修改
- 遵循了单一职责原则，聚合对象只负责存储数据，迭代器负责遍历数据

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 迭代器的实现可能会比较复杂

## 四、模板方法模式（Template Method Pattern）

### 1. 概念
模板方法模式定义了一个算法的骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

### 2. 适用场景
- 当需要定义一个算法的骨架，而将一些步骤延迟到子类中实现时
- 当需要在多个子类中共享算法的公共部分时
- 当需要控制子类的扩展时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 抽象类
class AbstractClass(ABC):
    def template_method(self) -> None:
        """模板方法，定义算法的骨架"""
        self.base_operation1()
        self.required_operation1()
        self.base_operation2()
        self.hook1()
        self.required_operation2()
        self.base_operation3()
        self.hook2()
    
    def base_operation1(self) -> None:
        """基本操作1，由抽象类实现"""
        print("抽象类: 执行基本操作1")
    
    def base_operation2(self) -> None:
        """基本操作2，由抽象类实现"""
        print("抽象类: 执行基本操作2")
    
    def base_operation3(self) -> None:
        """基本操作3，由抽象类实现"""
        print("抽象类: 执行基本操作3")
    
    @abstractmethod
    def required_operation1(self) -> None:
        """必须由子类实现的操作1"""
        pass
    
    @abstractmethod
    def required_operation2(self) -> None:
        """必须由子类实现的操作2"""
        pass
    
    def hook1(self) -> None:
        """钩子方法1，子类可以选择覆盖"""
        pass
    
    def hook2(self) -> None:
        """钩子方法2，子类可以选择覆盖"""
        pass

# 具体类1
class ConcreteClass1(AbstractClass):
    def required_operation1(self) -> None:
        print("具体类1: 实现必须操作1")
    
    def required_operation2(self) -> None:
        print("具体类1: 实现必须操作2")
    
    def hook1(self) -> None:
        print("具体类1: 覆盖钩子方法1")

# 具体类2
class ConcreteClass2(AbstractClass):
    def required_operation1(self) -> None:
        print("具体类2: 实现必须操作1")
    
    def required_operation2(self) -> None:
        print("具体类2: 实现必须操作2")
    
    def hook2(self) -> None:
        print("具体类2: 覆盖钩子方法2")

# 客户端代码
def client_code(abstract_class: AbstractClass) -> None:
    abstract_class.template_method()

# 测试
if __name__ == "__main__":
    print("客户端使用具体类1:")
    concrete_class1 = ConcreteClass1()
    client_code(concrete_class1)
    
    print("\n客户端使用具体类2:")
    concrete_class2 = ConcreteClass2()
    client_code(concrete_class2)
```

### 4. 优缺点

#### 优点
- 定义了算法的骨架，使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
- 实现了代码复用，算法的公共部分由抽象类实现，子类只需要实现特定的步骤
- 控制了子类的扩展，子类只能扩展算法中的特定步骤
- 遵循了开放-封闭原则，新增具体类不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 模板方法的修改可能会影响所有的子类
- 子类的实现可能会受到模板方法的限制

## 五、命令模式（Command Pattern）

### 1. 概念
命令模式将请求封装为一个对象，从而允许你用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

### 2. 适用场景
- 当需要将请求封装为一个对象时
- 当需要支持撤销操作时
- 当需要对请求进行排队或记录请求日志时
- 当需要将请求的发送者和接收者解耦时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 命令接口
class Command(ABC):
    @abstractmethod
    def execute(self) -> None:
        pass
    
    def undo(self) -> None:
        pass

# 接收者类
class Receiver:
    def action(self) -> None:
        print("接收者: 执行操作")
    
    def reverse_action(self) -> None:
        print("接收者: 执行撤销操作")

# 具体命令1
class ConcreteCommand1(Command):
    def __init__(self, receiver: Receiver) -> None:
        self._receiver = receiver
    
    def execute(self) -> None:
        print("具体命令1: 执行")
        self._receiver.action()
    
    def undo(self) -> None:
        print("具体命令1: 撤销")
        self._receiver.reverse_action()

# 具体命令2
class ConcreteCommand2(Command):
    def __init__(self, receiver: Receiver) -> None:
        self._receiver = receiver
    
    def execute(self) -> None:
        print("具体命令2: 执行")
        self._receiver.action()
    
    def undo(self) -> None:
        print("具体命令2: 撤销")
        self._receiver.reverse_action()

# 调用者类
class Invoker:
    def __init__(self) -> None:
        self._commands = []
        self._history = []
    
    def set_command(self, command: Command) -> None:
        self._commands.append(command)
    
    def execute_commands(self) -> None:
        for command in self._commands:
            command.execute()
            self._history.append(command)
        self._commands.clear()
    
    def undo_last_command(self) -> None:
        if self._history:
            last_command = self._history.pop()
            last_command.undo()

# 客户端代码
def client_code() -> None:
    # 创建接收者
    receiver = Receiver()
    
    # 创建命令
    command1 = ConcreteCommand1(receiver)
    command2 = ConcreteCommand2(receiver)
    
    # 创建调用者
    invoker = Invoker()
    
    # 设置命令
    invoker.set_command(command1)
    invoker.set_command(command2)
    
    # 执行命令
    print("执行命令:")
    invoker.execute_commands()
    
    # 撤销最后一个命令
    print("\n撤销最后一个命令:")
    invoker.undo_last_command()
    
    # 再次撤销最后一个命令
    print("\n再次撤销最后一个命令:")
    invoker.undo_last_command()

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 实现了请求的发送者和接收者之间的解耦
- 支持撤销和重做操作
- 可以对请求进行排队或记录请求日志
- 遵循了开放-封闭原则，新增命令不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 命令的实现可能会比较复杂

## 六、状态模式（State Pattern）

### 1. 概念
状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

### 2. 适用场景
- 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变其行为时
- 当一个对象需要根据状态进行大量的条件判断时
- 当需要将状态相关的行为封装到不同的类中时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 状态接口
class State(ABC):
    @abstractmethod
    def handle(self, context) -> None:
        pass

# 具体状态1
class ConcreteState1(State):
    def handle(self, context) -> None:
        print("当前状态: 状态1")
        print("执行状态1的操作")
        # 切换到状态2
        context.state = ConcreteState2()

# 具体状态2
class ConcreteState2(State):
    def handle(self, context) -> None:
        print("当前状态: 状态2")
        print("执行状态2的操作")
        # 切换到状态1
        context.state = ConcreteState1()

# 上下文类
class Context:
    def __init__(self, state: State) -> None:
        self._state = state
    
    @property
    def state(self) -> State:
        return self._state
    
    @state.setter
    def state(self, state: State) -> None:
        self._state = state
        print(f"上下文: 切换到状态 {type(state).__name__}")
    
    def request(self) -> None:
        self._state.handle(self)

# 客户端代码
def client_code() -> None:
    # 创建上下文，初始状态为状态1
    context = Context(ConcreteState1())
    
    # 发送请求，触发状态切换
    print("发送请求1:")
    context.request()
    
    print("\n发送请求2:")
    context.request()
    
    print("\n发送请求3:")
    context.request()
    
    print("\n发送请求4:")
    context.request()

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 将状态相关的行为封装到不同的类中，提高了代码的可维护性和可扩展性
- 避免了使用大量的条件判断语句
- 可以动态地改变对象的状态
- 遵循了单一职责原则，每个状态类只负责处理一种状态
- 遵循了开放-封闭原则，新增状态不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 状态类之间的转换可能会比较复杂

## 七、职责链模式（Chain of Responsibility Pattern）

### 1. 概念
职责链模式使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

### 2. 适用场景
- 当需要让多个对象都有机会处理请求时
- 当需要避免请求的发送者和接收者之间的耦合关系时
- 当需要动态地指定处理请求的对象时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import Optional

# 处理器接口
class Handler(ABC):
    @abstractmethod
    def set_next(self, handler) -> 'Handler':
        pass
    
    @abstractmethod
    def handle(self, request: str) -> Optional[str]:
        pass

# 抽象处理器
class AbstractHandler(Handler):
    _next_handler: Handler = None
    
    def set_next(self, handler: Handler) -> Handler:
        self._next_handler = handler
        return handler
    
    def handle(self, request: str) -> Optional[str]:
        if self._next_handler:
            return self._next_handler.handle(request)
        return None

# 具体处理器1：处理A类型的请求
class ConcreteHandlerA(AbstractHandler):
    def handle(self, request: str) -> Optional[str]:
        if request == "A":
            return f"ConcreteHandlerA: 处理请求 {request}"
        return super().handle(request)

# 具体处理器2：处理B类型的请求
class ConcreteHandlerB(AbstractHandler):
    def handle(self, request: str) -> Optional[str]:
        if request == "B":
            return f"ConcreteHandlerB: 处理请求 {request}"
        return super().handle(request)

# 具体处理器3：处理C类型的请求
class ConcreteHandlerC(AbstractHandler):
    def handle(self, request: str) -> Optional[str]:
        if request == "C":
            return f"ConcreteHandlerC: 处理请求 {request}"
        return super().handle(request)

# 客户端代码
def client_code(handler: Handler) -> None:
    # 测试不同类型的请求
    for request in ["A", "B", "C", "D"]:
        print(f"\n客户端: 发送请求 {request}")
        result = handler.handle(request)
        if result:
            print(f"  {result}")
        else:
            print(f"  请求 {request} 未被处理")

# 测试
if __name__ == "__main__":
    # 创建处理器
    handler_a = ConcreteHandlerA()
    handler_b = ConcreteHandlerB()
    handler_c = ConcreteHandlerC()
    
    # 构建职责链
    handler_a.set_next(handler_b).set_next(handler_c)
    
    print("职责链: handler_a -> handler_b -> handler_c")
    client_code(handler_a)
    
    print("\n职责链: handler_b -> handler_c")
    client_code(handler_b)
```

### 4. 优缺点

#### 优点
- 实现了请求的发送者和接收者之间的解耦
- 可以动态地指定处理请求的对象
- 可以灵活地调整职责链的结构
- 遵循了开放-封闭原则，新增处理器不需要修改现有代码

#### 缺点
- 请求可能不会被任何处理器处理
- 职责链的构建可能会比较复杂
- 职责链的执行效率可能会比较低

## 八、解释器模式（Interpreter Pattern）

### 1. 概念
解释器模式定义了一种语言的文法，并建立一个解释器来解释该语言中的句子。

### 2. 适用场景
- 当需要解释一种简单的语言时
- 当需要将一个语言中的句子表示为一个抽象语法树时
- 当需要解释执行一些简单的命令时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import List

# 抽象表达式
class AbstractExpression(ABC):
    @abstractmethod
    def interpret(self, context: dict) -> int:
        pass

# 终结符表达式：数字
class NumberExpression(AbstractExpression):
    def __init__(self, value: str) -> None:
        self._value = int(value)
    
    def interpret(self, context: dict) -> int:
        return self._value

# 终结符表达式：变量
class VariableExpression(AbstractExpression):
    def __init__(self, name: str) -> None:
        self._name = name
    
    def interpret(self, context: dict) -> int:
        return context.get(self._name, 0)

# 非终结符表达式：加法
class AddExpression(AbstractExpression):
    def __init__(self, left: AbstractExpression, right: AbstractExpression) -> None:
        self._left = left
        self._right = right
    
    def interpret(self, context: dict) -> int:
        return self._left.interpret(context) + self._right.interpret(context)

# 非终结符表达式：减法
class SubtractExpression(AbstractExpression):
    def __init__(self, left: AbstractExpression, right: AbstractExpression) -> None:
        self._left = left
        self._right = right
    
    def interpret(self, context: dict) -> int:
        return self._left.interpret(context) - self._right.interpret(context)

# 客户端代码
def client_code() -> None:
    # 定义上下文（变量值）
    context = {
        "a": 10,
        "b": 5,
        "c": 2
    }
    
    # 构建抽象语法树：a + b - c
    expression = SubtractExpression(
        AddExpression(
            VariableExpression("a"),
            VariableExpression("b")
        ),
        VariableExpression("c")
    )
    
    # 解释表达式
    result = expression.interpret(context)
    print(f"表达式 'a + b - c' 的结果: {result}")
    
    # 构建抽象语法树：a + (b - c)
    expression2 = AddExpression(
        VariableExpression("a"),
        SubtractExpression(
            VariableExpression("b"),
            VariableExpression("c")
        )
    )
    
    # 解释表达式
    result2 = expression2.interpret(context)
    print(f"表达式 'a + (b - c)' 的结果: {result2}")

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 可以方便地扩展语言的文法
- 可以将语言的文法表示为一个抽象语法树
- 可以解释执行一些简单的命令

#### 缺点
- 对于复杂的语言，解释器模式的实现可能会比较复杂
- 解释器模式的执行效率可能会比较低
- 解释器模式的使用范围受到一定限制

## 九、中介者模式（Mediator Pattern）

### 1. 概念
中介者模式定义了一个对象，用于封装一组对象之间的交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### 2. 适用场景
- 当需要减少对象之间的耦合关系时
- 当需要集中管理对象之间的交互时
- 当需要简化对象之间的通信时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import List

# 中介者接口
class Mediator(ABC):
    @abstractmethod
    def notify(self, sender: 'Colleague', event: str) -> None:
        pass

# 抽象同事类
class Colleague(ABC):
    def __init__(self, mediator: Mediator) -> None:
        self._mediator = mediator

# 具体同事类1：按钮
class Button(Colleague):
    def click(self) -> None:
        print("按钮: 被点击")
        self._mediator.notify(self, "click")

# 具体同事类2：文本框
class TextBox(Colleague):
    def change(self) -> None:
        print("文本框: 内容改变")
        self._mediator.notify(self, "change")

# 具体同事类3：标签
class Label(Colleague):
    def update(self, text: str) -> None:
        print(f"标签: 更新为 '{text}'")

# 具体中介者：表单中介者
class FormMediator(Mediator):
    def __init__(self) -> None:
        self._button = None
        self._text_box = None
        self._label = None
    
    def set_button(self, button: Button) -> None:
        self._button = button
    
    def set_text_box(self, text_box: TextBox) -> None:
        self._text_box = text_box
    
    def set_label(self, label: Label) -> None:
        self._label = label
    
    def notify(self, sender: Colleague, event: str) -> None:
        if sender == self._button and event == "click":
            print("中介者: 处理按钮点击事件")
            if self._label:
                self._label.update("按钮被点击了")
        elif sender == self._text_box and event == "change":
            print("中介者: 处理文本框内容改变事件")
            if self._label:
                self._label.update("文本框内容改变了")

# 客户端代码
def client_code() -> None:
    # 创建中介者
    mediator = FormMediator()
    
    # 创建同事类
    button = Button(mediator)
    text_box = TextBox(mediator)
    label = Label(mediator)
    
    # 注册同事类到中介者
    mediator.set_button(button)
    mediator.set_text_box(text_box)
    mediator.set_label(label)
    
    # 模拟用户操作
    print("用户点击按钮:")
    button.click()
    
    print("\n用户修改文本框:")
    text_box.change()

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 减少了对象之间的耦合关系
- 集中管理对象之间的交互
- 简化了对象之间的通信
- 遵循了单一职责原则，每个对象只负责自己的业务逻辑，中介者负责协调对象之间的交互
- 遵循了开放-封闭原则，新增同事类或修改交互逻辑不需要修改现有同事类

#### 缺点
- 中介者可能会变得过于复杂，承担过多的职责
- 中介者可能会成为系统的瓶颈
- 中介者的修改可能会影响所有的同事类

## 十、访问者模式（Visitor Pattern）

### 1. 概念
访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。

### 2. 适用场景
- 当需要对一个对象结构中的元素进行多种不同的操作，而这些操作又不适合在元素类中实现时
- 当需要在不改变元素类的前提下，定义新的操作时
- 当需要遍历一个对象结构，并对其中的元素执行操作时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import List

# 访问者接口
class Visitor(ABC):
    @abstractmethod
    def visit_concrete_element_a(self, element: 'ConcreteElementA') -> None:
        pass
    
    @abstractmethod
    def visit_concrete_element_b(self, element: 'ConcreteElementB') -> None:
        pass

# 元素接口
class Element(ABC):
    @abstractmethod
    def accept(self, visitor: Visitor) -> None:
        pass

# 具体元素A
class ConcreteElementA(Element):
    def accept(self, visitor: Visitor) -> None:
        visitor.visit_concrete_element_a(self)
    
    def operation_a(self) -> str:
        return "ConcreteElementA的操作"

# 具体元素B
class ConcreteElementB(Element):
    def accept(self, visitor: Visitor) -> None:
        visitor.visit_concrete_element_b(self)
    
    def operation_b(self) -> str:
        return "ConcreteElementB的操作"

# 对象结构
class ObjectStructure:
    def __init__(self) -> None:
        self._elements: List[Element] = []
    
    def add_element(self, element: Element) -> None:
        self._elements.append(element)
    
    def accept(self, visitor: Visitor) -> None:
        for element in self._elements:
            element.accept(visitor)

# 具体访问者1
class ConcreteVisitor1(Visitor):
    def visit_concrete_element_a(self, element: ConcreteElementA) -> None:
        print(f"ConcreteVisitor1: 访问 {element.__class__.__name__}，{element.operation_a()}")
    
    def visit_concrete_element_b(self, element: ConcreteElementB) -> None:
        print(f"ConcreteVisitor1: 访问 {element.__class__.__name__}，{element.operation_b()}")

# 具体访问者2
class ConcreteVisitor2(Visitor):
    def visit_concrete_element_a(self, element: ConcreteElementA) -> None:
        print(f"ConcreteVisitor2: 访问 {element.__class__.__name__}，{element.operation_a()}")
    
    def visit_concrete_element_b(self, element: ConcreteElementB) -> None:
        print(f"ConcreteVisitor2: 访问 {element.__class__.__name__}，{element.operation_b()}")

# 客户端代码
def client_code() -> None:
    # 创建对象结构
    object_structure = ObjectStructure()
    
    # 添加元素
    object_structure.add_element(ConcreteElementA())
    object_structure.add_element(ConcreteElementB())
    
    # 创建访问者1并访问元素
    print("使用ConcreteVisitor1访问元素:")
    visitor1 = ConcreteVisitor1()
    object_structure.accept(visitor1)
    
    # 创建访问者2并访问元素
    print("\n使用ConcreteVisitor2访问元素:")
    visitor2 = ConcreteVisitor2()
    object_structure.accept(visitor2)

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 可以在不改变元素类的前提下，定义新的操作
- 可以对一个对象结构中的元素进行多种不同的操作
- 可以将相关的操作集中到一个访问者类中
- 遵循了单一职责原则，元素类只负责存储数据，访问者类负责处理数据
- 遵循了开放-封闭原则，新增操作不需要修改现有元素类

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 访问者模式的实现可能会比较复杂
- 元素类的修改可能会影响所有的访问者类

## 十一、备忘录模式（Memento Pattern）

### 1. 概念
备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

### 2. 适用场景
- 当需要保存一个对象的内部状态，以便以后恢复时
- 当需要避免暴露对象的内部状态，而又需要提供恢复功能时
- 当需要实现撤销和重做功能时

### 3. 实现方式

```python
from typing import Dict, Any

# 备忘录类
class Memento:
    def __init__(self, state: Dict[str, Any]) -> None:
        # 保存状态的副本
        self._state = state.copy()
    
    def get_state(self) -> Dict[str, Any]:
        return self._state.copy()

# 原发器类
class Originator:
    def __init__(self) -> None:
        self._state: Dict[str, Any] = {}
    
    def set_state(self, key: str, value: Any) -> None:
        self._state[key] = value
    
    def get_state(self) -> Dict[str, Any]:
        return self._state.copy()
    
    def create_memento(self) -> Memento:
        """创建备忘录，保存当前状态"""
        return Memento(self._state)
    
    def restore_from_memento(self, memento: Memento) -> None:
        """从备忘录中恢复状态"""
        self._state = memento.get_state()

# 管理者类
class Caretaker:
    def __init__(self) -> None:
        self._mementos: Dict[str, Memento] = {}
    
    def save_memento(self, name: str, memento: Memento) -> None:
        """保存备忘录"""
        self._mementos[name] = memento
    
    def get_memento(self, name: str) -> Memento:
        """获取备忘录"""
        return self._mementos.get(name)

# 客户端代码
def client_code() -> None:
    # 创建原发器
    originator = Originator()
    
    # 创建管理者
    caretaker = Caretaker()
    
    # 设置初始状态
    originator.set_state("name", "Alice")
    originator.set_state("age", 30)
    originator.set_state("city", "New York")
    
    print(f"初始状态: {originator.get_state()}")
    
    # 保存状态
    caretaker.save_memento("state1", originator.create_memento())
    
    # 修改状态
    originator.set_state("age", 31)
    originator.set_state("city", "London")
    print(f"修改后状态: {originator.get_state()}")
    
    # 保存状态
    caretaker.save_memento("state2", originator.create_memento())
    
    # 再次修改状态
    originator.set_state("name", "Bob")
    originator.set_state("city", "Paris")
    print(f"再次修改后状态: {originator.get_state()}")
    
    # 恢复到第一次保存的状态
    print("\n恢复到第一次保存的状态:")
    originator.restore_from_memento(caretaker.get_memento("state1"))
    print(f"恢复后状态: {originator.get_state()}")
    
    # 恢复到第二次保存的状态
    print("\n恢复到第二次保存的状态:")
    originator.restore_from_memento(caretaker.get_memento("state2"))
    print(f"恢复后状态: {originator.get_state()}")

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 可以保存和恢复对象的内部状态，实现撤销和重做功能
- 不破坏封装性，状态的保存和恢复由原发器自己控制
- 可以保存对象的多个状态，以便以后恢复到不同的状态

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 备忘录的保存和恢复可能会消耗较多的内存和时间
- 备忘录的实现可能会比较复杂

## 十二、行为型模式总结

行为型模式关注对象之间的通信和职责分配，提供了不同的方式来定义对象之间的交互方式，以满足不同的需求：

- **观察者模式**：定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新
- **策略模式**：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换
- **迭代器模式**：提供了一种方法来访问一个聚合对象中的各个元素，而不暴露该对象的内部表示
- **模板方法模式**：定义了一个算法的骨架，而将一些步骤延迟到子类中实现
- **命令模式**：将请求封装为一个对象，从而允许你用不同的请求对客户进行参数化
- **状态模式**：允许一个对象在其内部状态改变时改变它的行为
- **职责链模式**：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系
- **解释器模式**：定义了一种语言的文法，并建立一个解释器来解释该语言中的句子
- **中介者模式**：定义了一个对象，用于封装一组对象之间的交互
- **访问者模式**：表示一个作用于某对象结构中的各元素的操作
- **备忘录模式**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态

选择合适的行为型模式可以提高代码的灵活性、可复用性和可维护性，适应不断变化的需求。在实际应用中，需要根据具体情况选择合适的设计模式，避免过度设计。