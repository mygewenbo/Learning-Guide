# 5. 事件驱动与事件循环

## 5.1 事件驱动架构

### 5.1.1 什么是事件驱动架构

事件驱动架构（Event-Driven Architecture，EDA）是一种软件设计模式，它通过事件的产生和响应来驱动程序的执行。在事件驱动架构中，程序的执行流程由外部事件或内部事件决定，而不是按照预先定义的顺序执行。

### 5.1.2 事件驱动架构的组成

- **事件源**：产生事件的对象或组件
- **事件**：描述发生了什么的对象或数据结构
- **事件监听器**：监听特定事件并在事件发生时执行相应处理逻辑的函数
- **事件发射器**：负责管理事件监听器和触发事件的对象
- **事件循环**：负责处理事件队列的机制

### 5.1.3 事件驱动架构的优势

- **高响应性**：能够快速响应外部事件
- **松耦合**：事件源和事件监听器之间的耦合度低
- **可扩展性**：可以轻松添加新的事件监听器
- **高效性**：适合处理大量并发事件

## 5.2 Node.js的事件循环

### 5.2.1 事件循环的概念

事件循环是Node.js处理异步操作的核心机制，它负责管理事件队列，按照一定的顺序执行事件回调函数。

Node.js的事件循环基于libuv库实现，libuv是一个跨平台的异步I/O库，它提供了事件循环、异步文件I/O、网络I/O等功能。

### 5.2.2 事件循环的阶段

Node.js的事件循环分为以下几个阶段：

1. **timers**：执行setTimeout和setInterval的回调函数
2. **pending callbacks**：执行某些系统操作的回调函数，如TCP错误回调
3. **idle, prepare**：仅内部使用
4. **poll**：执行I/O事件的回调函数，是事件循环中最重要的阶段
   - 计算应该阻塞和轮询I/O的时间
   - 处理poll队列中的事件
5. **check**：执行setImmediate的回调函数
6. **close callbacks**：执行close事件的回调函数，如socket.on('close', ...)

### 5.2.3 事件循环的执行流程

1. 进入事件循环
2. 执行当前阶段的回调函数
3. 进入下一个阶段
4. 重复上述过程，直到所有阶段的回调函数都执行完毕
5. 如果没有更多的回调函数需要执行，事件循环退出

### 5.2.4 事件循环的示例

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
}, 0);

setImmediate(() => {
  console.log('3');
});

process.nextTick(() => {
  console.log('4');
});

console.log('5');

// 输出：1 5 4 2 3
```

## 5.3 EventEmitter类

### 5.3.1 EventEmitter的基本概念

EventEmitter是Node.js的核心类之一，它提供了事件驱动的功能，允许对象注册事件监听器和触发事件。

### 5.3.2 EventEmitter的基本用法

```javascript
const EventEmitter = require('node:events');

// 创建EventEmitter实例
const emitter = new EventEmitter();

// 注册事件监听器
emitter.on('event', (arg1, arg2) => {
  console.log('Event triggered:', arg1, arg2);
});

// 触发事件
emitter.emit('event', 'hello', 'world');
```

### 5.3.3 EventEmitter的常用方法

#### 注册事件监听器

- **on(eventName, listener)**：注册一个事件监听器，每次事件触发时都会执行
- **once(eventName, listener)**：注册一个一次性事件监听器，事件触发后会自动移除
- **prependListener(eventName, listener)**：在监听器数组的开头注册一个事件监听器
- **prependOnceListener(eventName, listener)**：在监听器数组的开头注册一个一次性事件监听器

#### 移除事件监听器

- **off(eventName, listener)**：移除指定的事件监听器
- **removeListener(eventName, listener)**：与off方法相同
- **removeAllListeners([eventName])**：移除所有事件监听器，或指定事件的所有监听器

#### 触发事件

- **emit(eventName, [...args])**：触发指定的事件，并传递参数给监听器

#### 获取事件监听器信息

- **listeners(eventName)**：返回指定事件的监听器数组
- **listenerCount(eventName)**：返回指定事件的监听器数量

### 5.3.4 EventEmitter的示例

```javascript
const EventEmitter = require('node:events');

class MyEmitter extends EventEmitter {
  constructor() {
    super();
    this.count = 0;
  }

  increment() {
    this.count++;
    this.emit('increment', this.count);
  }
}

const myEmitter = new MyEmitter();

// 注册事件监听器
myEmitter.on('increment', (count) => {
  console.log('Count incremented:', count);
});

// 触发事件
myEmitter.increment(); // Count incremented: 1
myEmitter.increment(); // Count incremented: 2
myEmitter.increment(); // Count incremented: 3
```

### 5.3.5 EventEmitter的错误处理

```javascript
const EventEmitter = require('node:events');

const emitter = new EventEmitter();

// 注册错误事件监听器
emitter.on('error', (error) => {
  console.error('Error:', error);
});

// 触发错误事件
emitter.emit('error', new Error('Something went wrong'));
```

## 5.4 异步API与事件循环

### 5.4.1 异步API的分类

- **I/O操作**：如文件读写、网络请求等
- **定时器**：如setTimeout、setInterval等
- **process.nextTick**：在当前事件循环阶段结束后立即执行
- **setImmediate**：在check阶段执行

### 5.4.2 异步API的执行顺序

1. **同步代码**：立即执行
2. **process.nextTick**：在当前阶段结束后立即执行
3. **微任务**：如Promise的回调函数，在process.nextTick之后执行
4. **定时器**：在timers阶段执行
5. **I/O事件**：在poll阶段执行
6. **setImmediate**：在check阶段执行
7. **close事件**：在close callbacks阶段执行

### 5.4.3 异步API的示例

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  process.nextTick(() => {
    console.log('3');
  });
  Promise.resolve().then(() => {
    console.log('4');
  });
}, 0);

process.nextTick(() => {
  console.log('5');
  setTimeout(() => {
    console.log('6');
  }, 0);
  Promise.resolve().then(() => {
    console.log('7');
  });
});

Promise.resolve().then(() => {
  console.log('8');
  process.nextTick(() => {
    console.log('9');
  });
  setTimeout(() => {
    console.log('10');
  }, 0);
});

console.log('11');

// 输出：1 11 5 8 9 7 2 3 4 6 10
```

## 5.5 事件驱动的最佳实践

### 5.5.1 事件命名规范

- 使用有意义的事件名称
- 避免使用保留字作为事件名称
- 使用驼峰式命名或短横线命名

### 5.5.2 事件监听器的最佳实践

- **避免内存泄漏**：及时移除不再需要的事件监听器
- **保持监听器简洁**：复杂的逻辑应该拆分成多个简单的监听器
- **使用once方法**：对于只需要执行一次的监听器，使用once方法
- **限制监听器数量**：使用setMaxListeners方法限制每个事件的监听器数量

### 5.5.3 错误处理的最佳实践

- **始终注册error事件监听器**：避免未捕获的错误导致程序崩溃
- **使用try/catch处理同步错误**：在事件监听器中使用try/catch处理同步错误
- **使用Promise处理异步错误**：在异步操作中使用Promise处理错误

### 5.5.4 性能优化

- **避免频繁触发事件**：减少事件的触发频率
- **使用事件委托**：对于大量相似的元素，使用事件委托
- **使用Buffer处理大数据**：对于大量数据，使用Buffer处理

## 5.6 常见问题与解决方案

### 5.6.1 内存泄漏

**问题**：事件监听器没有被及时移除，导致内存泄漏

**解决方案**：
- 及时移除不再需要的事件监听器
- 使用once方法注册一次性事件监听器
- 使用setMaxListeners方法限制每个事件的监听器数量

### 5.6.2 事件触发顺序问题

**问题**：事件监听器的执行顺序不符合预期

**解决方案**：
- 了解事件循环的执行顺序
- 使用prependListener和prependOnceListener方法调整监听器的执行顺序

### 5.6.3 错误处理问题

**问题**：未捕获的错误导致程序崩溃

**解决方案**：
- 始终注册error事件监听器
- 使用try/catch处理同步错误
- 使用Promise处理异步错误

## 5.7 实践练习

1. 创建一个EventEmitter实例，注册多个事件监听器，并触发事件
2. 实现一个简单的事件总线，用于模块间通信
3. 实现一个带有错误处理的EventEmitter子类
4. 比较setTimeout、setImmediate和process.nextTick的执行顺序
5. 实现一个简单的异步任务队列，使用事件驱动的方式处理任务
6. 实现一个简单的HTTP服务器，使用事件驱动的方式处理请求
7. 实现一个简单的文件监听器，监听文件的变化
8. 实现一个简单的定时器，使用事件驱动的方式触发定时任务

通过以上练习，你将掌握Node.js事件驱动和事件循环的核心概念和使用方法，能够编写高效、可靠的事件驱动应用。