# 路由与中间件

## 一、路由基础

### 1.1 什么是路由

路由是指应用程序如何响应客户端对特定端点的请求，这些端点由URI（或路径）和HTTP请求方法（GET、POST等）定义。路由的结构通常为：

```javascript
app.METHOD(PATH, HANDLER)
```

其中：
- `app` 是Express实例
- `METHOD` 是HTTP请求方法（小写）
- `PATH` 是服务器上的路径
- `HANDLER` 是当路由匹配时执行的函数

### 1.2 基本路由示例

```javascript
// GET请求
app.get('/', (req, res) => {
  res.send('Hello World!');
});

// POST请求
app.post('/', (req, res) => {
  res.send('Got a POST request');
});

// PUT请求
app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user');
});

// DELETE请求
app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user');
});
```

### 1.3 路由参数

路由参数是URL中命名的占位符，用于捕获URL中特定位置的值。路由参数由冒号`:`前缀表示：

```javascript
app.get('/users/:userId/books/:bookId', (req, res) => {
  res.send(req.params);
  // 访问 /users/34/books/8989 会返回：{ "userId": "34", "bookId": "8989" }
});
```

路由参数的名称必须是有效的JavaScript标识符，不能包含连字符`-`，但可以使用下划线`_`。

### 1.4 路由处理程序

路由可以有多个处理程序函数，它们的行为类似中间件，用于处理请求。调用`next()`函数将控制权传递给下一个处理程序：

```javascript
app.get('/example/b', (req, res, next) => {
  console.log('第一个处理程序');
  next();
}, (req, res) => {
  res.send('第二个处理程序');
});
```

也可以将处理程序函数数组作为参数：

```javascript
const cb0 = (req, res, next) => {
  console.log('CB0');
  next();
}

const cb1 = (req, res, next) => {
  console.log('CB1');
  next();
}

const cb2 = (req, res) => {
  res.send('Hello from CB2!');
}

app.get('/example/c', [cb0, cb1, cb2]);
```

## 二、Express Router

### 2.1 Router简介

Express Router是一个独立的模块，可以用来创建模块化、可挂载的路由处理程序。它允许将路由组织成不同的模块，便于维护和扩展。

### 2.2 创建Router实例

```javascript
const express = require('express');
const router = express.Router();

// 定义路由
router.get('/', (req, res) => {
  res.send('Birds home page');
});

router.get('/about', (req, res) => {
  res.send('About birds');
});

// 导出Router
module.exports = router;
```

### 2.3 挂载Router

在主应用中挂载Router：

```javascript
const express = require('express');
const app = express();
const birdsRouter = require('./birds');

// 将birdsRouter挂载到/birds路径
app.use('/birds', birdsRouter);

app.listen(3000);
```

现在，应用程序将能够处理以下请求：
- GET /birds - 返回"Birds home page"
- GET /birds/about - 返回"About birds"

## 三、中间件

### 3.1 中间件的概念

中间件函数是可以访问请求对象（req）、响应对象（res）以及应用程序请求-响应循环中的下一个中间件函数的函数。中间件函数可以执行以下任务：

1. 执行任何代码
2. 修改请求和响应对象
3. 结束请求-响应循环
4. 调用堆栈中的下一个中间件函数

如果当前中间件函数没有结束请求-响应循环，它必须调用`next()`函数将控制权传递给下一个中间件函数，否则请求将被挂起。

### 3.2 中间件的类型

Express应用程序可以使用以下类型的中间件：

1. **应用级中间件**
2. **路由级中间件**
3. **错误处理中间件**
4. **内置中间件**
5. **第三方中间件**

### 3.3 应用级中间件

应用级中间件绑定到Express应用实例，使用`app.use()`和`app.METHOD()`函数：

```javascript
// 没有挂载路径的中间件，每个请求都会执行
app.use((req, res, next) => {
  console.log('Time:', Date.now());
  next();
});

// 挂载到/api路径的中间件，所有/api开头的请求都会执行
app.use('/api', (req, res, next) => {
  console.log('API Request:', req.originalUrl);
  next();
});

// 路由处理程序也是中间件
app.get('/', (req, res) => {
  res.send('Home Page');
});
```

### 3.4 路由级中间件

路由级中间件与应用级中间件类似，但它绑定到`express.Router()`实例：

```javascript
const router = express.Router();

// 路由级中间件
router.use((req, res, next) => {
  console.log('Time:', Date.now());
  next();
});

router.get('/', (req, res) => {
  res.send('Router Home Page');
});

app.use('/router', router);
```

### 3.5 错误处理中间件

错误处理中间件始终带有四个参数：`(err, req, res, next)`。即使不需要使用`next`函数，也必须提供它，否则中间件将被视为常规中间件，无法处理错误：

```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```

### 3.6 内置中间件

Express 4.x版本中，以下中间件已内置在Express中：

- `express.static` - 提供静态资源
- `express.json` - 解析JSON格式的请求体
- `express.urlencoded` - 解析URL编码的请求体

```javascript
// 使用内置中间件
app.use(express.static('public'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
```

### 3.7 第三方中间件

使用第三方中间件可以扩展Express应用的功能。例如，使用`cookie-parser`中间件来解析Cookie：

```bash
npm install cookie-parser
```

```javascript
const cookieParser = require('cookie-parser');
app.use(cookieParser());
```

常见的第三方中间件包括：
- `body-parser` - 解析请求体（Express 4.16+已内置）
- `cookie-parser` - 解析Cookie
- `express-session` - 管理会话
- `morgan` - 日志记录
- `cors` - 处理跨域资源共享

## 四、中间件的执行顺序

中间件的执行顺序取决于它们在代码中定义的顺序。例如：

```javascript
app.use((req, res, next) => {
  console.log('Middleware 1');
  next();
});

app.use((req, res, next) => {
  console.log('Middleware 2');
  next();
});

app.get('/', (req, res) => {
  console.log('Route handler');
  res.send('Hello World');
});
```

当访问根路径时，控制台输出顺序为：
```
Middleware 1
Middleware 2
Route handler
```

## 五、高级路由技巧

### 5.1 路由路径模式

Express支持使用字符串、字符串模式或正则表达式定义路由路径：

```javascript
// 字符串路径
app.get('/about', (req, res) => {
  res.send('About');
});

// 字符串模式路径
app.get('/ab?cd', (req, res) => {
  res.send('ab?cd');
  // 匹配acd或abcd
});

app.get('/ab+cd', (req, res) => {
  res.send('ab+cd');
  // 匹配abcd, abbcd, abbbcd等
});

app.get('/ab*cd', (req, res) => {
  res.send('ab*cd');
  // 匹配abcd, abxcd, abRABDOMcd, ab123cd等
});

// 正则表达式路径
app.get(/a/, (req, res) => {
  res.send('/a/');
  // 匹配任何包含a的路径
});

app.get(/.*fly$/, (req, res) => {
  res.send('/.*fly$/');
  // 匹配以fly结尾的任何路径，如butterfly, dragonfly
});
```

### 5.2 响应方法

Express提供了多种响应方法来结束请求-响应循环：

| 方法 | 描述 |
|------|------|
| res.download() | 提示下载文件 |
| res.end() | 结束响应过程 |
| res.json() | 发送JSON响应 |
| res.jsonp() | 发送带有JSONP支持的JSON响应 |
| res.redirect() | 重定向请求 |
| res.render() | 渲染视图模板 |
| res.send() | 发送各种类型的响应 |
| res.sendFile() | 发送文件作为八位字节流 |
| res.sendStatus() | 设置响应状态码并发送其字符串表示 |

## 六、实践示例

### 6.1 完整的路由与中间件示例

```javascript
const express = require('express');
const app = express();
const port = 3000;

// 内置中间件
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));

// 应用级中间件 - 日志记录
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  next();
});

// 路由处理
app.get('/', (req, res) => {
  res.send('Hello World!');
});

// 用户路由
app.get('/users', (req, res) => {
  res.json([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);
});

app.post('/users', (req, res) => {
  const newUser = req.body;
  res.status(201).json({ message: 'User created', user: newUser });
});

app.get('/users/:id', (req, res) => {
  const userId = req.params.id;
  res.json({ id: userId, name: `User ${userId}` });
});

// 错误处理中间件
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

// 404处理
app.use((req, res) => {
  res.status(404).json({ error: 'Not Found' });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}/`);
});
```

### 6.2 模块化路由示例

**users.js**
```javascript
const express = require('express');
const router = express.Router();

// 用户路由中间件
router.use((req, res, next) => {
  console.log('User route middleware');
  next();
});

router.get('/', (req, res) => {
  res.json([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);
});

router.get('/:id', (req, res) => {
  const userId = req.params.id;
  res.json({ id: userId, name: `User ${userId}` });
});

module.exports = router;
```

**posts.js**
```javascript
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  res.json([{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }]);
});

module.exports = router;
```

**app.js**
```javascript
const express = require('express');
const app = express();
const usersRouter = require('./users');
const postsRouter = require('./posts');

// 挂载模块化路由
app.use('/users', usersRouter);
app.use('/posts', postsRouter);

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

## 七、学习建议

1. **理解中间件的执行顺序**：中间件的执行顺序非常重要，错误的顺序可能导致功能失效或错误
2. **模块化路由设计**：将不同功能的路由组织到不同的模块中，提高代码的可维护性
3. **合理使用中间件**：中间件应该只做一件事，保持单一职责原则
4. **错误处理**：确保每个应用都有适当的错误处理中间件
5. **实践练习**：
   - 创建一个包含多个模块化路由的Express应用
   - 实现不同类型的中间件（应用级、路由级、错误处理）
   - 设计RESTful API，使用路由参数和查询参数
6. **学习资源**：
   - [Express官方文档](https://expressjs.com/zh-cn/guide/routing.html)
   - [Express中间件文档](https://expressjs.com/zh-cn/guide/using-middleware.html)
   - [MDN Web Docs - HTTP请求方法](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)

## 八、小结

路由和中间件是Express应用程序的核心概念。路由定义了应用程序如何响应客户端请求，而中间件则提供了一种灵活的方式来处理请求和响应。通过合理设计路由和中间件，可以创建出结构清晰、易于维护和扩展的Express应用程序。

在学习过程中，要重点理解中间件的执行顺序和不同类型中间件的使用场景，这对于构建复杂的Express应用至关重要。同时，模块化路由设计也是提高代码可维护性的重要实践。