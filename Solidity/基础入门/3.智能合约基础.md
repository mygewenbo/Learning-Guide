# 智能合约基础

## 一、智能合约概述

### 1.1 智能合约定义
- 智能合约是在区块链上运行的自动化程序
- 当满足特定条件时，合约会自动执行相应的操作
- 合约的执行结果是不可篡改的
- 合约代码和状态都存储在区块链上

### 1.2 智能合约的特点
- **去中心化**：不依赖于中心化服务器
- **透明性**：合约代码和执行结果对所有人可见
- **不可篡改性**：一旦部署，合约代码无法修改
- **自动执行**：无需人工干预，根据预设条件执行
- **安全性**：基于密码学和共识机制保障安全

### 1.3 智能合约的生命周期
1. **设计**：确定合约的功能和逻辑
2. **编码**：使用Solidity编写合约代码
3. **编译**：将Solidity代码编译为EVM字节码
4. **测试**：在本地或测试网进行测试
5. **部署**：将合约部署到主网或测试网
6. **交互**：用户通过交易与合约交互
7. **维护**：根据需要升级合约（如果设计了升级机制）

## 二、合约结构深入

### 2.1 合约的基本组成
- **状态变量**：存储合约的持久化数据
- **函数**：定义合约的行为和操作
- **事件**：记录合约状态变化
- **修饰符**：用于修改函数的行为
- **构造函数**：合约部署时执行的初始化函数
- **回退函数**：处理未匹配到函数签名的调用
- **接收函数**：处理直接向合约发送以太币的情况

### 2.2 合约的可见性
- **public**：合约外部和内部都可访问
- **private**：仅合约内部可访问
- **internal**：合约内部和继承合约可访问
- **external**：仅合约外部可访问

### 2.3 合约的继承
- Solidity支持单继承和多继承
- 使用`is`关键字实现继承
- 示例：
  ```solidity
  contract ParentContract {
      uint256 public parentValue;
      
      function parentFunction() public view returns (uint256) {
          return parentValue;
      }
  }
  
  contract ChildContract is ParentContract {
      uint256 public childValue;
      
      function childFunction() public view returns (uint256) {
          return childValue + parentValue;
      }
  }
  ```

## 三、状态管理

### 3.1 状态变量
- 存储在区块链上的持久化数据
- 每个状态变量都有一个存储位置
- 存储成本较高，应尽量优化
- 示例：
  ```solidity
  contract StateExample {
      // 状态变量
      uint256 public count = 0;
      address public owner;
      mapping(address => uint256) public balances;
      
      // 构造函数初始化状态变量
      constructor() {
          owner = msg.sender;
      }
      
      // 函数修改状态变量
      function increment() public {
          count++;
      }
      
      function setBalance(address user, uint256 amount) public {
          balances[user] = amount;
      }
  }
  ```

### 3.2 存储位置
- **storage**：持久化存储在区块链上
- **memory**：临时存储，函数执行完毕后消失
- **calldata**：用于函数参数，只读，不可修改
- 示例：
  ```solidity
  function processArray(uint[] memory inputArray) public returns (uint[] memory) {
      // inputArray存储在memory中
      uint[] memory result = new uint[](inputArray.length);
      
      for (uint i = 0; i < inputArray.length; i++) {
          result[i] = inputArray[i] * 2;
      }
      
      return result;
  }
  ```

### 3.3 状态变量的可见性
- 可以通过public修饰符自动生成getter函数
- 示例：
  ```solidity
  contract PublicVariableExample {
      // 自动生成getter函数：function myVariable() public view returns (uint256) {
      //     return myVariable;
      // }
      uint256 public myVariable = 42;
  }
  ```

## 四、函数深入

### 4.1 函数类型

#### 4.1.1 普通函数
- 可以修改合约状态
- 示例：
  ```solidity
  function updateValue(uint256 newValue) public {
      myValue = newValue;
  }
  ```

#### 4.1.2 视图函数
- 不修改合约状态
- 使用`view`修饰符
- 示例：
  ```solidity
  function getValue() public view returns (uint256) {
      return myValue;
  }
  ```

#### 4.1.3 纯函数
- 不读取也不修改合约状态
- 使用`pure`修饰符
- 示例：
  ```solidity
  function add(uint256 a, uint256 b) public pure returns (uint256) {
      return a + b;
  }
  ```

#### 4.1.4  payable函数
- 可以接收以太币
- 使用`payable`修饰符
- 示例：
  ```solidity
  function deposit() public payable {
      balances[msg.sender] += msg.value;
  }
  ```

### 4.2 函数修饰符
- 用于修改函数的行为
- 可以实现代码复用
- 示例：
  ```solidity
  // 定义修饰符
  modifier onlyOwner() {
      require(msg.sender == owner, "Not authorized");
      _; // 执行函数体
  }
  
  // 使用修饰符
  function restrictedFunction() public onlyOwner {
      // 只有合约所有者可以调用
  }
  
  // 多个修饰符
  modifier validAmount(uint256 amount) {
      require(amount > 0, "Amount must be greater than 0");
      _;
  }
  
  function transfer(address to, uint256 amount) public onlyOwner validAmount(amount) {
      // 只有所有者可以调用，且金额必须大于0
  }
  ```

### 4.3 构造函数
- 合约部署时执行一次
- 用于初始化合约状态
- 示例：
  ```solidity
  contract ConstructorExample {
      address public owner;
      uint256 public initialValue;
      
      // 构造函数
      constructor(uint256 _initialValue) {
          owner = msg.sender;
          initialValue = _initialValue;
      }
  }
  ```

### 4.4 回退函数和接收函数

#### 4.4.1 回退函数
- 处理未匹配到函数签名的调用
- 处理直接向合约发送以太币但没有调用接收函数的情况
- 示例：
  ```solidity
  fallback() external payable {
      // 处理未匹配到函数签名的调用
      emit FallbackCalled(msg.sender, msg.value);
  }
  ```

#### 4.4.2 接收函数
- 处理直接向合约发送以太币的情况
- 示例：
  ```solidity
  receive() external payable {
      // 处理直接向合约发送以太币
      balances[msg.sender] += msg.value;
      emit Received(msg.sender, msg.value);
  }
  ```

## 五、事件和日志系统

### 5.1 事件的作用
- 记录合约状态变化
- 方便外部应用监听和索引
- 降低存储成本（事件存储在交易日志中，成本较低）

### 5.2 事件的定义和使用
- 使用`event`关键字定义事件
- 使用`emit`关键字触发事件
- 示例：
  ```solidity
  contract EventExample {
      // 定义事件
      event Transfer(address indexed from, address indexed to, uint256 value);
      event BalanceUpdated(address indexed user, uint256 newBalance);
      
      mapping(address => uint256) public balances;
      
      function transfer(address to, uint256 value) public returns (bool) {
          require(balances[msg.sender] >= value, "Insufficient balance");
          
          balances[msg.sender] -= value;
          balances[to] += value;
          
          // 触发事件
          emit Transfer(msg.sender, to, value);
          emit BalanceUpdated(msg.sender, balances[msg.sender]);
          emit BalanceUpdated(to, balances[to]);
          
          return true;
      }
  }
  ```

### 5.3 事件的索引和过滤
- 使用`indexed`关键字可以索引事件参数
- 每个事件最多可以有3个索引参数
- 索引参数可以用于高效过滤事件
- 示例：
  ```solidity
  // 定义带索引的事件
  event Transfer(address indexed from, address indexed to, uint256 value);
  
  // 外部应用可以通过索引参数过滤事件
  // 例如：获取所有从特定地址发出的转账
  contract.getPastEvents('Transfer', {
      filter: { from: '0x1234567890123456789012345678901234567890' },
      fromBlock: 0,
      toBlock: 'latest'
  });
  ```

## 六、合约交互基础

### 6.1 合约之间的调用
- 直接调用：通过合约地址和ABI调用
- 示例：
  ```solidity
  // 定义接口
  interface IOtherContract {
      function getValue() external view returns (uint256);
      function setValue(uint256 newValue) external;
  }
  
  contract ContractA {
      IOtherContract public otherContract;
      
      // 构造函数中初始化合约地址
      constructor(address _otherContractAddress) {
          otherContract = IOtherContract(_otherContractAddress);
      }
      
      // 调用其他合约的函数
      function callOtherContract() public {
          uint256 value = otherContract.getValue();
          otherContract.setValue(value + 1);
      }
  }
  ```

### 6.2 以太币的处理
- 使用`payable`修饰符允许函数接收以太币
- 使用`msg.value`获取发送的以太币数量
- 使用`transfer`、`send`或`call`进行转账
- 示例：
  ```solidity
  contract EtherHandling {
      mapping(address => uint256) public balances;
      
      // 接收以太币
      function deposit() public payable {
          balances[msg.sender] += msg.value;
      }
      
      // 转账以太币（使用transfer）
      function withdraw(uint256 amount) public {
          require(balances[msg.sender] >= amount, "Insufficient balance");
          
          balances[msg.sender] -= amount;
          payable(msg.sender).transfer(amount);
      }
      
      // 转账以太币（使用call，推荐）
      function withdrawUsingCall(uint256 amount) public {
          require(balances[msg.sender] >= amount, "Insufficient balance");
          
          balances[msg.sender] -= amount;
          
          (bool success, ) = payable(msg.sender).call{value: amount}("");
          require(success, "Transfer failed");
      }
  }
  ```

## 七、实践项目：简单代币合约

### 7.1 项目概述
- 实现一个简单的代币合约
- 支持代币的发行、转账和余额查询
- 实现基本的ERC20代币功能

### 7.2 合约代码
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleToken {
    // 代币名称
    string public name = "Simple Token";
    
    // 代币符号
    string public symbol = "STK";
    
    // 小数位数
    uint8 public decimals = 18;
    
    // 总供应量
    uint256 public totalSupply;
    
    // 余额映射
    mapping(address => uint256) public balances;
    
    // 授权映射
    mapping(address => mapping(address => uint256)) public allowance;
    
    // 事件
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    // 构造函数
    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
    }
    
    // 转账函数
    function transfer(address to, uint256 value) public returns (bool) {
        require(to != address(0), "Transfer to the zero address");
        require(balances[msg.sender] >= value, "Insufficient balance");
        
        balances[msg.sender] -= value;
        balances[to] += value;
        
        emit Transfer(msg.sender, to, value);
        return true;
    }
    
    // 授权函数
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        
        emit Approval(msg.sender, spender, value);
        return true;
    }
    
    // 授权转账函数
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(to != address(0), "Transfer to the zero address");
        require(balances[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Allowance exceeded");
        
        balances[from] -= value;
        balances[to] += value;
        allowance[from][msg.sender] -= value;
        
        emit Transfer(from, to, value);
        return true;
    }
    
    // 获取余额
    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}
```

### 7.3 部署和测试
1. 在Remix中编译合约
2. 部署合约，设置初始供应量（如1000000）
3. 测试转账功能：
   - 调用`transfer`函数向另一个地址转账
   - 调用`balanceOf`函数检查余额
4. 测试授权功能：
   - 调用`approve`函数授权另一个地址
   - 调用`transferFrom`函数使用授权转账

## 八、练习

1. 设计并实现一个简单的投票合约
2. 实现一个带有权限控制的合约
3. 编写一个合约，实现基本的存款和取款功能
4. 创建一个合约，使用修饰符实现多种权限控制
5. 实现一个简单的众筹合约，包含目标金额和截止时间

## 九、总结

通过本章的学习，你已经深入了解了智能合约的基础概念，包括合约结构、状态管理、函数类型、修饰符、事件和合约交互等。你还实现了一个简单的代币合约，这是智能合约开发中的常见应用。

在下一章中，我们将学习控制流和错误处理，这是编写安全可靠智能合约的重要组成部分。