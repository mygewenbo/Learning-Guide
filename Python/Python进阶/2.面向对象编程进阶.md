# 面向对象编程进阶

## 一、继承的深入理解

### 1.1 继承的本质

继承是面向对象编程的核心特性之一，它允许子类继承父类的属性和方法，实现代码复用。在Python中，继承的本质是**类型关系**，子类是父类的一种特殊类型。

```python
# 父类
class Animal:
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        print(f"{self.name}正在吃东西")

# 子类
class Dog(Animal):
    def bark(self):
        print(f"{self.name}正在汪汪叫")

# 类型关系检查
print(issubclass(Dog, Animal))  # 输出：True

# 实例类型检查
dog = Dog("旺财")
print(isinstance(dog, Dog))     # 输出：True
print(isinstance(dog, Animal))  # 输出：True
```

### 1.2 继承链与方法解析顺序（MRO）

当一个类继承自多个父类时，Python使用**方法解析顺序**（Method Resolution Order，简称MRO）来确定调用哪个父类的方法。

```python
class A:
    def say_hello(self):
        print("Hello from A")

class B(A):
    def say_hello(self):
        print("Hello from B")

class C(A):
    def say_hello(self):
        print("Hello from C")

class D(B, C):
    pass

# 查看MRO
print(D.mro())  # 输出：[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

# 创建对象
d = D()
d.say_hello()  # 输出：Hello from B
```

### 1.3 super()函数的深入理解

`super()`函数用于调用父类的方法，它会根据MRO自动查找父类。

```python
class A:
    def __init__(self, name):
        self.name = name
        print(f"A.__init__ called with {name}")

class B(A):
    def __init__(self, name, age):
        super().__init__(name)
        self.age = age
        print(f"B.__init__ called with {age}")

class C(B):
    def __init__(self, name, age, gender):
        super().__init__(name, age)
        self.gender = gender
        print(f"C.__init__ called with {gender}")

# 创建对象
c = C("Alice", 25, "女")
# 输出：
# A.__init__ called with Alice
# B.__init__ called with 25
# C.__init__ called with 女
```

### 1.4 菱形继承问题

菱形继承是指一个子类继承自两个父类，而这两个父类又继承自同一个祖父类。Python通过C3线性化算法解决了菱形继承问题。

```python
class Grandparent:
    def __init__(self):
        print("Grandparent.__init__ called")

class Parent1(Grandparent):
    def __init__(self):
        super().__init__()
        print("Parent1.__init__ called")

class Parent2(Grandparent):
    def __init__(self):
        super().__init__()
        print("Parent2.__init__ called")

class Child(Parent1, Parent2):
    def __init__(self):
        super().__init__()
        print("Child.__init__ called")

# 查看MRO
print(Child.mro())
# 输出：[<class '__main__.Child'>, <class '__main__.Parent1'>, <class '__main__.Parent2'>, <class '__main__.Grandparent'>, <class 'object'>]

# 创建对象
child = Child()
# 输出：
# Grandparent.__init__ called
# Parent2.__init__ called
# Parent1.__init__ called
# Child.__init__ called
```

## 二、方法重写与重载

### 2.1 方法重写

方法重写是指子类重新实现父类的方法，以实现自己的功能。

```python
class Animal:
    def make_sound(self):
        print("动物发出声音")

class Dog(Animal):
    def make_sound(self):
        print("汪汪叫")

class Cat(Animal):
    def make_sound(self):
        print("喵喵叫")

# 多态调用
animals = [Dog(), Cat()]
for animal in animals:
    animal.make_sound()
# 输出：
# 汪汪叫
# 喵喵叫
```

### 2.2 方法重载

方法重载是指在同一个类中定义多个同名方法，但参数列表不同。Python不直接支持方法重载，但可以通过默认参数、可变参数等方式实现类似功能。

```python
class Calculator:
    def add(self, a, b=0, c=0):
        """支持2个或3个参数的加法"""
        return a + b + c
    
    def multiply(self, *args):
        """支持任意数量参数的乘法"""
        result = 1
        for num in args:
            result *= num
        return result

# 使用
calc = Calculator()
print(calc.add(1, 2))        # 输出：3
print(calc.add(1, 2, 3))     # 输出：6
print(calc.multiply(2, 3))   # 输出：6
print(calc.multiply(2, 3, 4))  # 输出：24
```

### 2.3 运算符重载

Python允许重载运算符，通过实现特殊方法来实现。

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    # 重载加法运算符
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    # 重载减法运算符
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)
    
    # 重载乘法运算符（向量点积）
    def __mul__(self, other):
        if isinstance(other, Vector):
            return self.x * other.x + self.y * other.y
        else:
            # 标量乘法
            return Vector(self.x * other, self.y * other)
    
    # 重载反向乘法运算符
    def __rmul__(self, scalar):
        return self * scalar
    
    # 重载相等运算符
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

# 使用
v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)      # 输出：Vector(4, 6)
print(v1 - v2)      # 输出：Vector(-2, -2)
print(v1 * v2)      # 输出：11（点积）
print(v1 * 3)       # 输出：Vector(3, 6)
print(3 * v1)       # 输出：Vector(3, 6)（反向乘法）
print(v1 == Vector(1, 2))  # 输出：True
```

## 三、抽象类与接口

### 3.1 抽象类

抽象类是一种不能实例化的类，它用于定义子类必须实现的方法。在Python中，使用`abc`模块来创建抽象类。

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    """形状抽象类"""
    
    @abstractmethod
    def area(self):
        """计算面积"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass

class Rectangle(Shape):
    """矩形类"""
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    """圆形类"""
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius

# 使用
shapes = [Rectangle(3, 4), Circle(5)]
for shape in shapes:
    print(f"面积：{shape.area():.2f}，周长：{shape.perimeter():.2f}")
# 输出：
# 面积：12.00，周长：14.00
# 面积：78.54，周长：31.42

# 尝试实例化抽象类（会报错）
# shape = Shape()  # TypeError: Can't instantiate abstract class Shape with abstract methods area, perimeter
```

### 3.2 接口

Python没有专门的接口机制，但可以通过抽象类来模拟接口。接口是一种特殊的抽象类，它只包含抽象方法，不包含任何实现。

```python
from abc import ABC, abstractmethod

class Drawable(ABC):
    """可绘制接口"""
    
    @abstractmethod
    def draw(self):
        """绘制方法"""
        pass

class Resizable(ABC):
    """可调整大小接口"""
    
    @abstractmethod
    def resize(self, factor):
        """调整大小方法"""
        pass

class Circle(Shape, Drawable, Resizable):
    """圆形类，实现了多个接口"""
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius
    
    def draw(self):
        print(f"绘制一个半径为{self.radius}的圆形")
    
    def resize(self, factor):
        self.radius *= factor
        print(f"圆形半径调整为{self.radius}")

# 使用
circle = Circle(5)
circle.draw()      # 输出：绘制一个半径为5的圆形
circle.resize(2)   # 输出：圆形半径调整为10
print(f"面积：{circle.area():.2f}")  # 输出：面积：314.16
```

## 四、特殊方法（魔术方法）

### 4.1 表示方法

- `__str__`：返回对象的字符串表示，用于`print()`和`str()`
- `__repr__`：返回对象的官方字符串表示，用于`repr()`和交互式环境
- `__format__`：用于`format()`函数格式化对象

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"{self.name}({self.age})"
    
    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"
    
    def __format__(self, format_spec):
        if format_spec == "short":
            return self.name
        elif format_spec == "full":
            return f"姓名：{self.name}，年龄：{self.age}"
        else:
            return str(self)

# 使用
person = Person("Alice", 25)
print(person)          # 输出：Alice(25)
print(repr(person))    # 输出：Person(name='Alice', age=25)
print(format(person))  # 输出：Alice(25)
print(format(person, "short"))  # 输出：Alice
print(format(person, "full"))   # 输出：姓名：Alice，年龄：25
```

### 4.2 容器方法

- `__len__`：返回容器长度，用于`len()`
- `__getitem__`：获取容器元素，用于`[]`
- `__setitem__`：设置容器元素，用于`[] =`
- `__delitem__`：删除容器元素，用于`del []`
- `__contains__`：检查元素是否在容器中，用于`in`

```python
class CustomList:
    def __init__(self):
        self.items = []
    
    def __len__(self):
        return len(self.items)
    
    def __getitem__(self, index):
        return self.items[index]
    
    def __setitem__(self, index, value):
        self.items[index] = value
    
    def __delitem__(self, index):
        del self.items[index]
    
    def __contains__(self, item):
        return item in self.items
    
    def append(self, item):
        self.items.append(item)

# 使用
my_list = CustomList()
my_list.append(1)
my_list.append(2)
my_list.append(3)

print(len(my_list))       # 输出：3
print(my_list[0])         # 输出：1
my_list[1] = 10
print(my_list[1])         # 输出：10
del my_list[2]
print(len(my_list))       # 输出：2
print(1 in my_list)       # 输出：True
print(3 in my_list)       # 输出：False
```

### 4.3 迭代方法

- `__iter__`：返回迭代器对象，用于`for`循环
- `__next__`：返回下一个元素，用于迭代器

```python
class Fibonacci:
    def __init__(self, n):
        self.n = n
        self.a, self.b = 0, 1
        self.count = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.count < self.n:
            result = self.a
            self.a, self.b = self.b, self.a + self.b
            self.count += 1
            return result
        else:
            raise StopIteration

# 使用
fib = Fibonacci(10)
for num in fib:
    print(num, end=" ")
# 输出：0 1 1 2 3 5 8 13 21 34
```

### 4.4 比较方法

- `__eq__`：等于，用于`==`
- `__ne__`：不等于，用于`!=`
- `__lt__`：小于，用于`<`
- `__le__`：小于等于，用于`<=`
- `__gt__`：大于，用于`>`
- `__ge__`：大于等于，用于`>=`

```python
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score
    
    def __eq__(self, other):
        return self.score == other.score
    
    def __lt__(self, other):
        return self.score < other.score
    
    def __le__(self, other):
        return self.score <= other.score
    
    def __gt__(self, other):
        return self.score > other.score
    
    def __ge__(self, other):
        return self.score >= other.score

# 使用
stu1 = Student("Alice", 85)
stu2 = Student("Bob", 90)
stu3 = Student("Charlie", 85)

print(stu1 == stu3)  # 输出：True
print(stu1 < stu2)   # 输出：True
print(stu2 > stu3)   # 输出：True
print(stu1 <= stu3)  # 输出：True
print(stu2 >= stu1)  # 输出：True

# 排序
students = [stu1, stu2, stu3]
students.sort()
for stu in students:
    print(f"{stu.name}: {stu.score}")
# 输出：
# Alice: 85
# Charlie: 85
# Bob: 90
```

### 4.5 数值转换方法

- `__int__`：转换为整数，用于`int()`
- `__float__`：转换为浮点数，用于`float()`
- `__bool__`：转换为布尔值，用于`bool()`

```python
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius
    
    def __int__(self):
        return int(self.celsius)
    
    def __float__(self):
        return float(self.celsius)
    
    def __bool__(self):
        return self.celsius > 0
    
    def to_fahrenheit(self):
        return self.celsius * 9/5 + 32

# 使用
temp = Temperature(25.5)
print(int(temp))     # 输出：25
print(float(temp))   # 输出：25.5
print(bool(temp))    # 输出：True

cold_temp = Temperature(-5)
print(bool(cold_temp))  # 输出：False
```

## 五、类的高级特性

### 5.1 类属性与实例属性

```python
class MyClass:
    # 类属性
    class_attr = "类属性值"
    
    def __init__(self, instance_attr):
        # 实例属性
        self.instance_attr = instance_attr

# 访问类属性
print(MyClass.class_attr)  # 输出：类属性值

# 创建实例
obj1 = MyClass("实例1属性值")
obj2 = MyClass("实例2属性值")

# 通过实例访问类属性
print(obj1.class_attr)  # 输出：类属性值
print(obj2.class_attr)  # 输出：类属性值

# 修改类属性
MyClass.class_attr = "修改后的类属性值"
print(obj1.class_attr)  # 输出：修改后的类属性值
print(obj2.class_attr)  # 输出：修改后的类属性值

# 通过实例修改类属性（实际上是创建了一个同名实例属性）
obj1.class_attr = "实例1的类属性副本"
print(obj1.class_attr)  # 输出：实例1的类属性副本
print(obj2.class_attr)  # 输出：修改后的类属性值
print(MyClass.class_attr)  # 输出：修改后的类属性值
```

### 5.2 类方法与静态方法

```python
class MyClass:
    class_attr = "类属性值"
    
    def __init__(self, instance_attr):
        self.instance_attr = instance_attr
    
    # 实例方法
    def instance_method(self):
        return f"实例方法调用，实例属性：{self.instance_attr}，类属性：{self.class_attr}"
    
    # 类方法
    @classmethod
    def class_method(cls):
        return f"类方法调用，类属性：{cls.class_attr}"
    
    # 静态方法
    @staticmethod
    def static_method():
        return "静态方法调用，不访问类属性或实例属性"

# 使用
obj = MyClass("实例属性值")

# 调用实例方法
print(obj.instance_method())  # 输出：实例方法调用，实例属性：实例属性值，类属性：类属性值

# 调用类方法
print(MyClass.class_method())  # 输出：类方法调用，类属性：类属性值
print(obj.class_method())      # 输出：类方法调用，类属性：类属性值

# 调用静态方法
print(MyClass.static_method())  # 输出：静态方法调用，不访问类属性或实例属性
print(obj.static_method())      # 输出：静态方法调用，不访问类属性或实例属性
```

### 5.3 类装饰器

类装饰器用于修改类的行为，可以在类定义时应用。

```python
def singleton(cls):
    """单例装饰器"""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class DatabaseConnection:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        print(f"创建数据库连接：{connection_string}")
    
    def connect(self):
        print(f"连接到数据库：{self.connection_string}")

# 使用
conn1 = DatabaseConnection("mysql://localhost:3306/db1")
conn2 = DatabaseConnection("mysql://localhost:3306/db1")

print(conn1 is conn2)  # 输出：True
conn1.connect()        # 输出：连接到数据库：mysql://localhost:3306/db1
```

### 5.4 元类

元类是创建类的类，它允许你控制类的创建过程。在Python中，默认的元类是`type`。

```python
class MyMeta(type):
    """自定义元类"""
    
    def __new__(cls, name, bases, attrs):
        # 添加一个类属性
        attrs['created_by'] = "MyMeta"
        
        # 修改方法
        for key, value in attrs.items():
            if callable(value) and not key.startswith("__"):
                original_method = value
                
                def wrapper(*args, **kwargs):
                    print(f"调用方法：{key}")
                    return original_method(*args, **kwargs)
                
                attrs[key] = wrapper
        
        return super().__new__(cls, name, bases, attrs)

class MyClass(metaclass=MyMeta):
    def __init__(self, name):
        self.name = name
    
    def say_hello(self):
        return f"Hello, {self.name}!"

# 使用
obj = MyClass("Alice")
print(obj.created_by)  # 输出：MyMeta
print(obj.say_hello())  # 输出：调用方法：say_hello
                        # 输出：Hello, Alice!
```

## 六、面向对象设计原则

### 6.1 单一职责原则（SRP）

一个类应该只有一个引起它变化的原因。

```python
# 违反单一职责原则
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def save(self):
        """保存用户到数据库"""
        pass
    
    def send_email(self, message):
        """发送邮件"""
        pass

# 遵循单一职责原则
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        """保存用户到数据库"""
        pass

class EmailService:
    def send_email(self, user, message):
        """发送邮件"""
        pass
```

### 6.2 开放封闭原则（OCP）

软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。

```python
# 违反开放封闭原则
class DiscountCalculator:
    def calculate_discount(self, customer_type, amount):
        if customer_type == "regular":
            return amount * 0.05
        elif customer_type == "vip":
            return amount * 0.1
        # 新增客户类型需要修改此方法

# 遵循开放封闭原则
from abc import ABC, abstractmethod

class DiscountStrategy(ABC):
    @abstractmethod
    def calculate(self, amount):
        pass

class RegularDiscount(DiscountStrategy):
    def calculate(self, amount):
        return amount * 0.05

class VIPDiscount(DiscountStrategy):
    def calculate(self, amount):
        return amount * 0.1

class DiscountCalculator:
    def __init__(self, discount_strategy):
        self.discount_strategy = discount_strategy
    
    def calculate_discount(self, amount):
        return self.discount_strategy.calculate(amount)

# 使用
regular_calc = DiscountCalculator(RegularDiscount())
vip_calc = DiscountCalculator(VIPDiscount())

print(regular_calc.calculate_discount(100))  # 输出：5.0
print(vip_calc.calculate_discount(100))      # 输出：10.0

# 新增客户类型，不需要修改现有代码
class PremiumDiscount(DiscountStrategy):
    def calculate(self, amount):
        return amount * 0.15

premium_calc = DiscountCalculator(PremiumDiscount())
print(premium_calc.calculate_discount(100))  # 输出：15.0
```

### 6.3 里氏替换原则（LSP）

子类应该可以替换父类，并且不会影响程序的正确性。

```python
# 违反里氏替换原则
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    @property
    def width(self):
        return self._width
    
    @width.setter
    def width(self, value):
        self._width = value
    
    @property
    def height(self):
        return self._height
    
    @height.setter
    def height(self, value):
        self._height = value
    
    def area(self):
        return self._width * self._height

class Square(Rectangle):
    def __init__(self, side):
        super().__init__(side, side)
    
    @property
    def width(self):
        return self._width
    
    @width.setter
    def width(self, value):
        self._width = value
        self._height = value
    
    @property
    def height(self):
        return self._height
    
    @height.setter
    def height(self, value):
        self._height = value
        self._width = value

# 问题：Square类违反了里氏替换原则
# 因为修改Square的width或height会同时修改另一个属性
# 这会导致依赖Rectangle的代码在使用Square时出现意外行为

def test_rectangle(rect):
    rect.width = 10
    rect.height = 20
    assert rect.area() == 200, f"面积应该是200，实际是{rect.area()}"

# 测试Rectangle
test_rectangle(Rectangle(5, 5))  # 通过

# 测试Square（会失败）
# test_rectangle(Square(5))  # AssertionError: 面积应该是200，实际是400
```

### 6.4 依赖倒置原则（DIP）

高层模块不应该依赖低层模块，两者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。

```python
# 违反依赖倒置原则
class MySQLDatabase:
    def connect(self):
        print("连接到MySQL数据库")
    
    def query(self, sql):
        print(f"执行MySQL查询：{sql}")

class UserService:
    def __init__(self):
        # 直接依赖具体的MySQLDatabase类
        self.db = MySQLDatabase()
    
    def get_user(self, user_id):
        self.db.connect()
        self.db.query(f"SELECT * FROM users WHERE id = {user_id}")

# 遵循依赖倒置原则
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def connect(self):
        pass
    
    @abstractmethod
    def query(self, sql):
        pass

class MySQLDatabase(Database):
    def connect(self):
        print("连接到MySQL数据库")
    
    def query(self, sql):
        print(f"执行MySQL查询：{sql}")

class PostgreSQLDatabase(Database):
    def connect(self):
        print("连接到PostgreSQL数据库")
    
    def query(self, sql):
        print(f"执行PostgreSQL查询：{sql}")

class UserService:
    def __init__(self, db: Database):
        # 依赖抽象的Database接口
        self.db = db
    
    def get_user(self, user_id):
        self.db.connect()
        self.db.query(f"SELECT * FROM users WHERE id = {user_id}")

# 使用
mysql_db = MySQLDatabase()
user_service = UserService(mysql_db)
user_service.get_user(1)  # 输出：连接到MySQL数据库
                           # 输出：执行MySQL查询：SELECT * FROM users WHERE id = 1

# 切换到PostgreSQL数据库，不需要修改UserService类
postgresql_db = PostgreSQLDatabase()
user_service2 = UserService(postgresql_db)
user_service2.get_user(1)  # 输出：连接到PostgreSQL数据库
                           # 输出：执行PostgreSQL查询：SELECT * FROM users WHERE id = 1
```

### 6.5 接口隔离原则（ISP）

客户端不应该被迫依赖它不使用的方法。

```python
# 违反接口隔离原则
from abc import ABC, abstractmethod

class Worker(ABC):
    @abstractmethod
    def work(self):
        pass
    
    @abstractmethod
    def eat(self):
        pass

class HumanWorker(Worker):
    def work(self):
        print("人类工作")
    
    def eat(self):
        print("人类吃饭")

class RobotWorker(Worker):
    def work(self):
        print("机器人工作")
    
    def eat(self):
        # 机器人不需要吃饭，但是被迫实现此方法
        pass

# 遵循接口隔离原则
from abc import ABC, abstractmethod

class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class HumanWorker(Workable, Eatable):
    def work(self):
        print("人类工作")
    
    def eat(self):
        print("人类吃饭")

class RobotWorker(Workable):
    def work(self):
        print("机器人工作")
        # 不需要实现eat方法
```

## 七、设计模式应用

### 7.1 创建型模式

#### 7.1.1 工厂方法模式

```python
from abc import ABC, abstractmethod

class Product(ABC):
    @abstractmethod
    def operation(self):
        pass

class ConcreteProduct1(Product):
    def operation(self):
        return "具体产品1的操作结果"

class ConcreteProduct2(Product):
    def operation(self):
        return "具体产品2的操作结果"

class Creator(ABC):
    @abstractmethod
    def factory_method(self):
        pass
    
    def some_operation(self):
        product = self.factory_method()
        result = f"创建者：使用{product.operation()}"
        return result

class ConcreteCreator1(Creator):
    def factory_method(self):
        return ConcreteProduct1()

class ConcreteCreator2(Creator):
    def factory_method(self):
        return ConcreteProduct2()

# 使用
creator1 = ConcreteCreator1()
print(creator1.some_operation())  # 输出：创建者：使用具体产品1的操作结果

creator2 = ConcreteCreator2()
print(creator2.some_operation())  # 输出：创建者：使用具体产品2的操作结果
```

#### 7.1.2 抽象工厂模式

```python
from abc import ABC, abstractmethod

# 抽象产品A
class AbstractProductA(ABC):
    @abstractmethod
    def useful_function_a(self):
        pass

# 具体产品A1
class ConcreteProductA1(AbstractProductA):
    def useful_function_a(self):
        return "具体产品A1的有用功能"

# 具体产品A2
class ConcreteProductA2(AbstractProductA):
    def useful_function_a(self):
        return "具体产品A2的有用功能"

# 抽象产品B
class AbstractProductB(ABC):
    @abstractmethod
    def useful_function_b(self):
        pass
    
    @abstractmethod
    def another_useful_function_b(self, collaborator: AbstractProductA):
        pass

# 具体产品B1
class ConcreteProductB1(AbstractProductB):
    def useful_function_b(self):
        return "具体产品B1的有用功能"
    
    def another_useful_function_b(self, collaborator: AbstractProductA):
        result = collaborator.useful_function_a()
        return f"具体产品B1与({result})协作"

# 具体产品B2
class ConcreteProductB2(AbstractProductB):
    def useful_function_b(self):
        return "具体产品B2的有用功能"
    
    def another_useful_function_b(self, collaborator: AbstractProductA):
        result = collaborator.useful_function_a()
        return f"具体产品B2与({result})协作"

# 抽象工厂
class AbstractFactory(ABC):
    @abstractmethod
    def create_product_a(self):
        pass
    
    @abstractmethod
    def create_product_b(self):
        pass

# 具体工厂1
class ConcreteFactory1(AbstractFactory):
    def create_product_a(self):
        return ConcreteProductA1()
    
    def create_product_b(self):
        return ConcreteProductB1()

# 具体工厂2
class ConcreteFactory2(AbstractFactory):
    def create_product_a(self):
        return ConcreteProductA2()
    
    def create_product_b(self):
        return ConcreteProductB2()

# 客户端代码
def client_code(factory: AbstractFactory):
    product_a = factory.create_product_a()
    product_b = factory.create_product_b()
    
    print(f"{product_b.useful_function_b()}")
    print(f"{product_b.another_useful_function_b(product_a)}")

# 使用
print("客户端：使用具体工厂1")
client_code(ConcreteFactory1())

print("\n客户端：使用具体工厂2")
client_code(ConcreteFactory2())
```

### 7.2 结构型模式

#### 7.2.1 适配器模式

```python
# 目标接口
class Target:
    def request(self):
        return "目标：标准请求"

# 适配者类
class Adaptee:
    def specific_request(self):
        return ".eetpadA eht fo roivaheb laicepS"  # 反向字符串

# 适配器类
class Adapter(Target):
    def __init__(self, adaptee: Adaptee):
        self.adaptee = adaptee
    
    def request(self):
        specific_result = self.adaptee.specific_request()
        # 转换适配者的结果为目标接口期望的格式
        return f"适配器：(转换) {specific_result[::-1]}"

# 客户端代码
def client_code(target: Target):
    print(target.request())

# 使用
print("客户端：直接使用目标对象")
target = Target()
client_code(target)

print("\n客户端：使用适配器包装适配者对象")
adaptee = Adaptee()
adapter = Adapter(adaptee)
client_code(adapter)
```

#### 7.2.2 装饰器模式

```python
from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    @abstractmethod
    def operation(self):
        pass

# 具体组件
class ConcreteComponent(Component):
    def operation(self):
        return "具体组件"

# 装饰器基类
class Decorator(Component):
    def __init__(self, component: Component):
        self._component = component
    
    @abstractmethod
    def operation(self):
        pass

# 具体装饰器A
class ConcreteDecoratorA(Decorator):
    def operation(self):
        return f"具体装饰器A({self._component.operation()})"

# 具体装饰器B
class ConcreteDecoratorB(Decorator):
    def operation(self):
        return f"具体装饰器B({self._component.operation()})"

# 客户端代码
def client_code(component: Component):
    print(f"结果：{component.operation()}")

# 使用
print("客户端：使用未装饰的组件")
simple = ConcreteComponent()
client_code(simple)

print("\n客户端：使用装饰器A装饰组件")
decorator1 = ConcreteDecoratorA(simple)
client_code(decorator1)

print("\n客户端：使用装饰器A和B装饰组件")
decorator2 = ConcreteDecoratorB(decorator1)
client_code(decorator2)
```

### 7.3 行为型模式

#### 7.3.1 观察者模式

```python
from abc import ABC, abstractmethod

# 主题接口
class Subject(ABC):
    @abstractmethod
    def attach(self, observer):
        pass
    
    @abstractmethod
    def detach(self, observer):
        pass
    
    @abstractmethod
    def notify(self):
        pass

# 具体主题
class ConcreteSubject(Subject):
    _state = 0
    _observers = []
    
    def attach(self, observer):
        print("主题：附加了一个观察者")
        self._observers.append(observer)
    
    def detach(self, observer):
        print("主题：移除了一个观察者")
        self._observers.remove(observer)
    
    def notify(self):
        print("主题：通知所有观察者...")
        for observer in self._observers:
            observer.update(self)
    
    def some_business_logic(self):
        print("\n主题：我正在做一些重要的事情")
        self._state += 1
        print(f"主题：我的状态已经改变为：{self._state}")
        self.notify()

# 观察者接口
class Observer(ABC):
    @abstractmethod
    def update(self, subject: Subject):
        pass

# 具体观察者A
class ConcreteObserverA(Observer):
    def update(self, subject: Subject):
        if subject._state < 3:
            print("具体观察者A：对主题状态变化做出反应")

# 具体观察者B
class ConcreteObserverB(Observer):
    def update(self, subject: Subject):
        if subject._state == 0 or subject._state >= 2:
            print("具体观察者B：对主题状态变化做出反应")

# 使用
subject = ConcreteSubject()

observer_a = ConcreteObserverA()
subject.attach(observer_a)

observer_b = ConcreteObserverB()
subject.attach(observer_b)

subject.some_business_logic()
subject.some_business_logic()

subject.detach(observer_a)

subject.some_business_logic()
```

#### 7.3.2 策略模式

```python
from abc import ABC, abstractmethod

# 策略接口
class Strategy(ABC):
    @abstractmethod
    def do_algorithm(self, data):
        pass

# 具体策略A
class ConcreteStrategyA(Strategy):
    def do_algorithm(self, data):
        return sorted(data)

# 具体策略B
class ConcreteStrategyB(Strategy):
    def do_algorithm(self, data):
        return reversed(sorted(data))

# 上下文
class Context:
    def __init__(self, strategy: Strategy):
        self._strategy = strategy
    
    @property
    def strategy(self):
        return self._strategy
    
    @strategy.setter
    def strategy(self, strategy: Strategy):
        self._strategy = strategy
    
    def do_some_business_logic(self, data):
        result = self._strategy.do_algorithm(data)
        print(f"上下文：使用策略处理数据：{','.join(result)}")

# 使用
context = Context(ConcreteStrategyA())
data = ["a", "b", "c", "d", "e"]
print("客户端：使用策略A")
context.do_some_business_logic(data)

print("\n客户端：使用策略B")
context.strategy = ConcreteStrategyB()
context.do_some_business_logic(data)
```

## 八、总结

本章深入介绍了面向对象编程的进阶知识，包括：

1. **继承的深入理解**：继承链、MRO、super()函数、菱形继承问题
2. **方法重写与重载**：方法重写实现多态、Python中的方法重载实现
3. **抽象类与接口**：使用abc模块创建抽象类和接口
4. **特殊方法**：表示方法、容器方法、迭代方法、比较方法、数值转换方法
5. **类的高级特性**：类属性与实例属性、类方法与静态方法、类装饰器、元类
6. **面向对象设计原则**：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则
7. **设计模式应用**：创建型模式、结构型模式、行为型模式

通过本章的学习，你应该已经掌握了面向对象编程的高级概念和设计原则，能够设计和实现更加复杂、可维护、可扩展的面向对象系统。这些知识将为你在Python进阶学习和实际项目开发中打下坚实的基础。

## 九、练习

1. 实现一个抽象类`Animal`，包含抽象方法`make_sound`和`move`，然后创建至少3个具体子类实现这些方法。
2. 实现一个`Vector3D`类，支持三维向量的加法、减法、点积、叉积和标量乘法。
3. 使用装饰器模式实现一个日志记录器，可以记录函数调用的参数和返回值。
4. 使用观察者模式实现一个简单的事件系统，支持事件的订阅和发布。
5. 实现一个工厂方法模式，用于创建不同类型的交通工具（汽车、飞机、船等）。
6. 使用策略模式实现一个排序算法库，支持冒泡排序、快速排序和归并排序。
7. 实现一个自定义容器类，支持迭代、切片和上下文管理（with语句）。
8. 设计一个符合依赖倒置原则的文件系统访问器，支持不同类型的文件系统（本地文件系统、网络文件系统等）。

## 十、参考资料

1. Python官方文档：https://docs.python.org/zh-cn/3/tutorial/classes.html
2. 《流畅的Python》（Luciano Ramalho）
3. 《Python Cookbook》（David Beazley）
4. 《设计模式：可复用面向对象软件的基础》（Erich Gamma等）
5. 《Head First设计模式》（Eric Freeman等）
6. 《Clean Code》（Robert C. Martin）