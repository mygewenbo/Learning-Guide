# 迭代器与生成器

## 一、迭代器概述

### 1.1 什么是迭代器

迭代器（Iterator）是Python中用于遍历可迭代对象的对象，它提供了一种统一的方式来访问容器中的元素，而不需要暴露容器的内部结构。

迭代器的主要特点是：
- 只能向前遍历，不能向后移动
- 只能遍历一次，遍历结束后需要重新创建迭代器
- 惰性计算，只在需要时才生成下一个元素，节省内存

### 1.2 可迭代对象与迭代器

在Python中，可迭代对象（Iterable）是指实现了`__iter__()`方法的对象，而迭代器（Iterator）是指同时实现了`__iter__()`和`__next__()`方法的对象。

- **可迭代对象**：列表、元组、字符串、字典、集合、文件对象等
- **迭代器**：通过`iter()`函数从可迭代对象获取的对象

**示例**：

```python
# 可迭代对象
my_list = [1, 2, 3, 4, 5]

# 获取迭代器
my_iterator = iter(my_list)

# 检查类型
print(f"my_list是否是可迭代对象：{hasattr(my_list, '__iter__')}")  # True
print(f"my_list是否是迭代器：{hasattr(my_list, '__next__')}")  # False
print(f"my_iterator是否是可迭代对象：{hasattr(my_iterator, '__iter__')}")  # True
print(f"my_iterator是否是迭代器：{hasattr(my_iterator, '__next__')}")  # True
```

### 1.3 迭代器的使用

可以使用`next()`函数或`for`循环来遍历迭代器。

**示例**：

```python
# 使用next()函数遍历迭代器
my_list = [1, 2, 3]
my_iterator = iter(my_list)

print(next(my_iterator))  # 1
print(next(my_iterator))  # 2
print(next(my_iterator))  # 3
# print(next(my_iterator))  # StopIteration异常

# 使用for循环遍历迭代器
my_list = [4, 5, 6]
for item in my_list:
    print(item)
# 输出：4 5 6

# for循环内部会自动处理StopIteration异常
```

## 二、迭代器协议

### 2.1 迭代器协议的定义

迭代器协议是指迭代器必须实现的两个方法：

1. `__iter__()`：返回迭代器对象本身，用于支持`for`循环
2. `__next__()`：返回容器中的下一个元素，如果没有更多元素，则抛出`StopIteration`异常

### 2.2 自定义迭代器

可以通过实现`__iter__()`和`__next__()`方法来创建自定义迭代器。

**示例**：

```python
class MyIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end
    
    def __iter__(self):
        """返回迭代器对象本身"""
        return self
    
    def __next__(self):
        """返回下一个元素"""
        if self.current > self.end:
            raise StopIteration
        else:
            current_value = self.current
            self.current += 1
            return current_value

# 使用自定义迭代器
my_iter = MyIterator(1, 5)

# 使用next()函数遍历
print(next(my_iter))  # 1
print(next(my_iter))  # 2

# 使用for循环遍历剩余元素
for item in my_iter:
    print(item)  # 3 4 5

# 重新创建迭代器
my_iter2 = MyIterator(6, 10)
for item in my_iter2:
    print(item)  # 6 7 8 9 10
```

### 2.3 斐波那契数列迭代器

**示例**：

```python
class FibonacciIterator:
    def __init__(self, max_num):
        self.max_num = max_num
        self.a, self.b = 0, 1
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.a > self.max_num:
            raise StopIteration
        else:
            current = self.a
            self.a, self.b = self.b, self.a + self.b
            return current

# 使用斐波那契迭代器
fib_iter = FibonacciIterator(50)
for num in fib_iter:
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

## 三、内置迭代器

Python提供了许多内置的迭代器，方便我们使用。

### 3.1 序列迭代器

列表、元组、字符串等序列类型都可以通过`iter()`函数获取迭代器。

**示例**：

```python
# 列表迭代器
my_list = [1, 2, 3]
list_iter = iter(my_list)

# 元组迭代器
my_tuple = (4, 5, 6)
tuple_iter = iter(my_tuple)

# 字符串迭代器
my_str = "hello"
str_iter = iter(my_str)

# 遍历字符串迭代器
for char in str_iter:
    print(char, end=" ")  # h e l l o
```

### 3.2 字典迭代器

字典的迭代器默认迭代键，可以通过`keys()`、`values()`和`items()`方法获取不同的迭代器。

**示例**：

```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# 默认迭代键
print("迭代键：")
for key in my_dict:
    print(key, end=" ")  # name age city

# 迭代键
print("\n迭代键：")
for key in my_dict.keys():
    print(key, end=" ")  # name age city

# 迭代值
print("\n迭代值：")
for value in my_dict.values():
    print(value, end=" ")  # Alice 25 New York

# 迭代键值对
print("\n迭代键值对：")
for item in my_dict.items():
    print(item, end=" ")  # ('name', 'Alice') ('age', 25) ('city', 'New York')
```

### 3.3 文件迭代器

文件对象是可迭代的，可以直接用于`for`循环遍历文件内容。

**示例**：

```python
# 创建测试文件
with open("test.txt", "w") as f:
    f.write("Line 1\nLine 2\nLine 3")

# 遍历文件内容
print("遍历文件内容：")
with open("test.txt", "r") as f:
    for line in f:
        print(line.strip())  # Line 1 Line 2 Line 3
```

### 3.4 其他内置迭代器

- `enumerate()`：返回索引和值的迭代器
- `zip()`：将多个可迭代对象打包成元组的迭代器
- `map()`：对可迭代对象的每个元素应用函数
- `filter()`：过滤可迭代对象的元素
- `reversed()`：反转可迭代对象
- `sorted()`：返回排序后的列表

**示例**：

```python
# enumerate()
my_list = ["a", "b", "c"]
for index, value in enumerate(my_list):
    print(f"索引：{index}, 值：{value}")
# 输出：
# 索引：0, 值：a
# 索引：1, 值：b
# 索引：2, 值：c

# zip()
names = ["Alice", "Bob", "Charlie"]
age = [25, 30, 35]
for name, age in zip(names, age):
    print(f"姓名：{name}, 年龄：{age}")
# 输出：
# 姓名：Alice, 年龄：25
# 姓名：Bob, 年龄：30
# 姓名：Charlie, 年龄：35

# map()
numbers = [1, 2, 3, 4, 5]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # [1, 4, 9, 16, 25]

# filter()
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # [2, 4]

# reversed()
reversed_list = reversed(numbers)
print(list(reversed_list))  # [5, 4, 3, 2, 1]

# sorted()
random_numbers = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_numbers = sorted(random_numbers)
print(sorted_numbers)  # [1, 1, 2, 3, 4, 5, 6, 9]
```

## 四、生成器概述

### 4.1 什么是生成器

生成器（Generator）是一种特殊的迭代器，它不需要显式实现`__iter__()`和`__next__()`方法，而是通过`yield`关键字来自动实现迭代器协议。

生成器的主要优势：
- **惰性计算**：只在需要时才生成下一个元素，节省内存
- **简化代码**：比自定义迭代器类更简洁
- **支持暂停和恢复**：可以在执行过程中暂停，保存当前状态，然后恢复执行

### 4.2 生成器的类型

Python中有两种类型的生成器：
- **生成器函数**：使用`yield`关键字定义的函数
- **生成器表达式**：类似于列表推导式的生成器创建方式

## 五、生成器函数

### 5.1 生成器函数的定义

生成器函数使用`def`关键字定义，与普通函数的区别是使用`yield`关键字而不是`return`关键字返回值。

**示例**：

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

# 调用生成器函数，返回生成器对象
gen = simple_generator()

# 遍历生成器
print("遍历生成器：")
for item in gen:
    print(item)  # 1 2 3

# 重新创建生成器
gen2 = simple_generator()
print(next(gen2))  # 1
print(next(gen2))  # 2
print(next(gen2))  # 3
# print(next(gen2))  # StopIteration异常
```

### 5.2 生成器函数的工作原理

生成器函数的执行过程：
1. 调用生成器函数时，不会立即执行函数体，而是返回一个生成器对象
2. 当调用`next()`函数或使用`for`循环遍历生成器时，函数体开始执行
3. 当遇到`yield`关键字时，函数暂停执行，返回`yield`后面的值
4. 当再次调用`next()`函数时，函数从上次暂停的位置继续执行
5. 当函数执行完毕或遇到`return`语句时，抛出`StopIteration`异常

**示例**：

```python
def generator_with_state():
    print("开始执行生成器")
    yield "第一个值"
    print("继续执行生成器")
    yield "第二个值"
    print("生成器执行完毕")

# 调用生成器函数
gen = generator_with_state()

print("获取第一个值：")
print(next(gen))

print("\n获取第二个值：")
print(next(gen))

print("\n尝试获取第三个值：")
try:
    next(gen)
except StopIteration:
    print("生成器已结束")
```

### 5.3 斐波那契数列生成器

**示例**：

```python
def fibonacci_generator(max_num):
    """生成斐波那契数列的生成器函数"""
    a, b = 0, 1
    while a <= max_num:
        yield a
        a, b = b, a + b

# 使用生成器
print("斐波那契数列（小于等于50）：")
for num in fibonacci_generator(50):
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

### 5.4 生成器函数的参数

生成器函数可以接收参数，用于控制生成器的行为。

**示例**：

```python
def range_generator(start, end, step=1):
    """自定义range生成器"""
    current = start
    while current < end:
        yield current
        current += step

# 使用生成器
print("自定义range生成器（1到10，步长2）：")
for num in range_generator(1, 10, 2):
    print(num, end=" ")  # 1 3 5 7 9
```

## 六、yield关键字

### 6.1 yield的基本用法

`yield`关键字用于生成器函数中，用于返回值并暂停函数执行。

**示例**：

```python
def count_down(n):
    """倒计时生成器"""
    while n > 0:
        yield n
        n -= 1

print("倒计时：")
for num in count_down(5):
    print(num, end=" ")  # 5 4 3 2 1
```

### 6.2 yield与return的区别

| 特性 | yield | return |
|------|-------|--------|
| 功能 | 返回值并暂停函数执行 | 返回值并结束函数执行 |
| 调用次数 | 可以多次调用，每次返回不同值 | 只能调用一次，函数结束 |
| 返回类型 | 生成器对象 | 具体值 |
| 内存使用 | 惰性计算，节省内存 | 立即计算，占用内存 |

### 6.3 send()方法

`send()`方法用于向生成器发送值，并恢复生成器执行。

**示例**：

```python
def echo_generator():
    """回显生成器，可以接收外部输入"""
    while True:
        received = yield
        if received is None:
            break
        yield f"你输入了：{received}"

# 使用生成器
gen = echo_generator()

# 启动生成器
next(gen)

# 发送值
print(gen.send("hello"))  # 你输入了：hello
next(gen)  # 恢复执行
print(gen.send("world"))  # 你输入了：world

# 关闭生成器
gen.close()
```

### 6.4 throw()方法

`throw()`方法用于向生成器抛出异常。

**示例**：

```python
def error_generator():
    """处理异常的生成器"""
    try:
        yield 1
        yield 2
        yield 3
    except ValueError as e:
        print(f"捕获到值错误：{e}")
        yield "从异常中恢复"
    yield 4

# 使用生成器
gen = error_generator()

print(next(gen))  # 1
print(next(gen))  # 2

# 抛出异常
gen.throw(ValueError, "自定义值错误")

print(next(gen))  # 从异常中恢复
print(next(gen))  # 4
```

### 6.5 close()方法

`close()`方法用于关闭生成器，触发`GeneratorExit`异常。

**示例**：

```python
def generator_with_cleanup():
    """带有清理代码的生成器"""
    try:
        yield 1
        yield 2
        yield 3
    except GeneratorExit:
        print("生成器被关闭，执行清理操作")
        raise

# 使用生成器
gen = generator_with_cleanup()

print(next(gen))  # 1
print(next(gen))  # 2

# 关闭生成器
gen.close()
```

## 七、生成器表达式

### 7.1 生成器表达式的语法

生成器表达式的语法与列表推导式类似，只是将方括号`[]`替换为圆括号`()`。

**语法**：

```python
(expression for item in iterable if condition)
```

**示例**：

```python
# 列表推导式
list_comp = [x ** 2 for x in range(5)]
print(f"列表推导式：{list_comp}")  # [0, 1, 4, 9, 16]

# 生成器表达式
gen_exp = (x ** 2 for x in range(5))
print(f"生成器表达式：{gen_exp}")  # <generator object <genexpr> at 0x...>

# 遍历生成器表达式
print("遍历生成器表达式：")
for item in gen_exp:
    print(item)  # 0 1 4 9 16
```

### 7.2 生成器表达式与列表推导式的区别

| 特性 | 生成器表达式 | 列表推导式 |
|------|--------------|------------|
| 语法 | 圆括号 `()` | 方括号 `[]` |
| 返回类型 | 生成器对象 | 列表 |
| 内存使用 | 惰性计算，只在需要时生成元素，节省内存 | 立即计算所有元素，占用内存 |
| 遍历方式 | 只能遍历一次 | 可以多次遍历 |
| 适用场景 | 处理大量数据或无限序列 | 处理少量数据 |

### 7.3 生成器表达式的应用

**示例**：

```python
# 处理大量数据
print("处理大量数据：")
large_gen = (x for x in range(1000000) if x % 2 == 0)
print(f"生成器表达式创建成功，占用内存少")
print(f"前5个偶数：{[next(large_gen) for _ in range(5)]}")  # [0, 2, 4, 6, 8]

# 嵌套生成器表达式
print("\n嵌套生成器表达式：")
nested_gen = ((i, j) for i in range(2) for j in range(3))
for item in nested_gen:
    print(item, end=" ")  # (0, 0) (0, 1) (0, 2) (1, 0) (1, 1) (1, 2)

# 与内置函数结合使用
print("\n\n与sum()函数结合：")
sum_result = sum(x ** 2 for x in range(10))
print(f"1到9的平方和：{sum_result}")  # 285

print("\n与max()函数结合：")
max_result = max(x for x in range(10) if x % 3 == 0)
print(f"1到9中能被3整除的最大值：{max_result}")  # 9
```

## 八、迭代器与生成器的应用场景

### 8.1 处理大量数据

当处理大量数据时，使用迭代器或生成器可以节省内存，因为它们是惰性计算的，只在需要时才生成元素。

**示例**：

```python
def read_large_file(file_path):
    """逐行读取大文件"""
    with open(file_path, "r") as f:
        for line in f:
            yield line.strip()

# 使用
# for line in read_large_file("large_file.txt"):
#     process_line(line)
```

### 8.2 生成无限序列

迭代器和生成器可以用于生成无限序列，因为它们不需要预先存储所有元素。

**示例**：

```python
def infinite_counter(start=0):
    """无限计数器生成器"""
    current = start
    while True:
        yield current
        current += 1

# 使用
counter = infinite_counter(1)
print("无限计数器的前5个值：")
for _ in range(5):
    print(next(counter), end=" ")  # 1 2 3 4 5

# 斐波那契无限序列
def infinite_fibonacci():
    """无限斐波那契数列生成器"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = infinite_fibonacci()
print("\n\n无限斐波那契数列的前10个值：")
for _ in range(10):
    print(next(fib), end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

### 8.3 流水线处理

迭代器和生成器可以用于创建数据处理流水线，每个步骤处理一部分数据，然后传递给下一个步骤。

**示例**：

```python
def generate_data(n):
    """生成数据"""
    for i in range(n):
        yield i

def filter_data(data):
    """过滤数据"""
    for item in data:
        if item % 2 == 0:
            yield item

def process_data(data):
    """处理数据"""
    for item in data:
        yield item * item

# 创建数据处理流水线
print("数据处理流水线：")
data = generate_data(10)
filtered = filter_data(data)
processed = process_data(filtered)

# 遍历结果
for item in processed:
    print(item, end=" ")  # 0 4 16 36 64
```

### 8.4 异步编程

在Python的异步编程中，生成器被广泛用于实现协程，是异步编程的基础。

**示例**：

```python
# 简单的协程示例
def coroutine_example():
    while True:
        received = yield
        print(f"协程收到：{received}")

# 使用协程
coro = coroutine_example()
next(coro)  # 启动协程
coro.send("第一条消息")  # 协程收到：第一条消息
coro.send("第二条消息")  # 协程收到：第二条消息
coro.close()
```

## 九、最佳实践

### 9.1 优先使用生成器表达式

对于简单的生成器，优先使用生成器表达式，因为它们更简洁易读。

**示例**：

```python
# 好的做法：使用生成器表达式
gen_exp = (x for x in range(10) if x % 2 == 0)

# 不好的做法：使用生成器函数
def even_generator():
    for x in range(10):
        if x % 2 == 0:
            yield x
```

### 9.2 避免在生成器中修改外部状态

生成器应该是纯函数，避免修改外部状态，这样可以提高生成器的可测试性和可维护性。

**示例**：

```python
# 不好的做法：修改外部状态
count = 0
def bad_generator():
    global count
    while count < 5:
        count += 1
        yield count

# 好的做法：使用内部状态
def good_generator():
    count = 0
    while count < 5:
        count += 1
        yield count
```

### 9.3 正确处理生成器的关闭

当不再使用生成器时，应该调用`close()`方法关闭生成器，以便执行清理操作。

**示例**：

```python
def generator_with_resources():
    """使用资源的生成器"""
    resource = "打开的资源"
    print(f"获取资源：{resource}")
    try:
        yield 1
        yield 2
    finally:
        print(f"释放资源：{resource}")

# 好的做法：使用with语句或手动关闭
gen = generator_with_resources()
try:
    print(next(gen))
    print(next(gen))
finally:
    gen.close()
```

### 9.4 避免在生成器中使用return语句

虽然Python允许在生成器中使用`return`语句，但它会立即终止生成器并抛出`StopIteration`异常，可能会导致意外行为。

**示例**：

```python
def generator_with_return():
    yield 1
    return "结束"
    yield 2  # 永远不会执行

gen = generator_with_return()
print(next(gen))  # 1
try:
    next(gen)
except StopIteration as e:
    print(f"生成器结束，返回值：{e.value}")  # 生成器结束，返回值：结束
```

## 十、总结

本章介绍了Python迭代器与生成器的相关知识，包括：

1. **迭代器概述**：什么是迭代器、可迭代对象与迭代器的区别
2. **迭代器协议**：`__iter__()`和`__next__()`方法
3. **自定义迭代器**：创建自定义迭代器类
4. **内置迭代器**：Python内置的迭代器
5. **生成器概述**：生成器的定义和优势
6. **生成器函数**：使用`yield`关键字定义生成器函数
7. **生成器表达式**：类似于列表推导式的生成器创建方式
8. **yield关键字**：`yield`的工作原理、`send()`、`throw()`、`close()`方法
9. **迭代器与生成器的应用场景**：处理大量数据、生成无限序列、流水线处理、异步编程
10. **最佳实践**：优先使用生成器表达式、避免修改外部状态、正确处理生成器的关闭、避免使用return语句

通过本章的学习，你应该已经掌握了Python迭代器与生成器的基本概念和使用方法，能够编写自定义迭代器和生成器，熟练使用生成器函数和生成器表达式，并了解它们的应用场景和最佳实践。迭代器与生成器是Python中的重要特性，它们可以帮助你编写更高效、更简洁的代码，特别是在处理大量数据或无限序列时。

## 十一、练习

1. 编写一个自定义迭代器，生成1到100之间的所有质数。
2. 编写一个生成器函数，生成指定范围内的斐波那契数列。
3. 使用生成器表达式生成1到100之间的所有偶数的平方。
4. 编写一个生成器函数，模拟倒计时，从指定数字倒数到0。
5. 使用生成器表达式和内置函数计算1到100之间所有奇数的和。
6. 编写一个生成器函数，读取文件内容，并返回每行的单词数。
7. 编写一个生成器函数，实现分页功能，每次返回指定数量的元素。
8. 使用生成器创建一个数据处理流水线，包括数据生成、过滤和处理步骤。

## 十二、参考资料

1. Python官方文档：https://docs.python.org/zh-cn/3/tutorial/classes.html#iterators
2. Python官方文档：https://docs.python.org/zh-cn/3/tutorial/classes.html#generators
3. 《流畅的Python》（Luciano Ramalho）
4. 《Python Cookbook》（David Beazley）
5. 《Effective Python》（Brett Slatkin）
6. Python生成器文档：https://docs.python.org/zh-cn/3/reference/expressions.html#yield-expressions