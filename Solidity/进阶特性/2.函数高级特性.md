# 函数高级特性

## 一、函数修饰符（Modifiers）

### 1.1 修饰符定义和使用
- 修饰符用于修改函数的行为
- 可以在函数执行前或执行后添加逻辑
- 用于实现代码复用和权限控制
- 示例：
  ```solidity
  // 定义修饰符
  modifier onlyOwner() {
      require(msg.sender == owner, "Not authorized");
      _; // 执行函数体
  }
  
  modifier validAmount(uint256 amount) {
      require(amount > 0, "Amount must be greater than zero");
      _; // 执行函数体
  }
  
  contract ModifierExample {
      address public owner;
      
      constructor() {
          owner = msg.sender;
      }
      
      // 使用修饰符
      function restrictedFunction() public onlyOwner {
          // 只有合约所有者可以调用
      }
      
      // 使用多个修饰符
      function transfer(address to, uint256 amount) public onlyOwner validAmount(amount) {
          // 只有所有者可以调用，且金额必须大于0
      }
  }
  ```

### 1.2 修饰符的执行顺序
- 修饰符按照声明顺序执行
- 函数体在所有修饰符的`_;`位置执行
- 示例：
  ```solidity
  modifier first() {
      // 第一个执行
      _;
      // 最后执行
  }
  
  modifier second() {
      // 第二个执行
      _;
      // 倒数第二个执行
  }
  
  function example() public first second {
      // 中间执行
  }
  ```

### 1.3 带参数的修饰符
- 修饰符可以接受参数
- 用于动态验证
- 示例：
  ```solidity
  modifier minAmount(uint256 requiredAmount) {
      require(msg.value >= requiredAmount, "Insufficient amount");
      _;
  }
  
  function deposit() public payable minAmount(1 ether) {
      // 只有发送至少1 ether才能调用
  }
  
  modifier validAddress(address addr) {
      require(addr != address(0), "Invalid address");
      _;
  }
  
  function transfer(address to, uint256 amount) public validAddress(to) {
      // 目标地址不能是零地址
  }
  ```

### 1.4 修饰符的继承
- 修饰符可以被继承
- 可以在子类中重写
- 示例：
  ```solidity
  contract Parent {
      modifier onlyParentOwner() {
          require(msg.sender == owner, "Not parent owner");
          _;
      }
  }
  
  contract Child is Parent {
      modifier onlyParentOwner() {
          // 扩展父类修饰符
          super.onlyParentOwner();
          require(someAdditionalCondition, "Additional condition failed");
          _;
      }
      
      function childFunction() public onlyParentOwner {
          // 执行逻辑
      }
  }
  ```

## 二、视图函数和纯函数

### 2.1 视图函数（View Functions）
- 不修改合约状态
- 使用`view`修饰符
- 可以读取状态变量
- 示例：
  ```solidity
  contract ViewExample {
      uint256 public value;
      
      function getValue() public view returns (uint256) {
          return value;
      }
      
      function calculateSum(uint256 a, uint256 b) public view returns (uint256) {
          return a + b + value;
      }
  }
  ```

### 2.2 纯函数（Pure Functions）
- 不读取也不修改合约状态
- 使用`pure`修饰符
- 只依赖于输入参数
- 示例：
  ```solidity
  contract PureExample {
      function add(uint256 a, uint256 b) public pure returns (uint256) {
          return a + b;
      }
      
      function multiply(uint256 a, uint256 b) public pure returns (uint256) {
          return a * b;
      }
      
      function concatenate(string memory a, string memory b) public pure returns (string memory) {
          return string(abi.encodePacked(a, b));
      }
  }
  ```

### 2.3 视图函数和纯函数的调用
- 可以通过外部调用或内部调用
- 外部调用不消耗gas（除了调用本身的gas）
- 内部调用消耗gas（如果包含复杂计算）
- 示例：
  ```solidity
  contract CallExample {
      uint256 public value = 100;
      
      function getValue() public view returns (uint256) {
          return value;
      }
      
      function add(uint256 a, uint256 b) public pure returns (uint256) {
          return a + b;
      }
      
      function callViewFunction() public view returns (uint256) {
          // 内部调用视图函数
          return getValue();
      }
      
      function callPureFunction() public pure returns (uint256) {
          // 内部调用纯函数
          return add(10, 20);
      }
  }
  ```

## 三、构造函数和析构函数

### 3.1 构造函数
- 合约部署时执行一次
- 用于初始化合约状态
- 可以接受参数
- 示例：
  ```solidity
  contract ConstructorExample {
      address public owner;
      uint256 public initialValue;
      string public name;
      
      // 构造函数
      constructor(uint256 _initialValue, string memory _name) {
          owner = msg.sender;
          initialValue = _initialValue;
          name = _name;
      }
      
      // 带修饰符的构造函数
      constructor() {
          owner = msg.sender;
      }
  }
  ```

### 3.2 析构函数
- 使用`selfdestruct`函数
- 用于销毁合约并将剩余以太币发送到指定地址
- 示例：
  ```solidity
  contract Destructible {
      address public owner;
      
      constructor() {
          owner = msg.sender;
      }
      
      modifier onlyOwner() {
          require(msg.sender == owner, "Not owner");
          _;
      }
      
      function destroy() public onlyOwner {
          // 销毁合约，将剩余以太币发送到owner地址
          selfdestruct(payable(owner));
      }
      
      function destroyAndSend(address payable recipient) public onlyOwner {
          // 销毁合约，将剩余以太币发送到指定地址
          selfdestruct(recipient);
      }
  }
  ```

### 3.3 不可变变量和常量

#### 3.3.1 常量（Constants）
- 使用`constant`关键字
- 必须在声明时初始化
- 不能修改
- 存储在字节码中，不占用存储槽
- 示例：
  ```solidity
  contract ConstantsExample {
      // 数值常量
      uint256 public constant MAX_VALUE = 1000;
      // 字符串常量
      string public constant CONTRACT_NAME = "MyContract";
      // 地址常量
      address public constant ADMIN_ADDRESS = 0x1234567890123456789012345678901234567890;
  }
  ```

#### 3.3.2 不可变变量（Immutables）
- 使用`immutable`关键字
- 可以在构造函数中初始化
- 不能修改
- 存储在字节码中，不占用存储槽
- 示例：
  ```solidity
  contract ImmutableExample {
      // 不可变变量
      address public immutable owner;
      uint256 public immutable deploymentTime;
      
      constructor() {
          owner = msg.sender;
          deploymentTime = block.timestamp;
      }
  }
  ```

## 四、回退函数和接收函数

### 4.1 回退函数（Fallback Function）
- 处理未匹配到函数签名的调用
- 处理直接向合约发送以太币但没有调用接收函数的情况
- 必须使用`external`修饰符
- 可以使用`payable`修饰符
- 示例：
  ```solidity
  contract FallbackExample {
      event FallbackCalled(address sender, uint256 value, bytes data);
      
      // 回退函数
      fallback() external payable {
          emit FallbackCalled(msg.sender, msg.value, msg.data);
      }
  }
  ```

### 4.2 接收函数（Receive Function）
- 处理直接向合约发送以太币的情况
- 是回退函数的一种特殊形式
- 不能有参数
- 不能有返回值
- 必须使用`external payable`修饰符
- 示例：
  ```solidity
  contract ReceiveExample {
      event ReceiveCalled(address sender, uint256 value);
      
      // 接收函数
      receive() external payable {
          emit ReceiveCalled(msg.sender, msg.value);
      }
  }
  ```

### 4.3 回退函数和接收函数的区别
| 特性 | 接收函数 | 回退函数 |
|------|----------|----------|
| 函数签名 | `receive() external payable` | `fallback() external [payable]` |
| 用途 | 处理直接转账 | 处理未匹配的函数调用和带数据的转账 |
| 参数 | 无 | 无（但可以访问`msg.data`） |
| 返回值 | 无 | 无 |
| 优先级 | 更高（直接转账时优先调用） | 更低（接收函数不存在时调用） |

### 4.4 示例：同时使用接收函数和回退函数
```solidity
contract FallbackAndReceiveExample {
    event ReceiveCalled(address sender, uint256 value);
    event FallbackCalled(address sender, uint256 value, bytes data);
    
    // 接收函数：处理直接转账
    receive() external payable {
        emit ReceiveCalled(msg.sender, msg.value);
    }
    
    // 回退函数：处理未匹配的函数调用和带数据的转账
    fallback() external payable {
        emit FallbackCalled(msg.sender, msg.value, msg.data);
    }
}
```

## 五、函数重载

### 5.1 函数重载定义
- 允许定义同名但参数不同的函数
- 参数数量或类型必须不同
- 返回类型不同不足以重载
- 示例：
  ```solidity
  contract OverloadExample {
      // 函数重载：参数数量不同
      function add(uint256 a, uint256 b) public pure returns (uint256) {
          return a + b;
      }
      
      function add(uint256 a, uint256 b, uint256 c) public pure returns (uint256) {
          return a + b + c;
      }
      
      // 函数重载：参数类型不同
      function process(uint256 value) public pure returns (string memory) {
          return string(abi.encodePacked("Processing uint: ", uint2str(value)));
      }
      
      function process(string memory value) public pure returns (string memory) {
          return string(abi.encodePacked("Processing string: ", value));
      }
      
      // 辅助函数：将uint转换为string
      function uint2str(uint256 _i) internal pure returns (string memory) {
          if (_i == 0) {
              return "0";
          }
          uint256 j = _i;
          uint256 length;
          while (j != 0) {
              length++;
              j /= 10;
          }
          bytes memory bstr = new bytes(length);
          uint256 k = length;
          while (_i != 0) {
              bstr[--k] = bytes1(uint8(48 + _i % 10));
              _i /= 10;
          }
          return string(bstr);
      }
  }
  ```

### 5.2 函数重载的解析
- Solidity编译器根据参数类型和数量选择匹配的函数
- 如果没有完全匹配的函数，编译器会尝试隐式转换
- 如果有多个可能的匹配，会导致编译错误
- 示例：
  ```solidity
  function testOverload() public pure returns (uint256, string memory) {
      uint256 sum2 = add(1, 2); // 调用add(uint256, uint256)
      uint256 sum3 = add(1, 2, 3); // 调用add(uint256, uint256, uint256)
      
      string memory result1 = process(123); // 调用process(uint256)
      string memory result2 = process("hello"); // 调用process(string)
      
      return (sum2 + sum3, string(abi.encodePacked(result1, ", ", result2)));
  }
  ```

## 六、实践项目：权限管理系统

### 6.1 项目概述
- 实现一个灵活的权限管理系统
- 支持角色创建和分配
- 支持权限检查和验证
- 使用修饰符实现权限控制

### 6.2 合约代码
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControl {
    // 事件
    event RoleCreated(bytes32 role);
    event RoleGranted(bytes32 role, address account);
    event RoleRevoked(bytes32 role, address account);
    event PermissionGranted(bytes32 role, bytes32 permission);
    event PermissionRevoked(bytes32 role, bytes32 permission);
    
    // 状态变量
    address public owner;
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    
    // 角色到权限的映射
    mapping(bytes32 => mapping(bytes32 => bool)) public rolePermissions;
    
    // 账户到角色的映射
    mapping(address => mapping(bytes32 => bool)) public accountRoles;
    
    // 所有角色
    bytes32[] public allRoles;
    
    // 修饰符
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    modifier onlyAdmin() {
        require(hasRole(msg.sender, ADMIN_ROLE), "Not admin");
        _;
    }
    
    modifier hasPermission(bytes32 permission) {
        require(hasAccess(msg.sender, permission), "Insufficient permissions");
        _;
    }
    
    // 构造函数
    constructor() {
        owner = msg.sender;
        
        // 创建管理员角色
        _createRole(ADMIN_ROLE);
        
        // 给所有者分配管理员角色
        _grantRole(ADMIN_ROLE, owner);
    }
    
    // 创建角色
    function createRole(bytes32 role) public onlyOwner {
        _createRole(role);
    }
    
    // 内部创建角色
    function _createRole(bytes32 role) internal {
        require(!rolePermissions[role]["EXISTS"], "Role already exists");
        rolePermissions[role]["EXISTS"] = true;
        allRoles.push(role);
        emit RoleCreated(role);
    }
    
    // 分配角色
    function grantRole(bytes32 role, address account) public onlyAdmin {
        _grantRole(role, account);
    }
    
    // 内部分配角色
    function _grantRole(bytes32 role, address account) internal {
        require(rolePermissions[role]["EXISTS"], "Role does not exist");
        require(!accountRoles[account][role], "Account already has role");
        accountRoles[account][role] = true;
        emit RoleGranted(role, account);
    }
    
    // 撤销角色
    function revokeRole(bytes32 role, address account) public onlyAdmin {
        require(accountRoles[account][role], "Account does not have role");
        accountRoles[account][role] = false;
        emit RoleRevoked(role, account);
    }
    
    // 检查账户是否有角色
    function hasRole(address account, bytes32 role) public view returns (bool) {
        return accountRoles[account][role];
    }
    
    // 授予权限
    function grantPermission(bytes32 role, bytes32 permission) public onlyAdmin {
        require(rolePermissions[role]["EXISTS"], "Role does not exist");
        rolePermissions[role][permission] = true;
        emit PermissionGranted(role, permission);
    }
    
    // 撤销权限
    function revokePermission(bytes32 role, bytes32 permission) public onlyAdmin {
        require(rolePermissions[role][permission], "Permission does not exist");
        rolePermissions[role][permission] = false;
        emit PermissionRevoked(role, permission);
    }
    
    // 检查角色是否有权限
    function roleHasPermission(bytes32 role, bytes32 permission) public view returns (bool) {
        return rolePermissions[role][permission];
    }
    
    // 检查账户是否有访问权限
    function hasAccess(address account, bytes32 permission) public view returns (bool) {
        // 管理员角色拥有所有权限
        if (accountRoles[account][ADMIN_ROLE]) {
            return true;
        }
        
        // 检查账户的所有角色是否有该权限
        for (uint256 i = 0; i < allRoles.length; i++) {
            bytes32 role = allRoles[i];
            if (accountRoles[account][role] && rolePermissions[role][permission]) {
                return true;
            }
        }
        
        return false;
    }
    
    // 示例：受保护的函数
    function restrictedFunction() public hasPermission(keccak256("RESTRICTED_FUNCTION")) {
        // 只有拥有RESTRICTED_FUNCTION权限的账户才能调用
    }
    
    // 示例：另一个受保护的函数
    function anotherRestrictedFunction() public hasPermission(keccak256("ANOTHER_PERMISSION")) {
        // 只有拥有ANOTHER_PERMISSION权限的账户才能调用
    }
}
```

### 6.3 部署和测试
1. 在Remix中编译合约
2. 部署合约
3. 测试角色管理：
   - 调用`createRole`函数创建新角色
   - 调用`grantRole`函数分配角色
   - 调用`revokeRole`函数撤销角色
4. 测试权限管理：
   - 调用`grantPermission`函数授予权限
   - 调用`revokePermission`函数撤销权限
5. 测试权限控制：
   - 调用`restrictedFunction`函数，验证只有拥有权限的账户才能调用
   - 调用`anotherRestrictedFunction`函数，验证权限控制

## 七、练习

1. 实现一个带有时间锁的修饰符，限制函数只能在特定时间后调用
2. 编写一个合约，使用不可变变量存储配置信息
3. 实现一个带有多级权限的访问控制系统
4. 编写一个合约，使用回退函数和接收函数处理以太币
5. 实现一个函数重载的数学库，支持不同类型和数量的参数

## 八、总结

通过本章的学习，你已经掌握了Solidity中函数的高级特性，包括：

- 修饰符：用于修改函数行为，实现代码复用和权限控制
- 视图函数和纯函数：用于只读操作，节省gas
- 构造函数和析构函数：用于合约初始化和销毁
- 不可变变量和常量：用于存储不变的值，节省gas
- 回退函数和接收函数：用于处理未匹配的调用和直接转账
- 函数重载：允许定义同名但参数不同的函数

这些高级特性可以帮助你编写更加灵活、安全和高效的智能合约，提高代码的可读性和可维护性。在下一章中，我们将学习事件和日志系统的深入知识。