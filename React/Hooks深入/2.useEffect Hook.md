# useEffect Hook 详解

## 1. 什么是 useEffect Hook？

`useEffect` 是 React 提供的一个内置 Hook，用于在函数组件中处理副作用操作。副作用是指那些不直接属于组件渲染过程的操作，如数据获取、订阅、手动 DOM 操作、定时器设置等。

### 核心特性
- 允许函数组件执行副作用操作
- 可以模拟类组件的生命周期方法
- 支持依赖项管理，控制副作用的执行时机
- 提供清理机制，防止内存泄漏
- 遵循 React 的单向数据流原则

## 2. 语法和基本使用

### 语法结构

```javascript
import { useEffect } from 'react';

function Component() {
  useEffect(() => {
    // 副作用逻辑
    
    return () => {
      // 清理逻辑（可选）
    };
  }, [dependencies]); // 依赖项数组（可选）
  
  return <div>Component</div>;
}
```

### 参数说明

1. **副作用函数**：包含要执行的副作用逻辑的函数
2. **清理函数**：可选的返回函数，用于清理副作用（如取消订阅、清除定时器等）
3. **依赖项数组**：可选的数组，包含影响副作用执行的变量。当数组中的任何变量发生变化时，副作用函数会重新执行

### 基本示例

```javascript
import { useState, useEffect } from 'react';
import { createRoot } from 'react-dom/client';

function Counter() {
  const [count, setCount] = useState(0);
  
  // 每次渲染后执行
  useEffect(() => {
    document.title = `Count: ${count}`;
  });
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<Counter />);
```

## 3. 依赖项管理

### 1. 无依赖项数组

当不提供依赖项数组时，副作用函数会在**每次组件渲染后**执行：

```javascript
useEffect(() => {
  console.log('Component rendered');
});
```

### 2. 空依赖项数组

当提供空依赖项数组时，副作用函数只会在**组件首次渲染后**执行一次：

```javascript
useEffect(() => {
  console.log('Component mounted');
}, []);
```

### 3. 有依赖项数组

当提供包含变量的依赖项数组时，副作用函数会在**首次渲染后**执行，并且在**任何依赖项发生变化**时重新执行：

```javascript
useEffect(() => {
  console.log(`Count changed to: ${count}`);
}, [count]);
```

### 4. 多个依赖项

依赖项数组可以包含多个变量，当其中任何一个变量发生变化时，副作用函数都会重新执行：

```javascript
useEffect(() => {
  console.log(`Count: ${count}, Name: ${name}`);
}, [count, name]);
```

## 4. 清理函数

清理函数用于在组件卸载或副作用重新执行前清理副作用，防止内存泄漏：

### 基本用法

```javascript
useEffect(() => {
  // 设置副作用
  const timer = setInterval(() => {
    console.log('Timer running');
  }, 1000);
  
  // 返回清理函数
  return () => {
    // 清理副作用
    clearInterval(timer);
  };
}, []);
```

### 清理函数的执行时机

清理函数会在以下时机执行：
1. 组件卸载前
2. 副作用函数重新执行前（如果依赖项发生变化）

### 清理函数的重要性

清理函数对于防止内存泄漏至关重要，特别是在以下情况下：
- 订阅事件或外部数据源
- 设置定时器或间隔器
- 创建 WebSocket 连接
- 手动操作 DOM

## 5. 常见用例

### 1. 数据获取

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    async function fetchUser() {
      try {
        setLoading(true);
        const response = await fetch(`https://api.example.com/users/${userId}`);
        const data = await response.json();
        if (!cancelled) {
          setUser(data);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }
    
    fetchUser();
    
    return () => {
      cancelled = true;
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <div>User: {user?.name}</div>;
}
```

### 2. 订阅事件

```javascript
function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return <div>Window Size: {size.width}x{size.height}</div>;
}
```

### 3. 手动 DOM 操作

```javascript
function FocusInput() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    // 组件挂载后自动聚焦输入框
    inputRef.current.focus();
  }, []);
  
  return <input ref={inputRef} placeholder="Focused input" />;
}
```

### 4. 设置定时器

```javascript
function CountdownTimer() {
  const [count, setCount] = useState(10);
  
  useEffect(() => {
    if (count <= 0) return;
    
    const timer = setTimeout(() => {
      setCount(count - 1);
    }, 1000);
    
    return () => {
      clearTimeout(timer);
    };
  }, [count]);
  
  return <div>Countdown: {count}</div>;
}
```

## 6. 与类组件生命周期的对比

| 类组件生命周期 | useEffect 实现 |
|----------------|---------------|
| componentDidMount | useEffect(() => { /* 逻辑 */ }, []) |
| componentDidUpdate | useEffect(() => { /* 逻辑 */ }, [deps]) |
| componentWillUnmount | useEffect(() => { return () => { /* 清理逻辑 */ }; }, []) |
| componentDidMount + componentDidUpdate | useEffect(() => { /* 逻辑 */ }) |
| componentDidMount + componentWillUnmount | useEffect(() => { /* 逻辑 */; return () => { /* 清理逻辑 */ }; }, []) |

## 7. 与其他 Hooks 的配合使用

### 与 useState 配合

```javascript
function DataFetchingComponent() {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://api.example.com/data');
        const result = await response.json();
        setData(result);
        setError(null);
      } catch (err) {
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
  }, []);
  
  // ...
}
```

### 与 useRef 配合

```javascript
function Component() {
  const ref = useRef([1, 2, 3, 4, 5]);
  const [value, setValue] = useState(0);
  
  useEffect(() => {
    const index = 2;
    setValue(ref.current[index]);
  }, []);
  
  return <div>Value: {value}</div>;
}
```

### 与 useCallback 配合

```javascript
function Component() {
  const dispatch = useDispatch();
  
  const onUpdate = useCallback(() => {
    dispatch({ kind: 'update' });
  }, [dispatch]);
  
  useEffect(() => {
    onUpdate();
  }, [onUpdate]);
  
  return <div />;
}
```

## 8. 性能优化

### 1. 减少不必要的重新渲染

```javascript
// ❌ 每次渲染都会创建新的对象，导致副作用重新执行
useEffect(() => {
  // 副作用逻辑
}, [{ key: 'value' }]);

// ✅ 使用稳定的依赖项
const stableObject = useMemo(() => ({ key: 'value' }), []);
useEffect(() => {
  // 副作用逻辑
}, [stableObject]);
```

### 2. 使用 useMemo 缓存计算结果

```javascript
function Component({ data }) {
  const processedData = useMemo(() => {
    return expensiveProcessing(data);
  }, [data]);
  
  useEffect(() => {
    // 使用 processedData 执行副作用
    console.log(processedData);
  }, [processedData]);
  
  return <div />;
}
```

### 3. 使用 useCallback 缓存回调函数

```javascript
function Component() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  useEffect(() => {
    // 使用 handleClick 执行副作用
    document.addEventListener('click', handleClick);
    
    return () => {
      document.removeEventListener('click', handleClick);
    };
  }, [handleClick]);
  
  return <div>Count: {count}</div>;
}
```

### 4. 条件性执行副作用

```javascript
function Component({ shouldRunEffect }) {
  useEffect(() => {
    if (shouldRunEffect) {
      // 只有当 shouldRunEffect 为 true 时执行副作用
      console.log('Effect ran');
    }
  }, [shouldRunEffect]);
  
  return <div />;
}
```

## 9. 常见错误和最佳实践

### 常见错误

1. **忘记添加依赖项**
   ```javascript
   // ❌ 错误：使用了 count 但没有添加到依赖项
   useEffect(() => {
     document.title = `Count: ${count}`;
   }, []);
   
   // ✅ 正确：添加 count 到依赖项
   useEffect(() => {
     document.title = `Count: ${count}`;
   }, [count]);
   ```

2. **在副作用中直接修改状态**
   ```javascript
   // ❌ 错误：可能导致无限循环
   useEffect(() => {
     setCount(count + 1);
   }, [count]);
   ```

3. **在清理函数中使用过期的状态**
   ```javascript
   // ❌ 错误：清理函数中使用的 count 可能是过期的
   useEffect(() => {
     const timer = setInterval(() => {
       console.log(count);
     }, 1000);
     
     return () => {
       console.log('Cleanup with count:', count);
       clearInterval(timer);
     };
   }, [count]);
   ```

4. **在副作用中调用 Hooks**
   ```javascript
   // ❌ 错误：在副作用中调用 Hook
   useEffect(() => {
     const [localState, setLocalState] = useState(0);
   }, []);
   ```

### 最佳实践

1. **保持副作用函数简洁**
   ```javascript
   // ✅ 正确：副作用函数简洁，只做一件事
   useEffect(() => {
     fetchData();
   }, [fetchData]);
   ```

2. **将相关的副作用组合在一起**
   ```javascript
   // ✅ 正确：将相关的副作用组合在一个 useEffect 中
   useEffect(() => {
     // 订阅事件
     // 设置定时器
     
     return () => {
       // 取消订阅
       // 清除定时器
     };
   }, [deps]);
   ```

3. **使用 AbortController 取消 fetch 请求**
   ```javascript
   useEffect(() => {
     const controller = new AbortController();
     const signal = controller.signal;
     
     async function fetchData() {
       try {
         const response = await fetch('https://api.example.com/data', { signal });
         const result = await response.json();
         setData(result);
       } catch (err) {
         if (err.name !== 'AbortError') {
           setError(err.message);
         }
       }
     }
     
     fetchData();
     
     return () => {
       controller.abort();
     };
   }, []);
   ```

4. **使用函数式更新避免依赖项**
   ```javascript
   // ✅ 正确：使用函数式更新，不需要添加 count 到依赖项
   useEffect(() => {
     const timer = setInterval(() => {
       setCount(prevCount => prevCount + 1);
     }, 1000);
     
     return () => {
       clearInterval(timer);
     };
   }, []);
   ```

## 10. React 19 中的 useEffect 特性

React 19 对 `useEffect` 进行了一些改进：

1. **自动批处理**：在 React 19 中，所有状态更新都会自动批处理，包括在 `useEffect` 中的更新

2. **改进的错误处理**：当 `useEffect` 中发生错误时，React 19 提供了更清晰的错误消息

3. **与 React Server Components 兼容**：`useEffect` 只能在客户端组件中使用，与 React Server Components 无缝集成

4. **支持异步清理函数**：React 19 允许 `useEffect` 的清理函数是异步的

## 11. 测试 useEffect

### 使用 React Testing Library 测试

```javascript
import { render, screen, waitFor } from '@testing-library/react';
import UserProfile from './UserProfile';

// Mock fetch
global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve({ name: 'John Doe' }),
  })
);

test('fetches and displays user data', async () => {
  render(<UserProfile userId={123} />);
  
  // 初始状态应该显示加载中
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  // 等待数据加载完成
  await waitFor(() => {
    expect(screen.getByText('User: John Doe')).toBeInTheDocument();
  });
  
  // 验证 fetch 被调用
  expect(global.fetch).toHaveBeenCalledWith('https://api.example.com/users/123');
});
```

### 测试清理函数

```javascript
import { render, unmountComponentAtNode } from 'react-dom';
import CountdownTimer from './CountdownTimer';

test('cleans up timer on unmount', () => {
  const container = document.createElement('div');
  
  // 保存原始的 setTimeout 和 clearTimeout
  const originalSetTimeout = global.setTimeout;
  const originalClearTimeout = global.clearTimeout;
  
  // 跟踪函数调用
  const setTimeoutMock = jest.fn(originalSetTimeout);
  const clearTimeoutMock = jest.fn(originalClearTimeout);
  
  // 替换全局函数
  global.setTimeout = setTimeoutMock;
  global.clearTimeout = clearTimeoutMock;
  
  // 渲染组件
  render(<CountdownTimer />, container);
  
  // 卸载组件
  unmountComponentAtNode(container);
  
  // 验证清理函数被调用
  expect(clearTimeoutMock).toHaveBeenCalled();
  
  // 恢复原始函数
  global.setTimeout = originalSetTimeout;
  global.clearTimeout = originalClearTimeout;
});
```

## 12. 总结

`useEffect` 是 React Hooks 中用于处理副作用的核心 Hook，它为函数组件提供了执行副作用操作的能力。通过 `useEffect`，我们可以：

- 执行数据获取、订阅、手动 DOM 操作等副作用
- 模拟类组件的生命周期方法
- 管理副作用的执行时机
- 清理副作用，防止内存泄漏
- 与其他 Hooks 配合使用，构建复杂的组件逻辑

遵循 React Hooks 规则，合理使用 `useEffect`，可以编写出更简洁、更易于维护的 React 组件。

## 13. 进一步学习资源

- [React 官方文档 - useEffect](https://react.dev/reference/react/useEffect)
- [React Hooks 规则](https://react.dev/rules/hooks)
- [React 性能优化](https://react.dev/learn/optimizing-performance)
- [自定义 Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

通过掌握 `useEffect` Hook，你已经掌握了 React 中处理副作用的核心机制，为后续学习其他 Hooks 打下了坚实基础。