# 创建型模式

创建型模式关注对象的创建过程，提供了一种在创建对象时隐藏创建逻辑的方式，使得程序在不指定具体类的情况下创建对象。创建型模式主要包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。

## 一、单例模式（Singleton Pattern）

### 1. 概念
单例模式确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。

### 2. 适用场景
- 当类只能有一个实例，且客户端可以从一个全局访问点访问它时
- 当这个唯一实例应该是通过子类化可扩展的，并且客户端应该无需更改代码就能使用一个扩展的实例时

### 3. 实现方式

#### 方式一：饿汉式（线程安全）

```python
class Singleton:
    # 类加载时就创建实例
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        # 初始化代码
        self.data = "Singleton Data"

# 测试
if __name__ == "__main__":
    s1 = Singleton()
    s2 = Singleton()
    print(f"s1 is s2: {s1 is s2}")  # True
    print(f"s1.data: {s1.data}")    # Singleton Data
    print(f"s2.data: {s2.data}")    # Singleton Data
    
    # 修改一个实例的数据，另一个实例也会受到影响
    s1.data = "Modified Data"
    print(f"s1.data: {s1.data}")    # Modified Data
    print(f"s2.data: {s2.data}")    # Modified Data
```

#### 方式二：懒汉式（线程不安全）

```python
class Singleton:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        self.data = "Singleton Data"

# 测试
if __name__ == "__main__":
    s1 = Singleton()
    s2 = Singleton()
    print(f"s1 is s2: {s1 is s2}")  # True
```

#### 方式三：懒汉式（线程安全，使用锁）

```python
import threading

class Singleton:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        self.data = "Singleton Data"

# 测试
if __name__ == "__main__":
    s1 = Singleton()
    s2 = Singleton()
    print(f"s1 is s2: {s1 is s2}")  # True
```

#### 方式四：使用装饰器实现单例

```python
def singleton(cls):
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class MySingleton:
    def __init__(self, data):
        self.data = data

# 测试
if __name__ == "__main__":
    s1 = MySingleton("Data 1")
    s2 = MySingleton("Data 2")
    print(f"s1 is s2: {s1 is s2}")  # True
    print(f"s1.data: {s1.data}")    # Data 1
    print(f"s2.data: {s2.data}")    # Data 1 (第二次初始化被忽略)
```

#### 方式五：使用元类实现单例

```python
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    def __init__(self, data):
        self.data = data

# 测试
if __name__ == "__main__":
    s1 = Singleton("Data 1")
    s2 = Singleton("Data 2")
    print(f"s1 is s2: {s1 is s2}")  # True
    print(f"s1.data: {s1.data}")    # Data 1
    print(f"s2.data: {s2.data}")    # Data 1 (第二次初始化被忽略)
```

### 4. 优缺点

#### 优点
- 确保只有一个实例，减少了内存开销
- 提供了全局访问点，方便客户端访问
- 可以严格控制实例的创建过程

#### 缺点
- 违反了单一职责原则，一个类同时负责创建实例和业务逻辑
- 单例模式的扩展比较困难
- 单例模式在多线程环境下需要特殊处理，确保线程安全

## 二、工厂方法模式（Factory Method Pattern）

### 1. 概念
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。

### 2. 适用场景
- 当一个类不知道它所必须创建的对象的类时
- 当一个类希望由它的子类来指定它所创建的对象时
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 产品接口
class Product(ABC):
    @abstractmethod
    def operation(self) -> str:
        pass

# 具体产品1
class ConcreteProduct1(Product):
    def operation(self) -> str:
        return "ConcreteProduct1的操作结果"

# 具体产品2
class ConcreteProduct2(Product):
    def operation(self) -> str:
        return "ConcreteProduct2的操作结果"

# 工厂接口
class Creator(ABC):
    @abstractmethod
    def factory_method(self) -> Product:
        pass
    
    def some_operation(self) -> str:
        # 调用工厂方法创建产品实例
        product = self.factory_method()
        # 使用产品实例
        result = f"Creator: {product.operation()}"
        return result

# 具体工厂1
class ConcreteCreator1(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct1()

# 具体工厂2
class ConcreteCreator2(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct2()

# 客户端代码
def client_code(creator: Creator) -> None:
    print(f"客户端: 不关心具体工厂类型\n{creator.some_operation()}")

# 测试
if __name__ == "__main__":
    print("使用ConcreteCreator1:")
    client_code(ConcreteCreator1())
    
    print("\n使用ConcreteCreator2:")
    client_code(ConcreteCreator2())
```

### 4. 优缺点

#### 优点
- 遵循了单一职责原则，每个具体工厂只负责创建对应的产品
- 遵循了开放-封闭原则，新增产品类型时只需要新增对应的具体产品和具体工厂，不需要修改现有代码
- 客户端不需要知道具体产品的类名，只需要知道对应的工厂即可

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 客户端必须知道所有的具体工厂类，才能选择合适的工厂

## 三、抽象工厂模式（Abstract Factory Pattern）

### 1. 概念
抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 2. 适用场景
- 当一个系统要独立于它的产品的创建、组合和表示时
- 当一个系统要由多个产品系列中的一个来配置时
- 当你要强调一系列相关的产品对象的设计以便进行联合使用时
- 当你提供一个产品类库，而只想显示它们的接口而不是实现时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 抽象产品A
class AbstractProductA(ABC):
    @abstractmethod
    def useful_function_a(self) -> str:
        pass

# 具体产品A1
class ConcreteProductA1(AbstractProductA):
    def useful_function_a(self) -> str:
        return "ConcreteProductA1的有用功能"

# 具体产品A2
class ConcreteProductA2(AbstractProductA):
    def useful_function_a(self) -> str:
        return "ConcreteProductA2的有用功能"

# 抽象产品B
class AbstractProductB(ABC):
    @abstractmethod
    def useful_function_b(self) -> str:
        pass
    
    @abstractmethod
    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        pass

# 具体产品B1
class ConcreteProductB1(AbstractProductB):
    def useful_function_b(self) -> str:
        return "ConcreteProductB1的有用功能"
    
    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        result = collaborator.useful_function_a()
        return f"ConcreteProductB1与{result}合作"

# 具体产品B2
class ConcreteProductB2(AbstractProductB):
    def useful_function_b(self) -> str:
        return "ConcreteProductB2的有用功能"
    
    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        result = collaborator.useful_function_a()
        return f"ConcreteProductB2与{result}合作"

# 抽象工厂
class AbstractFactory(ABC):
    @abstractmethod
    def create_product_a(self) -> AbstractProductA:
        pass
    
    @abstractmethod
    def create_product_b(self) -> AbstractProductB:
        pass

# 具体工厂1
class ConcreteFactory1(AbstractFactory):
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA1()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB1()

# 具体工厂2
class ConcreteFactory2(AbstractFactory):
    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA2()
    
    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB2()

# 客户端代码
def client_code(factory: AbstractFactory) -> None:
    product_a = factory.create_product_a()
    product_b = factory.create_product_b()
    
    print(f"{product_a.useful_function_a()}")
    print(f"{product_b.useful_function_b()}")
    print(f"{product_b.another_useful_function_b(product_a)}")

# 测试
if __name__ == "__main__":
    print("使用ConcreteFactory1:")
    client_code(ConcreteFactory1())
    
    print("\n使用ConcreteFactory2:")
    client_code(ConcreteFactory2())
```

### 4. 优缺点

#### 优点
- 确保产品家族的一致性，同一工厂创建的产品可以相互配合使用
- 遵循了开放-封闭原则，新增产品家族时只需要新增对应的具体工厂和产品，不需要修改现有代码
- 隔离了具体产品的创建细节，客户端不需要知道具体产品的类名

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 新增产品类型时，需要修改抽象工厂接口和所有具体工厂类，违反了开放-封闭原则

## 四、建造者模式（Builder Pattern）

### 1. 概念
建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 2. 适用场景
- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时
- 当构造过程必须允许被构造的对象有不同的表示时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 产品类
class Product:
    def __init__(self):
        self.parts = []
    
    def add(self, part: str) -> None:
        self.parts.append(part)
    
    def list_parts(self) -> str:
        return f"产品部件: {', '.join(self.parts)}"

# 建造者接口
class Builder(ABC):
    @abstractmethod
    def produce_part_a(self) -> None:
        pass
    
    @abstractmethod
    def produce_part_b(self) -> None:
        pass
    
    @abstractmethod
    def produce_part_c(self) -> None:
        pass

# 具体建造者1
class ConcreteBuilder1(Builder):
    def __init__(self):
        self.reset()
    
    def reset(self) -> None:
        self._product = Product()
    
    def produce_part_a(self) -> None:
        self._product.add("部件A1")
    
    def produce_part_b(self) -> None:
        self._product.add("部件B1")
    
    def produce_part_c(self) -> None:
        self._product.add("部件C1")
    
    def get_product(self) -> Product:
        product = self._product
        self.reset()
        return product

# 具体建造者2
class ConcreteBuilder2(Builder):
    def __init__(self):
        self.reset()
    
    def reset(self) -> None:
        self._product = Product()
    
    def produce_part_a(self) -> None:
        self._product.add("部件A2")
    
    def produce_part_b(self) -> None:
        self._product.add("部件B2")
    
    def produce_part_c(self) -> None:
        self._product.add("部件C2")
    
    def get_product(self) -> Product:
        product = self._product
        self.reset()
        return product

# 指挥者
class Director:
    def __init__(self):
        self._builder = None
    
    @property
    def builder(self) -> Builder:
        return self._builder
    
    @builder.setter
    def builder(self, builder: Builder) -> None:
        self._builder = builder
    
    # 构建完整产品
    def build_full_featured_product(self) -> None:
        self.builder.produce_part_a()
        self.builder.produce_part_b()
        self.builder.produce_part_c()
    
    # 构建简化产品
    def build_minimal_viable_product(self) -> None:
        self.builder.produce_part_a()

# 客户端代码
def client_code() -> None:
    director = Director()
    builder1 = ConcreteBuilder1()
    director.builder = builder1
    
    print("标准产品:")
    director.build_full_featured_product()
    product1 = builder1.get_product()
    print(product1.list_parts())
    
    print("\n简化产品:")
    director.build_minimal_viable_product()
    product2 = builder1.get_product()
    print(product2.list_parts())
    
    # 不使用指挥者，直接使用建造者
    print("\n自定义产品:")
    builder2 = ConcreteBuilder2()
    builder2.produce_part_a()
    builder2.produce_part_c()
    product3 = builder2.get_product()
    print(product3.list_parts())

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 分离了复杂对象的构建和表示，使得同样的构建过程可以创建不同的表示
- 可以更精细地控制复杂对象的构建过程
- 遵循了单一职责原则，每个建造者只负责构建产品的一部分
- 遵循了开放-封闭原则，新增产品类型时只需要新增对应的建造者，不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 建造者模式的使用范围受到一定限制，只适用于创建复杂对象

## 五、原型模式（Prototype Pattern）

### 1. 概念
原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

### 2. 适用场景
- 当要实例化的类是在运行时指定时
- 当创建对象的成本很高，而复制现有对象的成本较低时
- 当要避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时

### 3. 实现方式

#### 方式一：使用copy模块实现原型模式

```python
import copy

class Prototype:
    def __init__(self):
        self._objects = {}
    
    def register_object(self, name, obj):
        """注册原型对象"""
        self._objects[name] = obj
    
    def unregister_object(self, name):
        """注销原型对象"""
        del self._objects[name]
    
    def clone(self, name, **attr):
        """克隆原型对象，并更新属性"""
        obj = copy.deepcopy(self._objects.get(name))
        obj.__dict__.update(attr)
        return obj

# 具体原型类
class Car:
    def __init__(self):
        self.make = "Toyota"
        self.model = "Camry"
        self.year = 2023
        self.color = "Red"
    
    def __str__(self):
        return f"{self.year} {self.make} {self.model} in {self.color}"

# 测试
if __name__ == "__main__":
    # 创建原型管理器
    prototype = Prototype()
    
    # 创建原型对象
    car = Car()
    
    # 注册原型对象
    prototype.register_object("car", car)
    
    # 克隆原型对象
    car1 = prototype.clone("car")
    print(f"car1: {car1}")  # 2023 Toyota Camry in Red
    
    # 克隆原型对象并更新属性
    car2 = prototype.clone("car", color="Blue", year=2024)
    print(f"car2: {car2}")  # 2024 Toyota Camry in Blue
    
    # 克隆原型对象并更新多个属性
    car3 = prototype.clone("car", make="Honda", model="Accord", color="Black")
    print(f"car3: {car3}")  # 2023 Honda Accord in Black
```

#### 方式二：实现__copy__和__deepcopy__方法

```python
import copy

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address
    
    def __copy__(self):
        # 浅拷贝
        return Person(self.name, self.age, self.address)
    
    def __deepcopy__(self, memo):
        # 深拷贝
        return Person(
            copy.deepcopy(self.name, memo),
            copy.deepcopy(self.age, memo),
            copy.deepcopy(self.address, memo)
        )
    
    def __str__(self):
        return f"Person(name={self.name}, age={self.age}, address={self.address})")

# 测试
if __name__ == "__main__":
    # 创建原型对象
    person1 = Person("Alice", 30, {"city": "New York", "street": "123 Main St"})
    
    # 浅拷贝
    person2 = copy.copy(person1)
    person2.name = "Bob"
    person2.address["city"] = "London"
    print(f"person1: {person1}")  # Person(name=Alice, age=30, address={'city': 'London', 'street': '123 Main St'})
    print(f"person2: {person2}")  # Person(name=Bob, age=30, address={'city': 'London', 'street': '123 Main St'})
    
    # 深拷贝
    person3 = copy.deepcopy(person1)
    person3.name = "Charlie"
    person3.address["city"] = "Paris"
    print(f"person1: {person1}")  # Person(name=Alice, age=30, address={'city': 'London', 'street': '123 Main St'})
    print(f"person3: {person3}")  # Person(name=Charlie, age=30, address={'city': 'Paris', 'street': '123 Main St'})
```

### 4. 优缺点

#### 优点
- 可以快速创建复杂对象，而不需要重新初始化对象
- 可以避免构造函数的限制，创建对象更加灵活
- 遵循了开放-封闭原则，新增产品类型时只需要实现原型接口即可

#### 缺点
- 需要为每个类实现克隆方法，对于复杂对象来说，克隆方法的实现可能比较困难
- 深拷贝和浅拷贝的实现需要仔细处理，避免出现问题

## 六、创建型模式总结

创建型模式关注对象的创建过程，提供了不同的方式来创建对象，以满足不同的需求：

- **单例模式**：确保一个类只有一个实例，并提供全局访问点
- **工厂方法模式**：定义创建对象的接口，由子类决定要实例化的类
- **抽象工厂模式**：提供创建一系列相关或相互依赖对象的接口
- **建造者模式**：将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示
- **原型模式**：通过拷贝现有对象来创建新对象

选择合适的创建型模式可以提高代码的灵活性、可复用性和可维护性，适应不断变化的需求。在实际应用中，需要根据具体情况选择合适的设计模式，避免过度设计。