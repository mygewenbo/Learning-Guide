# 结构型模式

结构型模式关注类和对象的组合，通过继承和组合来实现新的功能，提高系统的灵活性和可扩展性。结构型模式主要包括适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式和享元模式。

## 一、适配器模式（Adapter Pattern）

### 1. 概念
适配器模式将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

### 2. 适用场景
- 当你想使用一个已经存在的类，但它的接口不符合你的需求时
- 当你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作时
- 当你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口时

### 3. 实现方式

#### 方式一：类适配器（使用继承）

```python
from abc import ABC, abstractmethod

# 目标接口
class Target(ABC):
    @abstractmethod
    def request(self) -> str:
        pass

# 适配者类（被适配的类）
class Adaptee:
    def specific_request(self) -> str:
        return "适配者的特定请求"

# 类适配器（使用继承）
class ClassAdapter(Target, Adaptee):
    def request(self) -> str:
        # 调用适配者的特定方法，并进行适配
        return f"类适配器: {self.specific_request()}"

# 客户端代码
def client_code(target: Target) -> None:
    print(target.request())

# 测试
if __name__ == "__main__":
    print("客户端直接使用适配者:")
    adaptee = Adaptee()
    # 适配者的接口与客户端期望的接口不兼容
    # client_code(adaptee)  # 这会导致错误
    print(f"适配者的特定请求: {adaptee.specific_request()}")
    
    print("\n客户端使用类适配器:")
    adapter = ClassAdapter()
    client_code(adapter)
```

#### 方式二：对象适配器（使用组合）

```python
from abc import ABC, abstractmethod

# 目标接口
class Target(ABC):
    @abstractmethod
    def request(self) -> str:
        pass

# 适配者类（被适配的类）
class Adaptee:
    def specific_request(self) -> str:
        return "适配者的特定请求"

# 对象适配器（使用组合）
class ObjectAdapter(Target):
    def __init__(self, adaptee: Adaptee) -> None:
        self._adaptee = adaptee
    
    def request(self) -> str:
        # 调用适配者的特定方法，并进行适配
        return f"对象适配器: {self._adaptee.specific_request()}"

# 客户端代码
def client_code(target: Target) -> None:
    print(target.request())

# 测试
if __name__ == "__main__":
    print("客户端使用对象适配器:")
    adaptee = Adaptee()
    adapter = ObjectAdapter(adaptee)
    client_code(adapter)
```

### 4. 优缺点

#### 优点
- 提高了类的复用性，允许将现有的类适配到新的接口
- 提高了系统的灵活性，使得可以在不修改原有代码的情况下使用新的功能
- 遵循了开放-封闭原则，新增适配器不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 适配器模式的使用范围受到一定限制，只适用于接口不兼容的情况

## 二、装饰器模式（Decorator Pattern）

### 1. 概念
装饰器模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活。

### 2. 适用场景
- 当需要给一个对象添加额外的职责，而又不希望通过继承来实现时
- 当需要动态地给一个对象添加职责，这些职责可以动态地撤销时
- 当需要给一批对象添加不同的职责，而又不希望创建大量的子类时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    @abstractmethod
    def operation(self) -> str:
        pass

# 具体组件
class ConcreteComponent(Component):
    def operation(self) -> str:
        return "具体组件的操作"

# 装饰器抽象类
class Decorator(Component):
    def __init__(self, component: Component) -> None:
        self._component = component
    
    @abstractmethod
    def operation(self) -> str:
        pass

# 具体装饰器1
class ConcreteDecorator1(Decorator):
    def operation(self) -> str:
        # 调用被装饰者的操作，并添加额外的功能
        return f"具体装饰器1({self._component.operation()})"

# 具体装饰器2
class ConcreteDecorator2(Decorator):
    def operation(self) -> str:
        # 调用被装饰者的操作，并添加额外的功能
        return f"具体装饰器2({self._component.operation()})"

# 客户端代码
def client_code(component: Component) -> None:
    print(f"结果: {component.operation()}")

# 测试
if __name__ == "__main__":
    # 使用具体组件
    simple = ConcreteComponent()
    print("客户端: 使用简单组件:")
    client_code(simple)
    
    # 使用装饰器1装饰组件
    decorator1 = ConcreteDecorator1(simple)
    print("\n客户端: 使用装饰器1装饰组件:")
    client_code(decorator1)
    
    # 使用装饰器2装饰已经装饰过的组件
    decorator2 = ConcreteDecorator2(decorator1)
    print("\n客户端: 使用装饰器2装饰已经装饰过的组件:")
    client_code(decorator2)
    
    # 可以组合多个装饰器
    decorator3 = ConcreteDecorator1(ConcreteDecorator2(simple))
    print("\n客户端: 使用多个装饰器组合:")
    client_code(decorator3)
```

### 4. 优缺点

#### 优点
- 可以动态地给对象添加额外的职责，而不需要修改原有代码
- 可以通过组合不同的装饰器来实现不同的功能组合
- 遵循了开放-封闭原则，新增装饰器不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 装饰器的使用可能会导致代码可读性下降
- 装饰器的执行顺序可能会影响最终结果

## 三、代理模式（Proxy Pattern）

### 1. 概念
代理模式为其他对象提供一种代理以控制对这个对象的访问。

### 2. 适用场景
- 当需要在访问一个对象之前或之后执行一些额外的操作时
- 当需要控制对一个对象的访问时
- 当需要延迟加载一个对象时
- 当需要对一个对象进行保护时

### 3. 实现方式

#### 方式一：静态代理

```python
from abc import ABC, abstractmethod

# 主题接口
class Subject(ABC):
    @abstractmethod
    def request(self) -> None:
        pass

# 真实主题
class RealSubject(Subject):
    def request(self) -> None:
        print("真实主题: 处理请求")

# 代理
class Proxy(Subject):
    def __init__(self, real_subject: RealSubject) -> None:
        self._real_subject = real_subject
    
    def request(self) -> None:
        # 在调用真实主题之前执行一些额外的操作
        self._before_request()
        # 调用真实主题
        self._real_subject.request()
        # 在调用真实主题之后执行一些额外的操作
        self._after_request()
    
    def _before_request(self) -> None:
        print("代理: 在请求之前执行一些额外的操作")
    
    def _after_request(self) -> None:
        print("代理: 在请求之后执行一些额外的操作")

# 客户端代码
def client_code(subject: Subject) -> None:
    subject.request()

# 测试
if __name__ == "__main__":
    print("客户端直接使用真实主题:")
    real_subject = RealSubject()
    client_code(real_subject)
    
    print("\n客户端使用代理:")
    proxy = Proxy(real_subject)
    client_code(proxy)
```

#### 方式二：动态代理（使用Python的装饰器）

```python
from functools import wraps

def proxy_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        # 在调用真实函数之前执行一些额外的操作
        print("代理: 在请求之前执行一些额外的操作")
        # 调用真实函数
        result = func(*args, **kwargs)
        # 在调用真实函数之后执行一些额外的操作
        print("代理: 在请求之后执行一些额外的操作")
        return result
    return wrapper

# 真实主题
class RealSubject:
    @proxy_decorator
    def request(self) -> None:
        print("真实主题: 处理请求")

# 客户端代码
def client_code(subject) -> None:
    subject.request()

# 测试
if __name__ == "__main__":
    print("客户端使用动态代理:")
    real_subject = RealSubject()
    client_code(real_subject)
```

### 4. 优缺点

#### 优点
- 可以在访问对象之前或之后执行一些额外的操作
- 可以控制对对象的访问，实现权限控制、延迟加载等功能
- 遵循了开放-封闭原则，新增代理不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 代理的使用可能会导致请求处理速度变慢
- 代理的实现可能会比较复杂

## 四、外观模式（Facade Pattern）

### 1. 概念
外观模式为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

### 2. 适用场景
- 当需要为一个复杂的子系统提供一个简单的接口时
- 当需要简化与一个复杂子系统的交互时
- 当需要将一个子系统与其他子系统分离，以提高系统的独立性和可移植性时

### 3. 实现方式

```python
# 子系统1
class Subsystem1:
    def operation1(self) -> str:
        return "子系统1: 操作1"
    
    def operation2(self) -> str:
        return "子系统1: 操作2"

# 子系统2
class Subsystem2:
    def operation1(self) -> str:
        return "子系统2: 操作1"
    
    def operation2(self) -> str:
        return "子系统2: 操作2"

# 外观类
class Facade:
    def __init__(self) -> None:
        self._subsystem1 = Subsystem1()
        self._subsystem2 = Subsystem2()
    
    def operation(self) -> str:
        """外观方法，提供一个简单的接口"""
        results = []
        results.append("外观: 准备执行操作")
        results.append(self._subsystem1.operation1())
        results.append(self._subsystem2.operation1())
        results.append(self._subsystem1.operation2())
        results.append(self._subsystem2.operation2())
        results.append("外观: 操作执行完成")
        return "\n".join(results)

# 客户端代码
def client_code(facade: Facade) -> None:
    print(facade.operation())

# 测试
if __name__ == "__main__":
    print("客户端直接使用子系统:")
    subsystem1 = Subsystem1()
    subsystem2 = Subsystem2()
    print(subsystem1.operation1())
    print(subsystem2.operation1())
    print(subsystem1.operation2())
    print(subsystem2.operation2())
    
    print("\n客户端使用外观:")
    facade = Facade()
    client_code(facade)
```

### 4. 优缺点

#### 优点
- 简化了与复杂子系统的交互，提供了一个简单的接口
- 降低了客户端与子系统之间的耦合度
- 提高了系统的可维护性和可扩展性
- 遵循了迪米特法则，客户端只需要与外观类交互

#### 缺点
- 外观类可能会变得过于复杂，承担过多的职责
- 外观类可能会成为系统的瓶颈
- 外观类的修改可能会影响客户端代码

## 五、桥接模式（Bridge Pattern）

### 1. 概念
桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。

### 2. 适用场景
- 当需要将抽象部分与实现部分分离，使它们可以独立地变化时
- 当需要在多个维度上扩展一个类时
- 当需要避免由于使用继承而导致的类爆炸时

### 3. 实现方式

```python
from abc import ABC, abstractmethod

# 实现接口
class Implementation(ABC):
    @abstractmethod
    def operation_implementation(self) -> str:
        pass

# 具体实现1
class ConcreteImplementation1(Implementation):
    def operation_implementation(self) -> str:
        return "具体实现1的操作"

# 具体实现2
class ConcreteImplementation2(Implementation):
    def operation_implementation(self) -> str:
        return "具体实现2的操作"

# 抽象类
class Abstraction:
    def __init__(self, implementation: Implementation) -> None:
        self._implementation = implementation
    
    def operation(self) -> str:
        return f"抽象: 基于{self._implementation.operation_implementation()}"

# 扩展抽象类
class ExtendedAbstraction(Abstraction):
    def operation(self) -> str:
        return f"扩展抽象: 基于{self._implementation.operation_implementation()}"

# 客户端代码
def client_code(abstraction: Abstraction) -> None:
    print(abstraction.operation())

# 测试
if __name__ == "__main__":
    # 使用具体实现1
    implementation1 = ConcreteImplementation1()
    abstraction1 = Abstraction(implementation1)
    print("客户端: 使用基本抽象和具体实现1:")
    client_code(abstraction1)
    
    # 使用具体实现2
    implementation2 = ConcreteImplementation2()
    abstraction2 = Abstraction(implementation2)
    print("\n客户端: 使用基本抽象和具体实现2:")
    client_code(abstraction2)
    
    # 使用扩展抽象和具体实现1
    extended_abstraction1 = ExtendedAbstraction(implementation1)
    print("\n客户端: 使用扩展抽象和具体实现1:")
    client_code(extended_abstraction1)
    
    # 使用扩展抽象和具体实现2
    extended_abstraction2 = ExtendedAbstraction(implementation2)
    print("\n客户端: 使用扩展抽象和具体实现2:")
    client_code(extended_abstraction2)
```

### 4. 优缺点

#### 优点
- 分离了抽象部分和实现部分，使它们可以独立地变化
- 减少了继承的使用，避免了类爆炸问题
- 提高了系统的可扩展性，新增抽象或实现不需要修改现有代码
- 遵循了开放-封闭原则

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 桥接模式的使用可能会导致代码可读性下降
- 桥接模式的设计和实现可能比较复杂

## 六、组合模式（Composite Pattern）

### 1. 概念
组合模式将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

### 2. 适用场景
- 当需要表示对象的"部分-整体"层次结构时
- 当需要让客户端能够统一处理单个对象和组合对象时
- 当需要递归地处理对象结构时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import List

# 组件抽象类
class Component(ABC):
    def __init__(self, name: str) -> None:
        self._name = name
    
    @abstractmethod
    def add(self, component) -> None:
        pass
    
    @abstractmethod
    def remove(self, component) -> None:
        pass
    
    @abstractmethod
    def display(self, depth: int) -> None:
        pass

# 叶子节点
class Leaf(Component):
    def add(self, component) -> None:
        print("叶子节点: 不能添加子节点")
    
    def remove(self, component) -> None:
        print("叶子节点: 没有子节点可以删除")
    
    def display(self, depth: int) -> None:
        print("-" * depth + self._name)

# 组合节点
class Composite(Component):
    def __init__(self, name: str) -> None:
        super().__init__(name)
        self._children: List[Component] = []
    
    def add(self, component) -> None:
        self._children.append(component)
    
    def remove(self, component) -> None:
        self._children.remove(component)
    
    def display(self, depth: int) -> None:
        print("-" * depth + self._name)
        for child in self._children:
            child.display(depth + 2)

# 客户端代码
def client_code() -> None:
    # 创建根节点
    root = Composite("根节点")
    
    # 添加子节点
    branch1 = Composite("分支1")
    branch1.add(Leaf("叶子1-1"))
    branch1.add(Leaf("叶子1-2"))
    
    branch2 = Composite("分支2")
    branch2.add(Leaf("叶子2-1"))
    
    branch3 = Composite("分支3")
    branch3.add(Leaf("叶子3-1"))
    branch3.add(Leaf("叶子3-2"))
    branch3.add(Leaf("叶子3-3"))
    
    # 将分支添加到根节点
    root.add(branch1)
    root.add(branch2)
    root.add(branch3)
    
    # 显示树形结构
    print("树形结构:")
    root.display(1)
    
    # 删除一个分支
    print("\n删除分支2后:")
    root.remove(branch2)
    root.display(1)
    
    # 尝试在叶子节点上添加子节点
    print("\n尝试在叶子节点上添加子节点:")
    leaf = Leaf("叶子")
    leaf.add(Leaf("子叶子"))

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 可以表示对象的"部分-整体"层次结构
- 客户端可以统一处理单个对象和组合对象
- 可以递归地处理对象结构
- 遵循了开放-封闭原则，新增叶子节点或组合节点不需要修改现有代码

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 组合模式的使用可能会导致代码可读性下降
- 组合模式的设计和实现可能比较复杂

## 七、享元模式（Flyweight Pattern）

### 1. 概念
享元模式运用共享技术有效地支持大量细粒度的对象。

### 2. 适用场景
- 当需要创建大量细粒度的对象时
- 当对象的大部分状态可以外部化时
- 当对象可以共享时

### 3. 实现方式

```python
from abc import ABC, abstractmethod
from typing import Dict

# 享元接口
class Flyweight(ABC):
    @abstractmethod
    def operation(self, extrinsic_state: str) -> None:
        pass

# 具体享元
class ConcreteFlyweight(Flyweight):
    def __init__(self, intrinsic_state: str) -> None:
        # 内部状态，共享部分
        self._intrinsic_state = intrinsic_state
    
    def operation(self, extrinsic_state: str) -> None:
        # 外部状态，非共享部分
        print(f"具体享元: 内部状态={self._intrinsic_state}, 外部状态={extrinsic_state}")

# 享元工厂
class FlyweightFactory:
    def __init__(self) -> None:
        self._flyweights: Dict[str, Flyweight] = {}
    
    def get_flyweight(self, key: str) -> Flyweight:
        # 如果享元不存在，则创建一个新的享元
        if key not in self._flyweights:
            self._flyweights[key] = ConcreteFlyweight(key)
        return self._flyweights[key]
    
    def get_flyweight_count(self) -> int:
        return len(self._flyweights)

# 客户端代码
def client_code() -> None:
    factory = FlyweightFactory()
    
    # 获取享元
    flyweight1 = factory.get_flyweight("A")
    flyweight1.operation("1")
    
    flyweight2 = factory.get_flyweight("B")
    flyweight2.operation("2")
    
    # 再次获取相同的享元
    flyweight3 = factory.get_flyweight("A")
    flyweight3.operation("3")
    
    # 检查是否是同一个享元
    print(f"\nflyweight1和flyweight3是否是同一个对象: {flyweight1 is flyweight3}")
    
    # 查看享元数量
    print(f"享元数量: {factory.get_flyweight_count()}")

# 测试
if __name__ == "__main__":
    client_code()
```

### 4. 优缺点

#### 优点
- 可以减少对象的创建，降低内存消耗
- 可以提高系统的性能
- 可以提高系统的可维护性

#### 缺点
- 增加了系统的复杂度，需要创建更多的类
- 享元模式的设计和实现可能比较复杂
- 享元模式的使用可能会导致代码可读性下降

## 八、结构型模式总结

结构型模式关注类和对象的组合，提供了不同的方式来组合类和对象，以满足不同的需求：

- **适配器模式**：将一个类的接口转换成客户希望的另一个接口
- **装饰器模式**：动态地给一个对象添加一些额外的职责
- **代理模式**：为其他对象提供一种代理以控制对这个对象的访问
- **外观模式**：为子系统中的一组接口提供一个一致的界面
- **桥接模式**：将抽象部分与它的实现部分分离，使它们都可以独立地变化
- **组合模式**：将对象组合成树形结构以表示"部分-整体"的层次结构
- **享元模式**：运用共享技术有效地支持大量细粒度的对象

选择合适的结构型模式可以提高代码的灵活性、可复用性和可维护性，适应不断变化的需求。在实际应用中，需要根据具体情况选择合适的设计模式，避免过度设计。