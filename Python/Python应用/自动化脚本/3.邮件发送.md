# 邮件发送

## 一、概述

在自动化脚本开发中，邮件发送是一项非常实用的功能，它可以用于：

- 自动化报告生成与发送
- 系统监控告警
- 数据备份通知
- 自动回复与确认
- 批量邮件发送

Python提供了强大的邮件发送库，使得我们可以轻松地在脚本中集成邮件发送功能。本章将详细介绍如何使用Python发送各种类型的邮件，包括纯文本邮件、HTML邮件、带附件的邮件等。

## 二、邮件发送基础

### 1. 邮件发送协议

邮件发送主要使用SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），它是一组用于从源地址到目的地址传输邮件的规范。SMTP默认使用端口25，加密连接使用端口465（SMTPS）或587（STARTTLS）。

### 2. Python邮件发送库

Python标准库中提供了两个主要的邮件处理模块：

- **smtplib**：用于发送邮件
- **email**：用于构建邮件内容

此外，还有一些第三方库可以简化邮件发送过程，如：

- **yagmail**：提供更简洁的API
- **sendgrid**：用于发送大量邮件
- **mailchimp**：用于邮件营销

## 三、smtplib模块详解

smtplib模块实现了SMTP客户端会话对象，用于发送邮件。

### 1. 基本使用流程

```python
import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 1. 构建邮件内容
msg = MIMEText('邮件内容', 'plain', 'utf-8')
msg['From'] = Header('发件人名称', 'utf-8')
msg['To'] = Header('收件人名称', 'utf-8')
msg['Subject'] = Header('邮件主题', 'utf-8')

# 2. 连接SMTP服务器并发送邮件
try:
    # 创建SMTP对象
    smtp_obj = smtplib.SMTP('smtp.example.com', 25)
    # 登录SMTP服务器
    smtp_obj.login('username', 'password')
    # 发送邮件
    smtp_obj.sendmail('sender@example.com', ['recipient@example.com'], msg.as_string())
    print("邮件发送成功")
except smtplib.SMTPException as e:
    print(f"邮件发送失败: {e}")
finally:
    # 关闭连接
    smtp_obj.quit()
```

### 2. SMTP连接方式

#### 2.1 普通连接（端口25）

```python
smtp_obj = smtplib.SMTP('smtp.example.com', 25)
```

#### 2.2 SSL加密连接（端口465）

```python
smtp_obj = smtplib.SMTP_SSL('smtp.example.com', 465)
```

#### 2.3 STARTTLS加密连接（端口587）

```python
smtp_obj = smtplib.SMTP('smtp.example.com', 587)
smtp_obj.starttls()  # 启用TLS加密
```

### 3. SMTP认证

```python
# 基本认证
smtp_obj.login('username', 'password')

# 对于需要应用密码的服务（如Gmail、QQ邮箱），使用应用密码而非登录密码
# smtp_obj.login('your_email@example.com', 'your_app_password')
```

### 4. 发送邮件

```python
# 发送给单个收件人
smtp_obj.sendmail('sender@example.com', 'recipient@example.com', msg.as_string())

# 发送给多个收件人
smtp_obj.sendmail('sender@example.com', ['recipient1@example.com', 'recipient2@example.com'], msg.as_string())

# 同时指定收件人、抄送人和密送
to_list = ['recipient1@example.com']
cc_list = ['cc@example.com']
bcc_list = ['bcc@example.com']
all_recipients = to_list + cc_list + bcc_list
smtp_obj.sendmail('sender@example.com', all_recipients, msg.as_string())
```

## 四、email模块详解

email模块用于构建邮件内容，支持多种邮件类型。

### 1. 邮件类型

| 类型 | 描述 | 模块 |
|------|------|------|
| 纯文本邮件 | 只包含文本内容 | email.mime.text.MIMEText |
| HTML邮件 | 包含HTML格式内容 | email.mime.text.MIMEText |
| 带附件的邮件 | 包含附件 | email.mime.multipart.MIMEMultipart |
| 内嵌图片的HTML邮件 | HTML中内嵌图片 | email.mime.multipart.MIMEMultipart + email.mime.image.MIMEImage |

### 2. 构建纯文本邮件

```python
from email.mime.text import MIMEText
from email.header import Header
from email.utils import formataddr

# 构建纯文本邮件
msg = MIMEText('这是一封纯文本邮件的内容', 'plain', 'utf-8')

# 设置发件人信息
msg['From'] = formataddr((Header('发件人名称', 'utf-8').encode(), 'sender@example.com'))

# 设置收件人信息
msg['To'] = formataddr((Header('收件人名称', 'utf-8').encode(), 'recipient@example.com'))

# 设置抄送信息
msg['Cc'] = formataddr((Header('抄送收件人', 'utf-8').encode(), 'cc@example.com'))

# 设置邮件主题
msg['Subject'] = Header('纯文本邮件主题', 'utf-8')
```

### 3. 构建HTML邮件

```python
from email.mime.text import MIMEText

# HTML内容
html_content = """
<html>
    <body>
        <h1>这是一封HTML邮件</h1>
        <p>HTML邮件可以包含丰富的格式，如：</p>
        <ul>
            <li><strong>粗体文本</strong></li>
            <li><em>斜体文本</em></li>
            <li><a href="https://www.example.com">链接</a></li>
            <li>列表项</li>
        </ul>
        <p>还可以包含表格：</p>
        <table border="1">
            <tr>
                <th>列1</th>
                <th>列2</th>
            </tr>
            <tr>
                <td>数据1</td>
                <td>数据2</td>
            </tr>
        </table>
    </body>
</html>
"""

# 构建HTML邮件
msg = MIMEText(html_content, 'html', 'utf-8')

# 设置邮件头信息（略）
```

### 4. 构建带附件的邮件

```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import os

# 创建带附件的邮件对象
msg = MIMEMultipart()

# 设置邮件头信息（略）

# 添加正文
text_content = "这是一封带附件的邮件"
msg.attach(MIMEText(text_content, 'plain', 'utf-8'))

# 添加附件1：文本文件
file_path1 = 'example.txt'
with open(file_path1, 'rb') as f:
    attach1 = MIMEApplication(f.read(), _subtype='txt')
    attach1.add_header('Content-Disposition', 'attachment', filename=os.path.basename(file_path1))
    msg.attach(attach1)

# 添加附件2：PDF文件
file_path2 = 'example.pdf'
with open(file_path2, 'rb') as f:
    attach2 = MIMEApplication(f.read(), _subtype='pdf')
    attach2.add_header('Content-Disposition', 'attachment', filename=os.path.basename(file_path2))
    msg.attach(attach2)
```

### 5. 构建内嵌图片的HTML邮件

```python
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
import os

# 创建邮件对象
msg = MIMEMultipart('related')

# 设置邮件头信息（略）

# 创建HTML内容，引用内嵌图片
html_content = """
<html>
    <body>
        <h1>这是一封内嵌图片的HTML邮件</h1>
        <p>以下是内嵌图片：</p>
        <img src="cid:image1" alt="示例图片">
    </body>
</html>
"""

# 添加HTML正文
msg.attach(MIMEText(html_content, 'html', 'utf-8'))

# 内嵌图片
image_path = 'example.jpg'
with open(image_path, 'rb') as f:
    img = MIMEImage(f.read())
    # 设置图片ID，与HTML中的cid对应
    img.add_header('Content-ID', '<image1>')
    msg.attach(img)
```

## 五、常用邮件服务配置

### 1. Gmail

```python
import smtplib
from email.mime.text import MIMEText

# Gmail SMTP配置
smtp_server = 'smtp.gmail.com'
smtp_port = 587  # 使用STARTTLS
# smtp_port = 465  # 使用SSL
sender_email = 'your_email@gmail.com'
sender_password = 'your_app_password'  # 应用密码，不是登录密码

# 构建邮件
msg = MIMEText('这是一封来自Gmail的测试邮件', 'plain', 'utf-8')
msg['From'] = sender_email
msg['To'] = 'recipient@example.com'
msg['Subject'] = 'Gmail测试邮件'

# 发送邮件
try:
    with smtplib.SMTP(smtp_server, smtp_port) as server:
        server.starttls()  # 启用TLS加密
        server.login(sender_email, sender_password)
        server.send_message(msg)
    print("邮件发送成功")
except Exception as e:
    print(f"邮件发送失败: {e}")
```

### 2. QQ邮箱

```python
import smtplib
from email.mime.text import MIMEText
from email.header import Header

# QQ邮箱SMTP配置
smtp_server = 'smtp.qq.com'
smtp_port = 465  # 使用SSL
sender_email = 'your_email@qq.com'
sender_password = 'your_app_password'  # QQ邮箱授权码

# 构建邮件
msg = MIMEText('这是一封来自QQ邮箱的测试邮件', 'plain', 'utf-8')
msg['From'] = Header('发送者', 'utf-8')
msg['To'] = Header('接收者', 'utf-8')
msg['Subject'] = Header('QQ邮箱测试邮件', 'utf-8')

# 发送邮件
try:
    with smtplib.SMTP_SSL(smtp_server, smtp_port) as server:
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, 'recipient@example.com', msg.as_string())
    print("邮件发送成功")
except Exception as e:
    print(f"邮件发送失败: {e}")
```

### 3. 163邮箱

```python
import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 163邮箱SMTP配置
smtp_server = 'smtp.163.com'
smtp_port = 465  # 使用SSL
sender_email = 'your_email@163.com'
sender_password = 'your_app_password'  # 163邮箱授权码

# 构建邮件
msg = MIMEText('这是一封来自163邮箱的测试邮件', 'plain', 'utf-8')
msg['From'] = Header('发送者', 'utf-8')
msg['To'] = Header('接收者', 'utf-8')
msg['Subject'] = Header('163邮箱测试邮件', 'utf-8')

# 发送邮件
try:
    with smtplib.SMTP_SSL(smtp_server, smtp_port) as server:
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, 'recipient@example.com', msg.as_string())
    print("邮件发送成功")
except Exception as e:
    print(f"邮件发送失败: {e}")
```

## 六、高级邮件发送功能

### 1. 批量邮件发送

```python
import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 邮件配置
smtp_server = 'smtp.example.com'
smtp_port = 587
sender_email = 'sender@example.com'
sender_password = 'password'

# 邮件内容
subject = '批量邮件测试'
body = '这是一封批量发送的测试邮件'

# 收件人列表
recipients = [
    'recipient1@example.com',
    'recipient2@example.com',
    'recipient3@example.com'
]

# 构建邮件模板
msg_template = MIMEText(body, 'plain', 'utf-8')
msg_template['From'] = Header('批量发送', 'utf-8')
msg_template['Subject'] = Header(subject, 'utf-8')

# 发送邮件
try:
    with smtplib.SMTP(smtp_server, smtp_port) as server:
        server.starttls()
        server.login(sender_email, sender_password)
        
        for recipient in recipients:
            # 为每个收件人创建邮件对象
            msg = MIMEText(body, 'plain', 'utf-8')
            msg['From'] = Header('批量发送', 'utf-8')
            msg['To'] = Header(recipient.split('@')[0], 'utf-8')
            msg['Subject'] = Header(subject, 'utf-8')
            
            server.sendmail(sender_email, recipient, msg.as_string())
            print(f"已发送到: {recipient}")
    
    print("所有邮件发送完成")
except Exception as e:
    print(f"邮件发送失败: {e}")
```

### 2. 个性化邮件发送

```python
import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 邮件配置（略）

# 收件人数据，包含个性化信息
recipients = [
    {'email': 'recipient1@example.com', 'name': '张三', 'info': '您的订单已发货'},
    {'email': 'recipient2@example.com', 'name': '李四', 'info': '您的会员即将到期'},
    {'email': 'recipient3@example.com', 'name': '王五', 'info': '您有新的消息'}
]

# 发送个性化邮件
try:
    with smtplib.SMTP(smtp_server, smtp_port) as server:
        server.starttls()
        server.login(sender_email, sender_password)
        
        for recipient in recipients:
            # 个性化邮件内容
            body = f"尊敬的{recipient['name']}：\n\n{recipient['info']}。\n\n此致\n敬礼"
            
            # 构建邮件
            msg = MIMEText(body, 'plain', 'utf-8')
            msg['From'] = Header('系统通知', 'utf-8')
            msg['To'] = Header(recipient['name'], 'utf-8')
            msg['Subject'] = Header('重要通知', 'utf-8')
            
            server.sendmail(sender_email, recipient['email'], msg.as_string())
            print(f"已发送到: {recipient['email']}")
    
    print("所有邮件发送完成")
except Exception as e:
    print(f"邮件发送失败: {e}")
```

### 3. 邮件发送状态监控

```python
import smtplib
from email.mime.text import MIMEText
import logging

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# 邮件配置（略）

# 发送邮件并记录日志
def send_email(recipient, subject, body):
    try:
        # 构建邮件
        msg = MIMEText(body, 'plain', 'utf-8')
        msg['From'] = sender_email
        msg['To'] = recipient
        msg['Subject'] = subject
        
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(msg)
        
        logging.info(f"邮件发送成功: {recipient} - {subject}")
        return True
    except Exception as e:
        logging.error(f"邮件发送失败: {recipient} - {subject} - {str(e)}")
        return False

# 使用示例
send_email('recipient@example.com', '测试邮件', '这是一封测试邮件')
```

### 4. 异步邮件发送

```python
import asyncio
import smtplib
from email.mime.text import MIMEText

# 邮件配置（略）

# 异步发送邮件
async def send_email_async(recipient, subject, body):
    loop = asyncio.get_event_loop()
    
    # 构建邮件
    msg = MIMEText(body, 'plain', 'utf-8')
    msg['From'] = sender_email
    msg['To'] = recipient
    msg['Subject'] = subject
    
    # 使用线程池执行同步的smtplib操作
    def send():
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(msg)
    
    await loop.run_in_executor(None, send)
    print(f"邮件发送成功: {recipient}")

# 批量异步发送
async def send_batch_emails():
    recipients = [
        'recipient1@example.com',
        'recipient2@example.com',
        'recipient3@example.com'
    ]
    
    # 创建任务列表
    tasks = []
    for recipient in recipients:
        task = asyncio.create_task(
            send_email_async(recipient, '异步测试邮件', '这是一封异步发送的测试邮件')
        )
        tasks.append(task)
    
    # 等待所有任务完成
    await asyncio.gather(*tasks)

# 运行异步函数
if __name__ == "__main__":
    asyncio.run(send_batch_emails())
    print("所有邮件发送完成")
```

## 七、邮件发送最佳实践

### 1. 安全性

- **使用加密连接**：始终使用SSL或STARTTLS加密连接
- **保护密码**：不要在代码中硬编码密码，使用环境变量或配置文件
- **使用应用密码**：对于支持的服务，使用应用密码而非登录密码
- **限制发送频率**：避免频繁发送邮件，防止被标记为垃圾邮件

### 2. 可靠性

- **使用上下文管理器**：确保SMTP连接正确关闭
- **添加异常处理**：捕获并处理可能的异常
- **实现重试机制**：对于发送失败的邮件，实现合理的重试逻辑
- **记录日志**：记录邮件发送状态，便于调试和监控

### 3. 邮件内容

- **清晰的主题**：主题应简洁明了，反映邮件内容
- **适当的格式**：根据内容选择合适的邮件类型（纯文本或HTML）
- **避免垃圾邮件特征**：不要使用过多的链接、图片或敏感词汇
- **添加退订选项**：对于批量发送的邮件，添加退订链接

### 4. 性能优化

- **批量发送**：对于大量邮件，使用批量发送而非单封发送
- **异步发送**：使用异步或多线程发送，提高发送效率
- **连接复用**：在发送多封邮件时，复用SMTP连接

## 八、第三方邮件库

### 1. yagmail

yagmail是一个简化邮件发送的第三方库，提供了更简洁的API。

```python
# 安装：pip install yagmail
import yagmail

# 配置yagmail
yag = yagmail.SMTP(user='sender@example.com', password='password', host='smtp.example.com', port=587)

# 发送纯文本邮件
yag.send(
    to='recipient@example.com',
    subject='yagmail测试邮件',
    contents='这是一封使用yagmail发送的纯文本邮件'
)

# 发送带附件的邮件
yag.send(
    to='recipient@example.com',
    subject='带附件的邮件',
    contents='这是一封带附件的邮件',
    attachments=['example.txt', 'example.pdf']
)

# 发送HTML邮件
yag.send(
    to='recipient@example.com',
    subject='HTML邮件',
    contents='<h1>这是一封HTML邮件</h1><p>使用yagmail发送</p>'
)

# 关闭连接
yag.close()
```

### 2. sendgrid

SendGrid是一个专业的邮件发送服务，提供了强大的API和统计功能。

```python
# 安装：pip install sendgrid
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail

# 配置SendGrid
sg = SendGridAPIClient(api_key='your_sendgrid_api_key')

# 构建邮件
message = Mail(
    from_email='sender@example.com',
    to_emails='recipient@example.com',
    subject='SendGrid测试邮件',
    plain_text_content='这是一封使用SendGrid发送的纯文本邮件',
    html_content='<strong>这是一封使用SendGrid发送的HTML邮件</strong>'
)

# 发送邮件
try:
    response = sg.send(message)
    print(f"状态码: {response.status_code}")
    print(f"响应头: {response.headers}")
    print("邮件发送成功")
except Exception as e:
    print(f"邮件发送失败: {e}")
```

## 九、综合示例

### 1. 系统监控告警邮件

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import psutil
import datetime

# 邮件配置
smtp_server = 'smtp.example.com'
smtp_port = 587
sender_email = 'monitor@example.com'
sender_password = 'password'
recipient_email = 'admin@example.com'

# 获取系统信息
def get_system_info():
    info = {
        'timestamp': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'cpu_usage': psutil.cpu_percent(interval=1),
        'memory_usage': psutil.virtual_memory().percent,
        'disk_usage': psutil.disk_usage('/').percent,
        'network_sent': psutil.net_io_counters().bytes_sent,
        'network_recv': psutil.net_io_counters().bytes_recv
    }
    return info

# 构建告警邮件
def build_alert_email(system_info):
    # 检查是否需要告警
    alert_needed = False
    alert_messages = []
    
    if system_info['cpu_usage'] > 80:
        alert_needed = True
        alert_messages.append(f"CPU使用率过高: {system_info['cpu_usage']}%")
    
    if system_info['memory_usage'] > 80:
        alert_needed = True
        alert_messages.append(f"内存使用率过高: {system_info['memory_usage']}%")
    
    if system_info['disk_usage'] > 90:
        alert_needed = True
        alert_messages.append(f"磁盘使用率过高: {system_info['disk_usage']}%")
    
    if not alert_needed:
        return None, False
    
    # 构建邮件
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = recipient_email
    msg['Subject'] = f"系统告警 - {system_info['timestamp']}"
    
    # 邮件正文
    body = f"系统监控告警\n\n"
    body += f"监控时间: {system_info['timestamp']}\n\n"
    body += "告警信息:\n"
    for msg in alert_messages:
        body += f"- {msg}\n"
    
    body += "\n详细系统信息:\n"
    body += f"CPU使用率: {system_info['cpu_usage']}%\n"
    body += f"内存使用率: {system_info['memory_usage']}%\n"
    body += f"磁盘使用率: {system_info['disk_usage']}%\n"
    body += f"网络发送: {system_info['network_sent'] / 1024 / 1024:.2f} MB\n"
    body += f"网络接收: {system_info['network_recv'] / 1024 / 1024:.2f} MB\n"
    
    msg.attach(MIMEText(body, 'plain', 'utf-8'))
    
    return msg, True

# 发送告警邮件
def send_alert_email():
    system_info = get_system_info()
    msg, alert_needed = build_alert_email(system_info)
    
    if alert_needed:
        try:
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.starttls()
                server.login(sender_email, sender_password)
                server.send_message(msg)
            print(f"告警邮件已发送 - {system_info['timestamp']}")
        except Exception as e:
            print(f"告警邮件发送失败: {e}")
    else:
        print(f"系统正常，无需告警 - {system_info['timestamp']}")

# 运行监控
if __name__ == "__main__":
    send_alert_email()
```

### 2. 自动化报告生成与发送

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import os

# 邮件配置
smtp_server = 'smtp.example.com'
smtp_port = 587
sender_email = 'report@example.com'
sender_password = 'password'
recipient_email = 'manager@example.com'

# 生成报告数据
def generate_report_data():
    # 生成示例数据
    data = {
        '日期': pd.date_range(start='2023-01-01', end='2023-01-31'),
        '销售额': [1000, 1200, 900, 1500, 1800, 1300, 1400, 1600, 1700, 1900, 2000, 1800, 1700, 1600, 1500, 1400, 1300, 1200, 1100, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 500, 800]
    }
    return pd.DataFrame(data)

# 生成销售图表
def generate_sales_chart(data, output_path):
    plt.figure(figsize=(10, 6))
    plt.plot(data['日期'], data['销售额'], marker='o')
    plt.title('月度销售额趋势')
    plt.xlabel('日期')
    plt.ylabel('销售额')
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()

# 生成HTML报告
def generate_html_report(data):
    # 计算统计信息
    total_sales = data['销售额'].sum()
    avg_sales = data['销售额'].mean()
    max_sales = data['销售额'].max()
    min_sales = data['销售额'].min()
    
    # 生成HTML内容
    html_content = f"""
    <html>
    <head>
        <title>月度销售报告</title>
        <style>
            body {{ font-family: Arial, sans-serif; }}
            h1 {{ color: #333; }}
            .summary {{ background-color: #f0f0f0; padding: 10px; margin: 10px 0; }}
            table {{ border-collapse: collapse; width: 100%; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #4CAF50; color: white; }}
        </style>
    </head>
    <body>
        <h1>月度销售报告</h1>
        <p>报告生成时间: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        
        <div class="summary">
            <h2>销售摘要</h2>
            <p>总销售额: {total_sales} 元</p>
            <p>平均销售额: {avg_sales:.2f} 元</p>
            <p>最高销售额: {max_sales} 元</p>
            <p>最低销售额: {min_sales} 元</p>
        </div>
        
        <h2>销售额趋势图</h2>
        <img src="cid:sales_chart" alt="销售额趋势图" width="800">
        
        <h2>销售数据明细</h2>
        <table>
            <tr>
                <th>日期</th>
                <th>销售额(元)</th>
            </tr>
    """
    
    # 添加数据行
    for index, row in data.iterrows():
        html_content += f"""
            <tr>
                <td>{row['日期'].strftime('%Y-%m-%d')}</td>
                <td>{row['销售额']}</td>
            </tr>
        """
    
    html_content += """
        </table>
    </body>
    </html>
    """
    
    return html_content

# 发送报告邮件
def send_report_email():
    # 创建临时目录
    temp_dir = 'temp_report'
    os.makedirs(temp_dir, exist_ok=True)
    
    try:
        # 生成报告数据
        data = generate_report_data()
        
        # 生成销售图表
        chart_path = os.path.join(temp_dir, 'sales_chart.png')
        generate_sales_chart(data, chart_path)
        
        # 生成Excel报告
        excel_path = os.path.join(temp_dir, 'sales_report.xlsx')
        data.to_excel(excel_path, index=False)
        
        # 构建邮件
        msg = MIMEMultipart('related')
        msg['From'] = sender_email
        msg['To'] = recipient_email
        msg['Subject'] = f"月度销售报告 - {datetime.datetime.now().strftime('%Y-%m')}"
        
        # 生成HTML报告
        html_content = generate_html_report(data)
        msg.attach(MIMEText(html_content, 'html', 'utf-8'))
        
        # 内嵌图表
        with open(chart_path, 'rb') as f:
            img = MIMEApplication(f.read(), _subtype='png')
            img.add_header('Content-ID', '<sales_chart>')
            msg.attach(img)
        
        # 添加Excel附件
        with open(excel_path, 'rb') as f:
            excel_attach = MIMEApplication(f.read(), _subtype='vnd.openxmlformats-officedocument.spreadsheetml.sheet')
            excel_attach.add_header('Content-Disposition', 'attachment', filename='sales_report.xlsx')
            msg.attach(excel_attach)
        
        # 发送邮件
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(msg)
        
        print("报告邮件发送成功")
        
    except Exception as e:
        print(f"报告邮件发送失败: {e}")
    finally:
        # 清理临时文件
        for file in os.listdir(temp_dir):
            os.remove(os.path.join(temp_dir, file))
        os.rmdir(temp_dir)

# 运行报告生成与发送
if __name__ == "__main__":
    send_report_email()
```

## 十、总结

本章详细介绍了如何使用Python发送各种类型的邮件，包括：

1. **邮件发送基础**：SMTP协议、Python邮件发送库
2. **smtplib模块**：连接方式、认证、发送邮件
3. **email模块**：构建不同类型的邮件（纯文本、HTML、带附件、内嵌图片）
4. **常用邮件服务配置**：Gmail、QQ邮箱、163邮箱
5. **高级邮件发送功能**：批量发送、个性化发送、状态监控、异步发送
6. **第三方邮件库**：yagmail、sendgrid
7. **综合示例**：系统监控告警、自动化报告生成与发送

通过学习本章内容，你将能够在自动化脚本中集成各种邮件发送功能，实现报告自动化、系统监控告警等实用功能。在实际应用中，建议根据具体需求选择合适的邮件发送方式，并遵循最佳实践，确保邮件发送的安全性、可靠性和高效性。

## 十一、练习题

1. 编写一个Python脚本，发送一封纯文本邮件
2. 编写一个Python脚本，发送一封HTML邮件，包含表格和链接
3. 编写一个Python脚本，发送一封带附件的邮件
4. 编写一个Python脚本，发送一封内嵌图片的HTML邮件
5. 实现一个批量邮件发送脚本，支持发送给多个收件人
6. 实现一个系统监控脚本，当CPU或内存使用率超过阈值时发送告警邮件
7. 实现一个自动化报告脚本，生成销售数据报告并发送邮件
8. 使用yagmail库简化邮件发送
9. 实现邮件发送的重试机制
10. 为邮件发送功能添加日志记录

## 十二、参考资料

1. Python官方文档 - smtplib：https://docs.python.org/zh-cn/3/library/smtplib.html
2. Python官方文档 - email：https://docs.python.org/zh-cn/3/library/email.html
3. yagmail文档：https://github.com/kootenpv/yagmail
4. SendGrid文档：https://sendgrid.com/docs/
5. SMTP协议规范：https://tools.ietf.org/html/rfc5321
6. 邮件发送最佳实践：https://sendgrid.com/blog/email-best-practices/